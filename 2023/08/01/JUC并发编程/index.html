<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="博客 编程">
  
  
  <meta name="description" content="爱设计 | 爱开发 | 爱摄影 | 爱生活">
  
  <title>
    JUC并发编程 |
    
    程序猿-小陈
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-JUC并发编程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    JUC并发编程
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/08/01/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2023-08-01T11:40:09.000Z" itemprop="datePublished">2023-08-01</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h1 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h1><p><strong>栈和栈帧</strong></p>
<p>Java Virtual Machine Stacks （Java 虚拟机栈） </p>
<p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。 </p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 </li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<span id="more"></span>



<h1 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h1><h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a><strong>停止线程</strong></h2><p>一般来说线程执行完毕就会结束，无需手动关闭。但是如果我们想关闭一个正在运行的线程，有什么方法呢？可以看一下Thread类中提供了一个stop()方法，调用这个方法，就可以立即将一个线程终止，非常方便</p>
<p>但stop方法为何会被废弃而不推荐使用？stop方法过于暴力，强制把正在执行的方法停止了</p>
<p>大家是否遇到过这样的场景：<strong>电力系统需要维修，此时咱们正在写代码，维修人员直接将电源关闭了，代码还没保存的，是不是很崩溃，这种方式就像直接调用线程的stop方法类似。线程正在运行过程中，被强制结束了，可能会导致一些意想不到的后果。可以给大家发送一个通知，告诉大家保存一下手头的工作，将电脑关闭</strong></p>
<h2 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a><strong>打断线程</strong></h2><p>在java中，线程中断是一种重要的线程写作机制，从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。在上面中，我们已经详细讨论了stop方法停止线程的坏处，jdk中提供了更好的中断线程的方法，就是<strong>interrupt()方法，该方法可以打断线程</strong></p>
<p><strong>严格的说，打断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出了！至于目标线程接收到通知之后如何处理，则完全由目标线程自己决定</strong></p>
<p><strong><code>Interrupt</code>说明</strong></p>
<p><code>interrupt</code>的<strong>本质是将线程的打断标记设为true</strong>，并调用线程的三个parker对象（C++实现级别）unpark该线程</p>
<p>基于以上本质，有如下说明：</p>
<ul>
<li>打断线程不等于中断线程，有以下两种情况：<ul>
<li>打断正在运行中的线程并不会影响线程的运行，但如果线程监测到了打断标记为true，可以自行决定后续处理</li>
<li>打断阻塞中的线程会让此线程产生一个<code>InterruptedException</code>异常，结束线程的运行。但如果该异常被线程捕获住，该线程依然可以自行决定后续处理（终止运行，继续运行，做一些善后工作等等）</li>
</ul>
</li>
</ul>
<p><strong>注意细节：</strong></p>
<p>1.interrupt()方法为什么可以打断sleep,wait,join方法导致的线程阻塞呢？</p>
<p>网络上的原理解析说是这三个方法内部会不断的轮询打断标记状态是否为true，一旦为true则会抛出InterruptedException，结束线程的阻塞状态**(源码是native，未能验证其正确性)**</p>
<p><strong>2.interrupt()方法不能打断由于线程竞争重量级锁Monitor(synchronized)失败而导致线程进入的阻塞状态</strong></p>
<p>3.如果打断的是处于sleep，wait，join方法的线程(阻塞态)，系统会重置打断标志位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> <span class="comment">//中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> <span class="comment">//判断线程是否被中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span>  <span class="comment">//判断线程是否被中断，并清除当前中断状态</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">One</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">//因为打断sleep状态的线程，底层会清空打断标记，所以需要重新设置打断标注为true</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果调用的是线程暴力终止方法stop()，那么线程将不做任何处理直接停止，即下面的代码就不会执行</span></span><br><span class="line">                    <span class="comment">//如果调用的是优化后的线程终止方法interrupt()，线程会收到一个希望停止执行的通知，由线程本身决定是立即停止还是做好后续的处理再停止</span></span><br><span class="line">                    <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;优雅的中止&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//主线程休眠1s，等待t1线程运行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//中断t1线程 or 中断线程</span></span><br><span class="line"><span class="comment">//        t1.stop();</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，<strong>具体那个线程获取cpu的执行器还是得看cpu的任务调度器来决定</strong></p>
<p>cpu调度器有可能还把执行给回刚刚让出cpu执行的线程</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，任务调度器可以忽略它 </li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<h2 id="等待线程结束-join"><a href="#等待线程结束-join" class="headerlink" title="等待线程结束(join)"></a>等待线程结束(join)</h2><p><strong>join的作用和原理和wait基本一致，参考后面wait即可，但二者也有细微的差别，后面也有章节给出了详细的分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p>第1个方法表示无限等待，它会一直阻塞当前线程。直到目标线程执行完毕</p>
<p>第2个方法有个参数，用于指定等待时间，如果超过了给定的时间目标线程还在执行，当前线程也会停止等待，而继续往下执行。如果当目标线程早已运行结束，那么即使线程还没有到等待事件也会停止等待</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>概念：进程会等待所有非守护线程运行结束，进程才会结束。而进程不会等待守护线程运行结束，就要所有非守护运行线程结束，即使守护线程仍未结束，进程也会强行结束</p>
<p>守护线程的作用和应用场景暂时不清晰</p>
<h1 id="线程的五种状态及其转换"><a href="#线程的五种状态及其转换" class="headerlink" title="线程的五种状态及其转换"></a>线程的五种状态及其转换</h1><p>操作系统层面</p>
<p><img src="D:/VscodeProjects/source/_posts/操作系统层面，线程的五种状态.png" alt="操作系统层面，线程的五种状态"></p>
<p>Java-API层面</p>
<p><img src="D:/VscodeProjects/source/_posts/Java-Api层面，线程的六种状态.png" alt="Java-Api层面，线程的六种状态"></p>
<h1 id="共享模型之管程-Monitor"><a href="#共享模型之管程-Monitor" class="headerlink" title="共享模型之管程(Monitor)"></a>共享模型之管程(Monitor)</h1><h2 id="多线程操作共享数据带来的问题"><a href="#多线程操作共享数据带来的问题" class="headerlink" title="多线程操作共享数据带来的问题"></a>多线程操作共享数据带来的问题</h2><p><strong>线程安全问题产生的前提条件：多个线程同时操作共享数据</strong></p>
<p>那么产生线程安全问题的核心原因是什么呢？</p>
<p><strong>不能保证对共享数据的操作是原子性(下面有详细的原因分析)</strong></p>
<h3 id="Java代码示例"><a href="#Java代码示例" class="headerlink" title="Java代码示例"></a><strong>Java代码示例</strong></h3><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题分析-解决方案"><a href="#问题分析-解决方案" class="headerlink" title="问题分析&amp;解决方案"></a><strong>问题分析&amp;解决方案</strong></h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析 </p>
<p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>而对应 i– 也是类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>实际上任何操作都有获取值，将处理完的值写入到结果存储器中这两个操作。</p>
<p><strong>而问题产生的核心原因就在于一个线程因为cpu分配的时间片用完了而未能将处理完的值写入到结果中，导致其他获取到cpu执行权的线程对数据的操作都是无效的，因为当cpu再次切换到未执行完的原线程时，会覆盖此前一系列线程对数据的操作结果</strong></p>
<p>例如：当cpu重新将执行权分配给原来尚未执行写入结果操作的线程时，该线程会继续执行，也就是将刚才处理的结果写入到结果存储器中，就会完全覆盖其他线程对该数据的处理结果</p>
<p><strong>对原因更深一步分析：</strong></p>
<p><strong>实质就算线程交叉运行会导致线程互相覆盖彼此对数据的操作结果，进而产生错误的数据。用一个专业术语来描述就是没有保证线程操作的原子性</strong></p>
<p><strong>那么如何保证线程完全将操作执行完(线程操作的原子性)才让其他线程继续操作共享数据呢？</strong></p>
<p><strong>初步解决方案</strong>：能不能让线程将操作完全执行完再发生线程的上下文切换呢？</p>
<p>答案是不能，因为cpu分配的时间片有限，线程的上下文切换是必然会发生的，我们不可能等一个线程将操作完全执行完再发生线程的上下文切换的。</p>
<p><strong>最终解决方案：既然不能避免线程上下文的切换，那就让其他线程在原线程的操作尚未完全执行完全时，拒绝让其他线程访问共享数据，直到原线程的操作完全执行完才允许其他线程访问共享数据，用专业的术语来说就是实现线程的同步 or 互斥效果</strong></p>
<p><strong>那最终解决方案具体怎么实现呢？</strong></p>
<p>通过给操作的代码加锁即可实现</p>
<p><strong>锁的具体作用是什么呢？为什么给操作的代码加锁就可以实现了呢？</strong></p>
<p>锁的作用：要想对共享数据进行操作，必须获取相应的锁资源才能操作</p>
<p><strong>具体实现：</strong></p>
<p><strong>那么在加了锁的情况下就可以保证即使在cpu将执行权分配给了其他线程时，其他线程也操作不了共享数据，因为其他线程要想操作共享数据必须获取相应的锁资源，而此时锁资源一直在原线程手中并没有被释放</strong></p>
<p><strong>也就是其他线程要想操作共享数据必须等原线程释放锁，那么原线程只要保证在操作执行完再释放锁就可以实现操作的原子性了</strong></p>
<h3 id="synchronized实现加锁"><a href="#synchronized实现加锁" class="headerlink" title="synchronized实现加锁"></a>synchronized实现加锁</h3><p>在Java层面，典型的两种锁：对象锁和类锁</p>
<p>对象锁：只要是同一个对象，那使用的就是同一把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类锁：只要是同一个类，那使用就是同一把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><p><strong>分析变量是否是线程安全的核心点有两个：</strong></p>
<p>1.变量是否是共享数据</p>
<p>2.是否存在多线程对共享数据的操作</p>
<h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a><strong>成员变量和静态变量是否线程安全？</strong></h3><ul>
<li>如果它们没有共享，则线程安全 </li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 <ul>
<li>如果只有读操作，则线程安全 </li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a><strong>局部变量是否线程安全？</strong></h3><ul>
<li>局部变量是线程安全的 </li>
<li>但局部变量引用的对象则未必 <ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p><strong>普通的局部变量因为不是共享数据是不可能存在线程安全问题的</strong></p>
<p><strong>局部引用是因为可能会通过会暴露引用从而导致局部引用成为共享数据</strong></p>
<h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a><strong>局部变量线程安全分析</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</strong></p>
<p>局部变量的引用稍有不同 </p>
<p>先看一个成员变量的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="comment">// &#123; 临界区, 会产生竞态条件</span></span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">            <span class="comment">// &#125; 临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类执行方法代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_NUMBER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOOP_NUMBER</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test.method1(LOOP_NUMBER);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>因为ArrayList集合是共享数据，并且ArrayList集合的操作并没有对线程安全问题进行处理</strong></p>
<p><strong>具体分析：</strong></p>
<p>因为add不是线程安全的，2个线程同时执行add最后可能只add了一个元素，然后remove2次就报错了</p>
<p>通过观察add方法源码即可理解，添加元素发现线程安全问题的核心是size++，和前面分析的i++原理是一致的</p>
<p>异常分析：两个线程同时添加元素，同时获取size的值，此时一个线程添加完元素尚未执行完索引自增如0+1的操作，而另一个线程却获取到了错误的数据0，那么该线程将会继续对索引0的位置赋值，就会覆盖上一个线程已经添加的元素值。那么实际上只添加了一个元素执行了两次删除操作，自然就发生异常了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<p>将 list 修改为局部变量就不会有上述问题了，因为ArrayList集合不是共享数据了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会带来线程安全问题？ </p>
<p><strong>结论是有可能带来线程安全问题，因为可以通过子类重写父类方法的方式暴露局部引用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p>
</blockquote>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a><strong>常见线程安全类</strong></h3><ul>
<li>String </li>
<li>Integer </li>
<li>StringBuffer </li>
<li>Random </li>
<li>Vector </li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>它们的每个方法是原子的 </li>
<li>但注意它们多个方法的组合不是原子的，见后面分析</li>
</ul>
<p><strong>线程安全类方法的组合</strong></p>
<p>分析下面代码是否线程安全？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">	table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非常容易混淆的点：如果每个操作是原子性的，但操作之间的组合并非是原子性的</strong></p>
<p>就拿这个案例来分析：</p>
<p>线程 1：</p>
<p>时间点1：申请获取锁资源成功，调用table.get方法</p>
<p>时间点2：调用完table.get方法后，释放锁资源，再次申请锁资源失败，阻塞等待锁资源的释放</p>
<p>时间点3：仍在继续阻塞等待锁资源的释放</p>
<p>时间点4：申请锁资源成功，调用table.put方法，方法调用完毕</p>
<p>线程2：</p>
<p>时间点1：申请获取锁资源失败(因为线程1获取了锁资源)，无法调用table.get方法，阻塞等待锁资源的释放</p>
<p>时间点2：申请获取锁资源成功，调用table.get方法</p>
<p>时间点3：调用完table.get方法后，释放锁资源，但此时再次由线程2比线程1先申请成功获取锁资源</p>
<p>时间点4：执行table.put完方法，执行完释放锁资源</p>
<p><strong>从这个案例可以很清晰的看出，两个线程的操作一直在交叉执行</strong></p>
<p><strong>很明显，虽然每个操作都是原子性的，但每个操作执行完后会释放锁资源，此时另一个线程就可以获取到锁资源并执行相关的操作，所以即使每个操作都是原子性的，但并不能保证操作之间的组合是原子性的</strong></p>
<p><strong>不可变类线程安全性</strong></p>
<p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？</p>
<p><strong>不可变类线程安全的核心：因为不可变类中的数据是不能改变的，所以不可能存在对共享数据的写操作，自然就会出现线程安全问题了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Immutable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Immutable</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想增加一个增加的方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Immutable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Immutable</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Immutable <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Immutable</span>(<span class="built_in">this</span>.value + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>例题概括：<strong>因为Tomcat中的servlet是单例的，所以Servlet中的成员变量都是共享数据，如果没有对共享数据进行线程安全的处理(操作的原子性)，那么都会存在线程安全问题</strong></p>
<p>例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 是否安全？是，因为是不可变的</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">// 是否安全？是，因为是不可变的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用上述变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？ 否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 记录调用次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？ 否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例4:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 是否安全？是，因为方法内部都是局部变量，不存在共享数据</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例5:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全?否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为是共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//是否安全？是，因为UserDao是局部变量，不存在共享数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？否，因为UserDaoImpl是同一个 对象，那么Connection就是共享数据了</span></span><br><span class="line">    <span class="type">private</span> <span class="variable">Connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例7:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 是否安全？否，虽然sdf是局部引用，但是抽象方法存在暴露局部引用的可能</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        foo(sdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中 foo 的行为是不确定的，存在暴露局部引用的可能</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;1999-10-11 00:00:00&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sdf.parse(dateStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a><strong>Java 对象头</strong></h3><p>以 32 位虚拟机为例</p>
<p>普通对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                    Object Header (64 bits)                   </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|       <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)          |<span class="params">   Klass Word (32 bits)  </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                             Object Header (96 bits)                             </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params">        Mark Word(32bits)       </span>|   <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits)  |<span class="params">  array length(32bits)  </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure>

<p>其中 <strong>Mark Word 结构</strong>为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                  <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)                  |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|    <span class="symbol">hashcode:</span><span class="number">25</span>  |<span class="params"> age:4 </span>|   <span class="symbol">biased_lock:</span><span class="number">0</span>   |<span class="params">   01    </span>|       <span class="title class_">Normal</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">thread:23</span>|<span class="symbol">epoch:</span><span class="number">2</span>|<span class="params"> age:4 </span>|   <span class="symbol">biased_lock:</span><span class="number">1</span>   |<span class="params">   01    </span>|       <span class="title class_">Biased</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">          ptr_to_lock_record:30              </span>|   <span class="number">00</span>    |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|          <span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>      |<span class="params">   10    </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                                             </span>|   <span class="number">11</span>    |<span class="params">    Marked <span class="keyword">for</span> GC   </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<p>64 位虚拟机 Mark Word</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                          <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits)                       |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params">  01   </span>|        <span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:54 </span>|   <span class="symbol">epoch:</span><span class="number">2</span>   |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>|  <span class="number">01</span>   |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                    <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                   |<span class="params">  00   </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                 ptr_to_heavyweight_monitor:62              </span>|  <span class="number">10</span>   |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                            |<span class="params">  11   </span>|    <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span>   |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26357186/what-is-in-java-object-header">https://stackoverflow.com/questions/26357186/what-is-in-java-object-header</a></p>
</blockquote>
<h3 id="原理之Monitor-锁"><a href="#原理之Monitor-锁" class="headerlink" title="原理之Monitor(锁)"></a><font color='blue'>原理之Monitor(锁)</font></h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong> </p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针 </p>
<p><strong>Monitor锁：实际上对象不是真正的锁，对象只是在对象头中保存了真正的锁的引用</strong></p>
<p>Monitor 结构如下</p>
<p><img src="D:/VscodeProjects/source/_posts/Monitor结构.png" alt="Monitor结构"></p>
<p><strong>如何通过Monitor锁来实现线程安全呢(加锁原理&amp;&amp;实现原理)？</strong></p>
<p>1.如果一个线程想要加锁，那么他就会跟Monitor锁形成关联(关联就是对象头会保存Monitor锁的引用)</p>
<p>2.线程和锁形成关联后，线程会通过锁的Owner值判断该锁是否已经有主人了(是否被其他线程占有了)，如果没有Owner为null，证明该锁没有主人，线程就会把Owner值设置为自己的线程id，标识自己获取了这把锁</p>
<p>3.当另一个线程也想要加锁时，那么该线程也会跟同一个Monitor锁形成关联，通过判断锁的Owner值判断锁是否已经被其他线程占有，如果Owner值不为空，说明已经被其他线程占有，那么此线程就会将自己的线程状态从运行状态切换为阻塞状态并进入Monitor锁的等待队列EntryList中</p>
<p>4.占有锁的线程如何释放锁？释放锁会做些什么操作？</p>
<p>占有锁的线程会将Owner值重写置为Null，并唤醒等待队列中正在等待的线程，然后接触和Monitor锁的关联，此时已经被唤醒的线程会重新竞争锁</p>
<p><strong>小细节：</strong></p>
<p>因为对象头的存储空间有限，对象头是使用本来存储 hashcode:25  | age:4 |   biased_lock:0 的空间来存储Monitor锁的引用，那么对象头本来的hashcode,age,biased_lock的数据是交给了Monitor锁来暂时存储的，等到释放锁时二者再重新交换，恢复对象头的MarkWork结构</p>
<blockquote>
<p><strong>注意</strong>： </p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果 </li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
</blockquote>
<h3 id="原理之-synchronized"><a href="#原理之-synchronized" class="headerlink" title="原理之 synchronized"></a><font color='blue'>原理之 synchronized</font></h3><p>从<strong>JVM的字节码角度</strong>讲述synchronized原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">              flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">              Code:</span><br><span class="line">              stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">              <span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// &lt;- lock引用 （synchronized开始）</span></span><br><span class="line">              <span class="number">3</span>: dup</span><br><span class="line">              <span class="number">4</span>: astore_1 <span class="comment">// lock引用 -&gt; slot 1</span></span><br><span class="line">              <span class="number">5</span>: monitorenter <span class="comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span></span><br><span class="line">              <span class="number">6</span>: getstatic #<span class="number">3</span> <span class="comment">// &lt;- i</span></span><br><span class="line">              <span class="number">9</span>: iconst_1 <span class="comment">// 准备常数 1</span></span><br><span class="line">              <span class="number">10</span>: iadd <span class="comment">// +1</span></span><br><span class="line">              <span class="number">11</span>: putstatic #<span class="number">3</span> <span class="comment">// -&gt; i</span></span><br><span class="line">              <span class="number">14</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line">              <span class="number">15</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">              <span class="number">16</span>: goto <span class="number">24</span></span><br><span class="line">              <span class="number">19</span>: astore_2 <span class="comment">// e -&gt; slot 2 </span></span><br><span class="line">              <span class="number">20</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line">              <span class="number">21</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">              <span class="number">22</span>: aload_2 <span class="comment">// &lt;- slot 2 (e)</span></span><br><span class="line">              <span class="number">23</span>: athrow <span class="comment">// throw e</span></span><br><span class="line">              <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">              Exception table:</span><br><span class="line">              from to target type</span><br><span class="line">              <span class="number">6</span>    <span class="number">16</span>  <span class="number">19</span>    any</span><br><span class="line">              <span class="number">19</span>   <span class="number">22</span>  <span class="number">19</span>    any</span><br><span class="line">              LineNumberTable:</span><br><span class="line">              line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">              line <span class="number">9</span>: <span class="number">6</span></span><br><span class="line">              line <span class="number">10</span>: <span class="number">14</span></span><br><span class="line">              line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line">              LocalVariableTable:</span><br><span class="line">              Start Length Slot Name Signature</span><br><span class="line">              <span class="number">0</span>     <span class="number">25</span>     <span class="number">0</span>    args [Ljava/lang/String;</span><br><span class="line">              StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">              frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">              offset_delta = <span class="number">19</span></span><br><span class="line">              locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">              stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">              frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">              offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>从JVM的字节码清晰可以看出加锁的原理</p>
<p>加锁过程就是对象头(MarkWork结构属于对象头的内部结构)保存了Monitor锁的引用</p>
<p>解锁过程就是唤醒等待队列中的线程并解除跟Monitor锁的关联(重置对象头的MarkWork结构)</p>
<p><strong>重置对象头的MarkWork结构实际上就是将对象头中存储的Mointor锁引用和锁暂时存储的对象头的MarkWork结构信息进行交换，恢复对象头MarkWork结构的信息</strong></p>
<h3 id="原理之-synchronized-进阶"><a href="#原理之-synchronized-进阶" class="headerlink" title="原理之 synchronized 进阶"></a><font color='blue'>原理之 synchronized 进阶</font></h3><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><strong>轻量级锁的使用场景：</strong></p>
<p>如果一个对象虽然有多线程要加锁，但他们加锁的时间是错开的，也就是不存在多线程<strong>同时</strong>访问共享资源的情况，就基本不会出现线程安全问题，那么就可以使用轻量级锁来优化重量级的Monitor锁</p>
<p><strong>为什么需要优化Monitor锁?</strong></p>
<p>Monitor锁属于操作系统层面的锁，涉及操作系统的资源调配和线程的上下文切换，对性能的消耗是非常大的，所以称其为重量级的锁</p>
<p><strong>为什么明明已经不存在同时访问共享资源的情况，也就是不存在线程安全问题了，还要加轻量级锁呢？</strong></p>
<p>因为我们不能保证一定没有<strong>同时</strong>访问共享资源的情况，要做好如果真的出现同时访问共享资源的安全处理</p>
<p><strong>轻量级锁加锁原理：</strong></p>
<p>1.轻量级锁是使用<strong>线程栈的一个锁记录结构来实现的</strong>，每一个栈的栈帧都会包含一个锁记录结构</p>
<p>2.线程如果想要加锁，首先先判断锁对象的对象头MarkWork结构是否已经保存了其他锁记录的引用信息，如果已经保存了其他锁记录的引用信息，证明该锁已经被其他线程持有，加锁失败</p>
<p>3.如果没有保存其他锁记录的引用信息，则让锁记录和锁对象进行CAS操作，如果CAS操作成功，则标识着线程成功加锁，如果CAS操作失败则加锁失败</p>
<p><strong>CAS操作分为三步：</strong></p>
<p>1.获取锁对象的对象头MarkWork结构的值</p>
<p>2.将获取到的MarkWrok结构的值与锁对象的MarkWork结构的值相比较，<strong>如果相同则证明在加锁过程中没有其他线程干扰</strong></p>
<p>3.如果相同则会让锁记录的引用地址信息和锁对象的对象头MarkWork结构信息进行交换，交换成功即上锁成功</p>
<p><strong>轻量级锁解锁原理</strong></p>
<p>锁记录和锁对象使用CAS操作，如果交换成功则解锁成功，如果交换失败，则说明轻量级锁已经升级为重量级锁，进入重量级锁的解锁流程(重量级级锁的解锁原理上面有)</p>
<p><strong>细节：</strong></p>
<p>如果轻量锁加锁失败则会进行锁膨胀  or  累加锁的重入次数LockRecord</p>
<p>如果是因为同一个线程重复加锁，则会累加锁的重入次数，如果是因为有其他线程同时竞争锁(同时访问共享资源)，则会进行锁膨胀，锁膨胀就是将轻量级锁升级为重量级锁。因为存在线程安全问题，只能升级为重量级锁解决线程安全问题了</p>
<p><strong>案例演示</strong></p>
<p>轻量级锁对使用者是透明的，即语法仍然是 synchronized </p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建锁记录（Lock Record）对象，<strong>每个线程栈的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/线程栈帧存储锁记录.png" alt="线程栈帧存储锁记录"></p>
</li>
<li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</p>
<p><img src="D:/VscodeProjects/source/_posts/锁记录指向锁对象&CAS操作.png" alt="锁记录指向锁对象&amp;CAS操作"></p>
</li>
<li><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="D:/VscodeProjects/source/_posts/CAS操作成功.png" alt="CAS操作成功"></p>
</li>
<li><p>如果 cas 失败，有两种情况 </p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/CAS操作失败之可重入的情况.png" alt="CAS操作失败之可重入的情况"></p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</p>
<p><img src="D:/VscodeProjects/source/_posts/轻量级锁解锁时如果有重入，则重入记录-1.png" alt="轻量级锁解锁时如果有重入，则重入记录-1"></p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用cas将Mark Word的值恢复给对象头 </p>
<ul>
<li>成功，则解锁成功 </li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（<strong>有竞争</strong>），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/线程竞争访问锁资源导致锁膨胀.png" alt="线程竞争访问锁资源导致锁膨胀"></p>
<ul>
<li>这时 Thread-1 加轻量级锁失败，进入<strong>锁膨胀流程</strong></li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/锁膨胀流程.png" alt="锁膨胀流程"></p>
<p>1.即为Object 对象(锁对象)<strong>申请 Monitor 锁</strong>，让 <strong>Object 指向重量级锁地址</strong>(锁对象不再保存锁记录的引用地址)</p>
<p>2.然后自己进入 Monitor 的 <strong>EntryList 等待队列</strong>中，并将自己的线程状态切换为阻塞状态		</p>
<p>3.当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入<strong>重量级解锁流程</strong>，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞</p>
<p><strong>实质上是通过避免线程状态的切换(从运行态切换为阻塞太)，从而节约操作系统的资源，进而提高操作的性能</strong> </p>
<p>自旋重试成功的情况</p>
<table>
<thead>
<tr>
<th align="center">线程1 (  core 1上)</th>
<th align="center">对象Mark</th>
<th align="center">线程2 ( core 2上)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">10（重量锁）</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">访问同步块，获取monitor</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">成功（加锁）</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10(重量锁）重量锁指针</td>
<td align="center">访问同步块，获取 monitor</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行完毕</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">成功（解锁）</td>
<td align="center">01（无锁）</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">成功（加锁)</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">执行同步块</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>自旋重试失败的情况</p>
<table>
<thead>
<tr>
<th align="center">线程1 ( core 1上)</th>
<th align="center">对象Mark</th>
<th align="center">线程2( core 2上)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">10（重量锁）</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">访问同步块，获取monitor</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">成功（加锁)</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">访问同步块，获取monitor</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</li>
<li><strong>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能</strong> </li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作，而CAS操作仍会消耗一定的性能</strong></p>
<p><strong>优化方案：</strong>既然只有一个线程在操作了，并不存在其他线程干扰的问题，那能不能在重入锁时不需要执行CAS操作呢，只需要判断一下是不是自己的锁即可呢？</p>
<p>答案是能，用偏向锁优化轻量级锁即可</p>
<p>偏向锁来做进一步优化轻量级锁：</p>
<p><strong>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有</strong> </p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>轻量级锁优化前后对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">subgraph 偏向锁</span><br><span class="line">t5(&quot;m1内调用synchronized(obj)&quot;)</span><br><span class="line">t6(&quot;m2内调用synchronized(obj)&quot;)</span><br><span class="line">t7(&quot;m2内调用synchronized(obj)&quot;)</span><br><span class="line">t8(对象)</span><br><span class="line">t5 -.用ThreadID替换MarkWord.-&gt; t8</span><br><span class="line">t6 -.检查ThreadID是否是自己.-&gt; t8</span><br><span class="line">t7 -.检查ThreadID是否是自己.-&gt; t8</span><br><span class="line">end</span><br><span class="line">subgraph 轻量级锁</span><br><span class="line">t1(&quot;m1内调用synchronized(obj)&quot;)</span><br><span class="line">t2(&quot;m2内调用synchronized(obj)&quot;)</span><br><span class="line">t3(&quot;m2内调用synchronized(obj)&quot;)</span><br><span class="line">t1 -.生成锁记录.-&gt; t1</span><br><span class="line">t2 -.生成锁记录.-&gt; t2</span><br><span class="line">t3 -.生成锁记录.-&gt; t3</span><br><span class="line">t4(对象)</span><br><span class="line">t1 -.用锁记录替换markword.-&gt; t4</span><br><span class="line">t2 -.用锁记录替换markword.-&gt; t4</span><br><span class="line">t3 -.用锁记录替换markword.-&gt; t4</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h5><p>回忆一下对象头格式</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                          <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits)                       |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params">  01   </span>|        <span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:54 </span>|   <span class="symbol">epoch:</span><span class="number">2</span>   |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>|  <span class="number">01</span>   |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                    <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                   |<span class="params">  00   </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                 ptr_to_heavyweight_monitor:62              </span>|  <span class="number">10</span>   |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                            |<span class="params">  11   </span>|    <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span>   |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure>

<p>一个对象创建时： </p>
<ul>
<li>如果开启了偏向锁（<strong>默认开启</strong>），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 </li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数<code>- XX:BiasedLockingStartupDelay=0</code>来禁用延迟 </li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<p><strong>实质就是用对象头的MarkWork结构的倒数第三位表示是否启动偏向锁，如果是0表示未启用，如果是1表示启用偏向锁</strong></p>
<p>1） 测试延迟特性 </p>
<p>2） 测试偏向锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="type">ClassLayout</span> <span class="variable">classLayout</span> <span class="operator">=</span> ClassLayout.parseInstance(d);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;synchronized 前&quot;</span>);</span><br><span class="line">        System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;synchronized 中&quot;</span>);</span><br><span class="line">            System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;synchronized 后&quot;</span>);</span><br><span class="line">        System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11:08:58.117 c.TestBiased [t1] - synchronized 前</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 </span><br><span class="line">11:08:58.121 c.TestBiased [t1] - synchronized 中</span><br><span class="line">00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 </span><br><span class="line">11:08:58.121 c.TestBiased [t1] - synchronized 后</span><br><span class="line">00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<p>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p>
</blockquote>
<p>3）测试禁用 </p>
<p>在上面测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁 </p>
<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11:13:10.018 c.TestBiased [t1] - synchronized 前</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">11:13:10.021 c.TestBiased [t1] - synchronized 中</span><br><span class="line">00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000 </span><br><span class="line">11:13:10.021 c.TestBiased [t1] - synchronized 后</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br></pre></td></tr></table></figure>

<p>4)测试 hashCode </p>
<ul>
<li><strong>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</strong></li>
</ul>
<h5 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h5><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销 </p>
<p><strong>因为对象头的空间有限，如果存储了hashCode就没有额外的空间存储线程id了</strong></p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode </li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
<p>在调用 hashCode 后使用偏向锁，记得去掉<code>-XX:-UseBiasedLocking </code></p>
<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015 </span><br><span class="line">11:22:10.391 c.TestBiased [t1] - synchronized 前</span><br><span class="line">00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 </span><br><span class="line">11:22:10.393 c.TestBiased [t1] - synchronized 中</span><br><span class="line">00000000 00000000 00000000 00000000 00100000 11000011 11110011 01101000 </span><br><span class="line">11:22:10.393 c.TestBiased [t1] - synchronized 后</span><br><span class="line">00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 </span><br></pre></td></tr></table></figure>



<h5 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h5><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
<p><strong>因为有其他锁使用偏向锁对象，证明存在多个线程同时访问共享资源的去情况，必须将锁升级未轻量级锁，只有轻量级锁在遇到线程安全问题时将锁升级重量级锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">            TestBiased.class.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span></span><br><span class="line">        <span class="comment">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span></span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment"> System.in.read();</span></span><br><span class="line"><span class="comment"> &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment"> e.printStackTrace();</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TestBiased.class.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 </span><br><span class="line">[t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 </span><br><span class="line">[t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 </span><br><span class="line">[t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br></pre></td></tr></table></figure>



<h5 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait&#x2F;notify"></a>撤销 - 调用 wait&#x2F;notify</h5><p><strong>因为wait&#x2F;notify本身就是重量级锁的api,如果在偏向锁中要想使用重量级锁的api，必须将偏向锁升级为重量级锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                d.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;notify&quot;</span>);</span><br><span class="line">            d.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 </span><br><span class="line">[t1] - 00000000 00000000 00000000 00000000 00011111 10110011 11111000 00000101 </span><br><span class="line">[t2] - notify </span><br><span class="line">[t1] - 00000000 00000000 00000000 00000000 00011100 11010100 00001101 11001010 </span><br></pre></td></tr></table></figure>



<h5 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a><strong>批量重偏向</strong></h5><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID </p>
<p><strong>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程</strong></p>
<p><strong>案例演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            list.add(d);</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            list.notify();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出验证</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - ===============&gt; </span><br><span class="line">[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br></pre></td></tr></table></figure>

<h5 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h5><p><strong>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1,t2,t3;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">loopNumber</span> <span class="operator">=</span> <span class="number">39</span>;</span><br><span class="line">    t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            list.add(d);</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t3);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    t3.start();</span><br><span class="line">    t3.join();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Dog</span>()).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料 </p>
<p><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LemonFive/p/11246086.html">https://www.cnblogs.com/LemonFive/p/11246086.html</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LemonFive/p/11248248.html">https://www.cnblogs.com/LemonFive/p/11248248.html</a> </p>
<p>[偏向锁论文](<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing (oracle.com)</a>)</p>
</blockquote>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除：<strong>Java编译器会自行优化实际上不需要加锁的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations=3)</span></span><br><span class="line"><span class="meta">@Measurement(iterations=5)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//因为o是局部变量，每次方法进栈都会new一个新的Object对象，所以实际上每次不同的线程进来获取的都不是同一把锁，根本就没有竞争锁资源的情况发生，根本就不需要锁，所以Java编译器会自行消除锁</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>a方法没有加锁和b方法加了锁的性能对比，二者性能差异不大，证明Java编译器底层对b方法进行了消除锁的优化</strong></p>
<p><code>java -jar benchmarks.jar</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark 			Mode 		Samples 	Score 		Score error 	Units </span><br><span class="line">c.i.MyBenchmark.a 	avgt 		5 			1.542 			0.056 		ns/op </span><br><span class="line">c.i.MyBenchmark.b 	avgt 		5 			1.518 			0.091 		ns/op </span><br></pre></td></tr></table></figure>

<p><code>java -XX:-EliminateLocks -jar benchmarks.jar</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark 			Mode 		Samples 		Score 		Score error 	Units </span><br><span class="line">c.i.MyBenchmark.a 	avgt 		5 				1.507 		0.108 			ns/op </span><br><span class="line">c.i.MyBenchmark.b 	avgt 		5 				16.976 		1.572 			ns/op</span><br></pre></td></tr></table></figure>



<p>锁粗化 </p>
<p>对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.Monitor是什么？</p>
<p>Monitor是一种重量级锁的数据结构，他有waitset等待队列,entrylist阻塞队列，owner锁的主人三种属性，waitset存储阻塞类型为wating，timed_waiting状态的线程，而entrylist则存储blocked状态的线程，owner存储锁的主人，即线程id</p>
<p>2.为什么需要重量级锁Monitor？</p>
<p>因为重量级锁Monitor可以实现线程访问共享资源的串行性，进而解决并发线程中的线程安全问题</p>
<p>3.如何使用重量级锁？</p>
<p>使用synchronized关键字配合重量级锁的相关功能api(如wait,notify,notifyAll)即可，需要深入理解synchronized关键字的原理，重量级锁Monitor的结构以及重量级锁的每一个功能api的实现原理才能合理的使用重量级锁</p>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><h4 id="原理之-wait-notify"><a href="#原理之-wait-notify" class="headerlink" title="原理之 wait &#x2F; notify"></a><font color='blue'>原理之 wait &#x2F; notify</font></h4><p><strong>wait&#x2F;notify是属于重量级锁Monitor的相关功能，所以其原理和重量级锁Monitor结构有很大的关联</strong></p>
<p>![wait and notify原理](D:&#x2F;VscodeProjects&#x2F;source&#x2F;_posts&#x2F;wait and notify原理.png)</p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，<strong>即可进入 WaitSet等待队列变为 WAITING 状态</strong> </li>
<li><strong>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</strong> </li>
<li><strong>BLOCKED 线程会在 Owner 线程释放锁时唤醒</strong> </li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li>
</ul>
<h4 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a><strong>API 介绍</strong></h4><ul>
<li><code>obj.wait()</code> 让进入 object 监视器的线程到 waitSet 等待 </li>
<li><code>obj.notify()</code> 在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li>
<li><code>obj.notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法，且都需要获取了重量级锁资源之后才能调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">// 主线程两秒后执行</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        obj.notify(); <span class="comment">// 唤醒obj上一个线程</span></span><br><span class="line">        <span class="comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notify 的一种结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">20:00:53.096 [Thread-0] c.TestWaitNotify - 执行.... </span><br><span class="line">20:00:53.099 [Thread-1] c.TestWaitNotify - 执行.... </span><br><span class="line">20:00:55.096 [main] c.TestWaitNotify - 唤醒 obj 上其它线程</span><br><span class="line">20:00:55.096 [Thread-0] c.TestWaitNotify - 其它代码.... </span><br></pre></td></tr></table></figure>

<p>notifyAll 的结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">19:58:15.457 [Thread-0] c.TestWaitNotify - 执行.... </span><br><span class="line">19:58:15.460 [Thread-1] c.TestWaitNotify - 执行.... </span><br><span class="line">19:58:17.456 [main] c.TestWaitNotify - 唤醒 obj 上其它线程</span><br><span class="line">19:58:17.456 [Thread-1] c.TestWaitNotify - 其它代码.... </span><br><span class="line">19:58:17.456 [Thread-0] c.TestWaitNotify - 其它代码.... </span><br></pre></td></tr></table></figure>

<p><code>wait()</code> 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 notify 为止</p>
<p><code>wait(long n)</code> 有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p>
<h4 id="wait-notify-的正确用法"><a href="#wait-notify-的正确用法" class="headerlink" title="wait notify 的正确用法"></a>wait notify 的正确用法</h4><p>开始之前先看看 </p>
<h5 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a><code>sleep(long n)</code> 和 <code>wait(long n)</code> 的区别</h5><ol>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法</li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用</li>
<li><strong>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</strong></li>
<li>它们 状态 TIMED_WAITING</li>
</ol>
<p><strong>核心共同点：都会让出CPU的执行权</strong></p>
<p><strong>核心区别：sleep方法不会释放锁资源，而wait方法会释放锁资源</strong></p>
<h5 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>思考下面的解决方案好不好，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">    hasCigarette = <span class="literal">true</span>;</span><br><span class="line">    log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20:49:49.883 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:49:49.887 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:49:50.882 [送烟的] c.TestCorrectPosture - 烟到了噢！</span><br><span class="line">20:49:51.887 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">true</span>] </span><br><span class="line">20:49:51.887 [小南] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>其它干活的线程，都要一直阻塞，效率太低(就是因为sleep方法不会释放锁资源)</strong> </li>
<li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来 <strong>(sleep方法缺乏notify的及时唤醒机制)</strong></li>
<li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加 synchronized 就好像 main 线程是翻窗户进来的 </li>
<li>解决方法，使用 wait - notify 机制</li>
</ul>
<h5 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h5><p>思考下面的实现行吗，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasCigarette = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解决了其它干活的线程阻塞的问题</strong> </li>
<li><strong>但如果有其它线程也在等待条件呢？</strong></li>
</ul>
<h5 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20:53:12.173 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:53:12.176 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:53:12.176 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line">20:53:12.176 [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line">20:53:13.174 [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line">20:53:13.174 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:53:13.174 [小南] c.TestCorrectPosture - 没干成活... </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线 程，称之为【虚假唤醒】</strong></p>
<p>就比如案例中明明是想唤醒送外卖的线程但却随机唤醒了送烟的线程… </p>
</li>
<li><p>解决方法，改为 notifyAll</p>
</li>
</ul>
<h5 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20:55:23.978 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:55:23.982 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:55:23.982 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line">20:55:23.982 [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line">20:55:24.979 [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line">20:55:24.979 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line">20:55:24.980 [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:55:24.980 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:55:24.980 [小南] c.TestCorrectPosture - 没干成活... </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</strong></li>
</ul>
<p>就比如案例中虽然正确唤醒送外卖的线程，但与此同时也会唤醒送烟的线程，并且其实送烟的线程此时还没有烟这个资源就被唤醒了，应该继续等待下一次的唤醒，但使用if+wait只有一次判断是否有送烟的资源，如果第一次唤醒没有烟的资源送过来，那后续就再也没有机会唤醒送烟的线程了</p>
<p><strong>核心：实际上就是notifyAll会唤醒所有线程，导致除了真正获取到相应的资源的线程可以继续执行外，其他线程都是被虚假唤醒的，应再次进入等待状态(阻塞状态)，等待唤醒，而If+wait只有一次判断资源和等待的机会，如果因为虚假唤醒了，就再也没有机会进入等待状态等待相应的资源再唤醒了</strong></p>
<ul>
<li><strong>解决方法，用 while + wait，当条件不成立，再次 wait</strong></li>
</ul>
<h5 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h5><p>将 if 改为 while</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        room.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改动后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        room.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有线程被唤醒才会接着while，不唤醒就是wait，所以不会有cpu空转</p>
<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">20:58:34.322 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:58:34.326 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:58:34.326 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line">20:58:34.326 [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line">20:58:35.323 [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line">20:58:35.324 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line">20:58:35.324 [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:58:35.324 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br></pre></td></tr></table></figure>



<h5 id="正确用法"><a href="#正确用法" class="headerlink" title="正确用法"></a><strong>正确用法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">//1.while循环保证有多次判断资源并唤醒线程的机会，避免出现只有一次判断资源和唤醒的机会(if)</span></span><br><span class="line">    <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">//2.notifyAll保证一定能够唤醒正确的线程(因为他会唤醒所有线程，所有线程里面必然有一个是正确的线程)</span></span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1.wait&#x2F;notify&#x2F;notifyAll是什么？</p>
<p>wait&#x2F;notify&#x2F;notifyAll是重量级锁的功能api，可以实现让当前运行线程释放锁，还可以唤醒正处于waiting状态的线程</p>
<p><strong>2.为什么需要wait&#x2F;notify?他的使用场景是什么？</strong></p>
<p>让获取了锁资源但缺乏其他资源不能有效运行的线程及时的释放掉锁资源，让其他线程能够及时的获取锁资源执行相应的任务，大大提高了线程的并发性</p>
<p>3.如何使用wait&#x2F;notify&#x2F;notifyAll?</p>
<p>需要搭配synchronized关键字使用，而且必须获取了锁资源之后才能使用(也就是必须在synchronized同步代码内使用)</p>
<p><strong>那为什么必须获取到锁资源才能调用这几个方法呢？</strong></p>
<p><strong>A.首先wait方法本身就是针对获取了锁资源但缺乏其他资源不能及时有效运行从而导致锁资源没有得到及时释放的场景，所以调用wait方法必须先获取锁资源才能释放锁资源呀</strong></p>
<p>B.notify&#x2F;notifyAll，从wait()原理上来理解，一旦调用了wait方法及时释放了锁资源，线程的状态就会变成Wating状态(也属于阻塞状态的一种)，进入到等待队列WaitSet中，而等待队列WaitSet属于锁资源的一部分，如果你不先获取到锁资源，那么你怎么能获取到等待队列WaitSet，进而唤醒队列中的线程呢</p>
<p>4.注意细节：</p>
<p>调用了wait()方法一定要调用相应的notify&#x2F;notifyAll方法唤醒线程，否则线程将一直阻塞下去，程序也会因为有非守护线程没执行完而一直不能结束</p>
<p>一句话概括注意细节：</p>
<p><strong>wait和notify&#x2F;notifyAll一定要成对出现，有多少个wait就要有多少个notify&#x2F;notifyAll</strong></p>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><h3 id="保护性暂停模式通信"><a href="#保护性暂停模式通信" class="headerlink" title="保护性暂停模式通信"></a>保护性暂停模式通信</h3><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a><strong>1.定义</strong></h5><p><strong>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果，实现线程之间相互传输结果(线程间的通信)</strong></p>
<p>要点 </p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，<strong>让他们关联同一个 GuardedObject(存储线程之间通信数据的存储空间)</strong> </li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者） </li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式 </li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/保护性暂停模式原理图.png" alt="保护性暂停模式原理图"></p>
<p><strong>保护性暂停模式的特点：</strong></p>
<p>1.线程与线程之间只能是<strong>一一对应关系</strong>的</p>
<p>2.线程与线程之间的结果传输(通信)是同步的，<strong>为什么说是同步的呢？</strong></p>
<p><strong>因为生产者和消费者是一一对应关系的，生产者生产好消息后将消息设置在公共的数据存储空间中，消费者立马就可以获取</strong></p>
<h5 id="2-原理实现-无超时时间"><a href="#2-原理实现-无超时时间" class="headerlink" title="2.原理实现(无超时时间)"></a><strong>2.原理实现(无超时时间)</strong></h5><p><strong>如果wait()没有设置超时时间，一定要调用notify&#x2F;notifyAll方法手动唤醒正在等待的线程，否则等待的线程会一直阻塞下去</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 条件不满足则等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="comment">//手动唤醒等待线程</span></span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>一个线程等待另一个线程的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟线程生产数据和获取数据的过程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">&quot;生产数据开始...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟生产数据需要2s</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;生产数据完成...&quot;</span>);</span><br><span class="line">            guardedObject.complete(data);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取数据开始...&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> (String) guardedObject.get();</span><br><span class="line">            log.info(<span class="string">&quot;获取数据完成...数据是&quot;</span>+data);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:12:29.444 [t2] INFO com.czq.GuardedObject - 获取数据开始...</span><br><span class="line">11:12:29.444 [t1] INFO com.czq.GuardedObject - 生产数据开始...</span><br><span class="line">11:12:31.455 [t1] INFO com.czq.GuardedObject - 生产数据完成...</span><br><span class="line">11:12:31.455 [t2] INFO com.czq.GuardedObject - 获取数据完成...数据是data</span><br></pre></td></tr></table></figure>



<h5 id="原理实现-有超时时间"><a href="#原理实现-有超时时间" class="headerlink" title="原理实现(有超时时间)"></a><strong>原理实现(有超时时间)</strong></h5><p><strong>如果要控制超时时间呢</strong></p>
<p><strong>控制超时的核心点：</strong></p>
<p><strong>1.如何实时计算剩余的等待时间，因为每次虚假唤醒都会消耗一定的时间</strong></p>
<p><strong>2.设置了超时时间为什么就不需要主动唤醒了？主动唤醒和不主动的唤醒的区别是什么？</strong></p>
<p>因为线程在到达超时时间后就会自动唤醒。</p>
<p><strong>区别：</strong></p>
<p>如果正常设置了唤醒，那就是线程生产完数据后能立即通知另一个线程获取数据，如果没有设置唤醒，另一个线程则等待超时时间到达后再获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObjectV2</span> &#123;</span><br><span class="line">    <span class="comment">//线程2等待线程1生产完数据后，获取线程1生产的数据</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeOut)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="comment">//等待另一个线程生产数据</span></span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//经历时间</span></span><br><span class="line">            <span class="type">long</span> parseTime=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response==<span class="literal">null</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获取剩余等待开始时间</span></span><br><span class="line">                <span class="comment">//剩余等待时间 = 超时时间-实际经历的时间(实际已经等待的时间)，如果小于0说明超时，否则正常执行</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeOut-parseTime;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//说明超时</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//因为存在虚假唤醒问题，所以等待时间不能直接是timeOut,而是得实时减去虚假唤醒所耗费的时间(每一次虚假唤醒都会执行一轮循环)</span></span><br><span class="line">                    <span class="comment">//timeOut-parseTime会存在一个问题：如果超时了，时间会小于0，等待小于0的时间会出现异常，得判断剩余等待时间是否小于0</span></span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算实时经历时间(即等待了多久)</span></span><br><span class="line">                parseTime = System.currentTimeMillis()-begin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程1生产数据设置到公共的数据容器中并唤醒正在等待容器中数据的线程，让其正常获取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="built_in">this</span>.response = object;</span><br><span class="line">            <span class="comment">//如果是设置了等待的超时时间，线程生产完数据唤醒另一个线程获取数据就不是必须的了，因为线程在到达超时时间后就会自动唤醒</span></span><br><span class="line">            <span class="comment">//无论生产数据的线程有无主动唤醒另一个线程，另一个线程都可以达到唤醒的效果</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//有无主动唤醒的区别：如果正常设置了唤醒，那就是线程生产完数据后能立即通知另一个线程获取数据，如果没有设置唤醒，另一个线程则等待超时时间到达后再获取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            lock.notifyAll();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试，没有超时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject2</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟线程生产数据和获取数据的过程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">&quot;生产数据开始...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟生产数据需要10ms</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;生产数据完成...&quot;</span>);</span><br><span class="line">            guardedObject.complete(data);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取数据开始...&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> (String) guardedObject.get(<span class="number">20</span>);</span><br><span class="line">            log.info(<span class="string">&quot;获取数据完成...数据是&quot;</span>+data);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11:27:07.483 [t1] INFO com.czq.GuardedObject2 - 生产数据开始...</span><br><span class="line">11:27:07.483 [t2] INFO com.czq.GuardedObject2 - 获取数据开始...</span><br><span class="line">11:27:07.485 [t2] DEBUG com.czq.GuardedObject2 - waitTime: 20</span><br><span class="line">11:27:07.501 [t1] INFO com.czq.GuardedObject2 - 生产数据完成...</span><br><span class="line">11:27:07.517 [t2] INFO com.czq.GuardedObject2 - 获取数据完成...数据是data</span><br></pre></td></tr></table></figure>

<p>测试超时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待时间不足 生产数据时间10毫秒，等待时间5毫秒</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> (String) guardedObject.get(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">29.730</span> [t1] INFO com.czq.GuardedObject2 - 生产数据开始...</span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">29.730</span> [t2] INFO com.czq.GuardedObject2 - 获取数据开始...</span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">29.732</span> [t2] DEBUG com.czq.GuardedObject2 - waitTime: <span class="number">5</span></span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">29.743</span> [t2] DEBUG com.czq.GuardedObject2 - waitTime: -<span class="number">6</span></span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">29.743</span> [t1] INFO com.czq.GuardedObject2 - 生产数据完成...</span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">29.743</span> [t2] INFO com.czq.GuardedObject2 - 获取数据完成...数据是<span class="literal">null</span></span><br></pre></td></tr></table></figure>



<h5 id="join方法的原理"><a href="#join方法的原理" class="headerlink" title="join方法的原理"></a>join方法的原理</h5><p>是调用者轮询检查线程 alive 状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.join();</span><br></pre></td></tr></table></figure>

<p>等价于下面的代码，<strong>即join()方法的底层原理就是wait(long timeOut)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂时假设调用t1.join()方法的线程是主线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">    <span class="comment">//那wait(0)代表无休止的等待下去，究竟是谁对主线程(调用等待t1线程的线程)进行了唤醒呢？</span></span><br><span class="line">    <span class="comment">//答案：t1线程在结束运行时JVM会自动调用一次notifyAll方法唤醒所有线程</span></span><br><span class="line">    <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">        t1.wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<p>join 体现的是【保护性暂停】模式，请参考源码解析</p>
</blockquote>
<p><strong>通过源码解析原理：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参</span></span><br><span class="line"><span class="comment">//等待时长的实现类似于之前的保护性暂停</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//负责不设置超时时间的等待逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">           <span class="comment">//那wait(0)代表无休止的等待下去，究竟是谁对主线程(调用等待t1线程的线程)进行了唤醒呢？</span></span><br><span class="line">    		<span class="comment">//实际上t1线程在结束运行时JVM会自动调用一次notifyAll方法唤醒所有线程</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//else负责设置了超时时间的等待逻辑，具体的底层实现原理如下，实际上就是wait(long timeOut)方法的原理，上面有详细解析</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="comment">//delay：剩余等待时间</span></span><br><span class="line">            <span class="comment">//剩余等待时间 = 超时时间-实际经历的时间(实际已经等待的时间)，如果小于0说明超时，否则正常执行</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            <span class="comment">//计算实时的经历时间(等待时间)</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="wait和join的区别"><a href="#wait和join的区别" class="headerlink" title="wait和join的区别"></a>wait和join的区别</h5><p><strong>前提：</strong>wait方法和join方法都没有设置超时唤醒</p>
<p>1.因为join的底层就是wait，二者的原理基本一致，但有一处细微的区别，<strong>就是join方法会等待线程执行完才会自动唤醒，而wait方法只要拿到另一个线程的通信数据后就会自动唤醒，不需要等待线程执行完毕才唤醒</strong></p>
<p>2.调用join()时不需要我们自己手动获取锁资源，手动调用wait&#x2F;notify等方法，只要调用join()方法便有一条龙服务的功能，因为join()底层早已经帮我们封装好了(底层的实现是wait&#x2F;notify..)，而wait则需要我们手动获取了锁资源才能调用，<strong>所以调用起来join会比wait方便很多</strong></p>
<h5 id="引入第三方中间类降低线程之间的耦合"><a href="#引入第三方中间类降低线程之间的耦合" class="headerlink" title="引入第三方中间类降低线程之间的耦合"></a>引入第三方中间类降低线程之间的耦合</h5><p><strong>通俗解读场景：</strong></p>
<p>如果是存在多个一一对应的生产者和消费者，生产者和消费者都是动态变化的，耦合度非常强，可以通过引入一个第三方的中间类<strong>实现生产者和消费者的解耦并管理线程之间存储的通信数据</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/多个一一对应的生产者和消费者.png" alt="多个一一对应的生产者和消费者"></p>
<p>新增 id 用来标识 Guarded Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间利用公共的数据存储空间进行通信交互，生产者线程可以将生产的消息存储到此空间中，消费者线程可以从此空间获取消息并消费</span></span><br><span class="line"><span class="comment"> * 切记：</span></span><br><span class="line"><span class="comment"> * 1.公共的数据存储空间类只能存储和获取生产数据但不能自己生产数据，因为生产数据是生产者干的活</span></span><br><span class="line"><span class="comment"> * 2.公共的数据存储空间只能存储和获取生产数据但不能自己消费数据，因为消费数据是消费者干的活</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedObject3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁，控制线程安全问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">//公共的数据存储容器中存储线程间交互的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产数据的唯一标识id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程负责生产数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个线程负责等待数据生产完成并获取</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeOut)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> parseTime=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (data == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeOut-parseTime;</span><br><span class="line">                log.info(<span class="string">&quot;waitTime....&#123;&#125;&quot;</span>,waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                parseTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间解耦类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MailBox</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer,GuardedObject3&gt; guardedObjects = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为数据容器中会存储多个数据，所以每个数据得有一个唯一的标识id，并且为了避免消息标识id冲突(如果由消费者和生产者自己设计消息id则有可能会产生冲突)</span></span><br><span class="line">    <span class="comment">//所以数据的唯一标识id交给数据容器自己来设计(采用自增策略)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> id=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有可能多个线程同时会生产id，会有线程安全问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generatedId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建存储消息的数据空间用来存储生产者生产的消息(公共的数据存储空间只能存储数据和获取数据，但不能生产数据，因为生产数据是生产者干的活)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject3 <span class="title function_">createGuardedObject3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">GuardedObject3</span> <span class="variable">guardedObject3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject3</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> generatedId();</span><br><span class="line">        guardedObject3.setId(id);</span><br><span class="line">        guardedObjects.put(id,guardedObject3);</span><br><span class="line">        <span class="keyword">return</span> guardedObject3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数据容器中获取对应线程间交互的数据空间(公共的数据存储空间只能存储数据和获取数据，但不能消费数据，因为消费数据是消费者干的活)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject3 <span class="title function_">getGuardedObject3</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> guardedObjects.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用作线程间传输结果的公共的数据存储空间是由谁来创建？可以是生产者来创建，也可以是消费者来创建，这里的案例是消费者来创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> guardedObjects.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务相关类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Postman</span><span class="params">(<span class="type">int</span> id, String mail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建多个消费者线程消费消息</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Peoples</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程休眠1s等待消费者线程创建好的公共的数据存储空间先，否则生产者即使生产了消息也没有数据存储空间来存储消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer id : MailBox.getIds()) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Postmans</span>(id,<span class="string">&quot;内容&quot;</span>+id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>某次运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">49.086</span> [Thread-<span class="number">1</span>] DEBUG com.czq.Peoples - 开始收信 id:<span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">49.086</span> [Thread-<span class="number">0</span>] DEBUG com.czq.Peoples - 开始收信 id:<span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">49.086</span> [Thread-<span class="number">2</span>] DEBUG com.czq.Peoples - 开始收信 id:<span class="number">3</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">49.090</span> [Thread-<span class="number">1</span>] INFO com.czq.GuardedObject3 - waitTime...<span class="number">.2000</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">49.090</span> [Thread-<span class="number">2</span>] INFO com.czq.GuardedObject3 - waitTime...<span class="number">.2000</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">49.090</span> [Thread-<span class="number">0</span>] INFO com.czq.GuardedObject3 - waitTime...<span class="number">.2000</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">50.092</span> [Thread-<span class="number">3</span>] DEBUG com.czq.Postmans - 送信 id:<span class="number">3</span>, 内容:内容<span class="number">3</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">50.092</span> [Thread-<span class="number">4</span>] DEBUG com.czq.Postmans - 送信 id:<span class="number">2</span>, 内容:内容<span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">50.092</span> [Thread-<span class="number">5</span>] DEBUG com.czq.Postmans - 送信 id:<span class="number">1</span>, 内容:内容<span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">50.092</span> [Thread-<span class="number">0</span>] DEBUG com.czq.Peoples - 收到信 id:<span class="number">1</span>, 内容:内容<span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">50.092</span> [Thread-<span class="number">1</span>] DEBUG com.czq.Peoples - 收到信 id:<span class="number">2</span>, 内容:内容<span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">50.092</span> [Thread-<span class="number">2</span>] DEBUG com.czq.Peoples - 收到信 id:<span class="number">3</span>, 内容:内容<span class="number">3</span></span><br></pre></td></tr></table></figure>



<p><strong>现在最大的困惑是引入第三方解耦线程之间的耦合的作用怎么理解？感觉没有前后对比感受不到他的好处</strong></p>
<p><strong>暂时的理解：</strong></p>
<p>最大的作用是**将生产者线程和消费者线程的强耦合转化成了二者与第三方类的弱耦合(解除了生产者和消费者之间的强耦合)**，因为生产者和消费者是动态变化的，如果二者耦合，耦合度会非常强，而第三方类是静态的，基本不会发生变化，那就是弱耦合</p>
<h3 id="生产者消费者模式通信"><a href="#生产者消费者模式通信" class="headerlink" title="生产者消费者模式通信"></a>生产者消费者模式通信</h3><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>要点 </p>
<ul>
<li>与前面的保护性暂停模式中的 GuardObject 不同，<strong>不需要产生结果和消费结果的线程一一对应</strong> </li>
<li>消费队列可以用来平衡生产和消费的线程资源**(引入第三方中间类解耦的作用)**</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 <strong>(引入第三方中间类解耦的作用)</strong></li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 </li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><strong>保护性暂停模式和生产者消费者模式通信最大的区别是前者定义的线程只能一对一通信，后置可以实现一对多的通信</strong></p>
<p><strong>其次就是生产者消费者模式通信是异步的</strong>，<strong>因为生产者生产的消息需要在队列中排队等待</strong>(一个生产者可以对应多个消费者，而队列中存储的可能是多个生产者生产的消息)，消费不一定能立刻消费消息</p>
<p><img src="D:/VscodeProjects/source/_posts/生产者消费者模式通信模式图.png" alt="生产者消费者模式通信模式图"></p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="comment">//消息id，可以跟id从公共的数据容器中获取线程间传输的结果消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">//消息内容</span></span><br><span class="line">    <span class="keyword">private</span> Object content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.czq.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方中间类：公共的数据存储容器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">//并且此时线程与线程之间的一对多的关联</span></span><br><span class="line">    <span class="comment">//使用双向链表存储消息，两个出口的链表让生产者可以从一个出口生产消息，消费者可以从另一个出口消费消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Message&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储生产者的生产消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="comment">//1.判断存储数据的容器是否已经满了，如果已经满了，生产者阻塞等待容器释放空间</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;数据容器已满...&quot;</span>);</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.容器不是满的状态则可以存储消息</span></span><br><span class="line">            queue.push(message);</span><br><span class="line">            <span class="comment">//3.容器不是满的状态就可以唤醒消费者线程消费消息</span></span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="comment">//1.判断数据容器中是否有消息可以释放(容器是否为空)，如果为空，则阻塞等待，直到容器中有消息可以消费</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;数据容器为空...&quot;</span>);</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.容器中有数据则直接消费即可</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//3.消费了容器中的数据后，容器已经脱离了满的状态了，唤醒生产者生产消息线程</span></span><br><span class="line">            queue.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">messageQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 4 个生产者线程, 生产消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;内容&quot;</span>+id;</span><br><span class="line">                log.debug(<span class="string">&quot;try put message(&#123;&#125;)&quot;</span>, id);</span><br><span class="line">                messageQueue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, response));</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 个消费者线程, 处理结果</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.take();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> message.getContent();</span><br><span class="line">                log.debug(<span class="string">&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;</span>, message.getId(), response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某次运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">18:10:02.035 [生产者1] DEBUG com.czq.two.Test - try put message(1)</span><br><span class="line">18:10:02.035 [生产者0] DEBUG com.czq.two.Test - try put message(0)</span><br><span class="line">18:10:02.035 [生产者3] DEBUG com.czq.two.Test - try put message(3)</span><br><span class="line">18:10:02.035 [生产者2] DEBUG com.czq.two.Test - try put message(2)</span><br><span class="line">18:10:02.039 [生产者3] DEBUG com.czq.two.MessageQueue - 数据容器已满...</span><br><span class="line">18:10:02.039 [生产者0] DEBUG com.czq.two.MessageQueue - 数据容器已满...</span><br><span class="line">18:10:02.142 [生产者3] DEBUG com.czq.two.MessageQueue - 数据容器已满...</span><br><span class="line">18:10:02.142 [消费者] DEBUG com.czq.two.Test - take message(2): [内容2] lines</span><br><span class="line">18:10:02.142 [消费者] DEBUG com.czq.two.Test - take message(0): [内容0] lines</span><br><span class="line">18:10:02.142 [消费者] DEBUG com.czq.two.Test - take message(3): [内容3] lines</span><br><span class="line">18:10:02.142 [消费者] DEBUG com.czq.two.Test - take message(1): [内容1] lines</span><br><span class="line">18:10:02.142 [消费者] DEBUG com.czq.two.MessageQueue - 数据容器为空...</span><br></pre></td></tr></table></figure>



<h3 id="线程间的通信总结"><a href="#线程间的通信总结" class="headerlink" title="线程间的通信总结"></a>线程间的通信总结</h3><p><strong>1.线程间的通信是什么？</strong></p>
<p>这里的线程间的通信概念<strong>特指一个线程在等待另一个线程的执行结果</strong>，然后通过公共的存储空间实现结果的传输</p>
<p><strong>2.为什么需要线程间的通信？</strong></p>
<p><strong>因为必然存在一个线程等待另一个线程的执行结果这样的业务场景</strong>，比如用户线程必须等待商家线程把交易金额算出来后才能付钱..</p>
<p>3.如何实现线程间的通信？</p>
<p><strong>实现线程间通信的核心：</strong></p>
<p><strong>1.线程之间通过wait()和notify&#x2F;notifyAll实现线程间的通信(通过wait方法实现线程之间的互相等待，通过notify&#x2F;notifyAll放实现线程之间的互相唤醒)</strong></p>
<p>2.线程之间使用一个<strong>公共的数据存储空间(GuardedObject和LinkedList等)存储线程之间的通信数据</strong></p>
<p><strong>疑问</strong></p>
<p><strong>为什么wait,notify&#x2F;notifyAll是通信的核心之一？</strong></p>
<p>因为wait,notify&#x2F;notifyAll能够实现一个线程等待另一个线程的执行结果，待另一个线程产生执行结果后可以通过唤醒的方式通知原线程及时获取另一个线程的执行结果</p>
<h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>它们是 LockSupport 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>

<p>先 park 再 unpark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">22:06:39.463 [t1] DEBUG com.czq.two.Test2 - start...</span><br><span class="line">22:06:39.468 [t1] DEBUG com.czq.two.Test2 - park...</span><br><span class="line">22:06:39.468 [main] DEBUG com.czq.two.Test2 - unpark...</span><br><span class="line">22:06:39.468 [t1] DEBUG com.czq.two.Test2 - resume...</span><br></pre></td></tr></table></figure>

<p>先 unpark 再 park</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">22:07:08.845 [main] DEBUG com.czq.two.Test2 - unpark...</span><br><span class="line">22:07:08.845 [t1] DEBUG com.czq.two.Test2 - start...</span><br><span class="line">22:07:08.855 [t1] DEBUG com.czq.two.Test2 - park...</span><br><span class="line">22:07:08.855 [t1] DEBUG com.czq.two.Test2 - resume...</span><br></pre></td></tr></table></figure>



<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>与 Object 的 wait &amp; notify 相比 </p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll  是唤醒所有等待线程，就不那么【精确】 </li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<h4 id="park和unpark的原理"><a href="#park和unpark的原理" class="headerlink" title="park和unpark的原理"></a>park和unpark的原理</h4><p>每个线程都有自己的一个 Parker 对象(由C++编写，java中不可见)，由三部分组成 <code>_counter </code>， <code>_cond </code>和 <code>_mutex</code> 打个比喻 </p>
<p><strong>park方法原理</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/park方法原理.png" alt="park方法原理"></p>
<p><strong>counter值为0的情况：</strong></p>
<p>1.如果counter变量的值为0</p>
<p>2.则获取互斥锁让当前线程切换到阻塞状态并让当前线程进入到cond阻塞队列中等待</p>
<p>3.并再次设置counter值为0</p>
<p><strong>counter值为1的情况：</strong></p>
<p>1.如果counter变量的值为1</p>
<p>2.让线程继续正常执行下去并设置counter值为0</p>
<p><strong>unpark方法原理</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/unpark方法原理.png" alt="unpark方法原理"></p>
<p>1.将counter变量的值从0置为1</p>
<p>2.唤醒cond阻塞队列中的线程让其继续执行</p>
<p>3.如果counter值本来就是1，那将会重复设置counter变量的值为1并且不需要唤醒阻塞队列中的线程</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>1.Park &amp;Unpark是什么？</p>
<p>是实现线程阻塞状态和运行状态互相转换的一种方式</p>
<p>2.为什么需要Park &amp; Unpark？他的使用场景是什么？</p>
<p>Park &amp; Unpark可以解决在线程成功获取到锁的资源后但缺乏其他资源而导致的线程不能得到有效运行和不能及时释放锁的问题(和wait&#x2F;notify的使用场景类似)</p>
<p>3.怎么使用Park &amp; Unpark？使用原理是什么？</p>
<p><strong>park和unpark的原理与操作的PV操作原理非常像，park操作做信号量的减法(从1-&gt;0)，如果已经是0则让线程阻塞。unpark操作做信号量的加法(从0-&gt;1)，如果已经是1则不需要唤醒阻塞队列中的线程</strong></p>
<p>4.park &amp;unpark对比synchronized重量级锁和ReentrantLock重量级锁的等待唤醒机制有什么优势吗？</p>
<p><strong>A.park &amp; unpark支持唤醒指定的某个线程，这是synchronized重量级锁和ReentrantLock重量级锁实现不了的</strong></p>
<p><strong>B.park &amp; unpark使用起来非常简单和灵活(因为他的原理是基于操作系统的PV操作)，不像synchronized重量级锁实现起来非常的复杂</strong>，需要保证wait和notify成对出现，还要使用循环避免虚假唤醒和只有一次判断资源的情况，还需要保证加了锁必须要手动释放锁</p>
<p><strong>即使是ReentrantLock重量级锁实现起来也和synchronized重量级锁类似，同样复杂</strong>，只是ReentrantLock重量级锁对synchronized锁做了些许优化罢了</p>
<h2 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h2><p><img src="D:/VscodeProjects/source/_posts/Java-Api层面，线程的六种状态.png" alt="Java-Api层面，线程的六种状态"></p>
<p><strong>BLOCKED,WAITING,TIME_WAITING是三种不同的阻塞状态，虽然都是阻塞状态，但他们的类型不一样</strong></p>
<p>假设有线程 <code>Thread t</code> </p>
<h4 id="情况-1-NEW-RUNNABLE"><a href="#情况-1-NEW-RUNNABLE" class="headerlink" title="情况 1 NEW --&gt; RUNNABLE"></a>情况 1 <code>NEW --&gt; RUNNABLE</code></h4><ul>
<li>当调用 <code>t.start()</code> 方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<p><strong>NEW状态代表只是在Java层面新建一个线程对象，但该线程对象还没有与操作系统的线程关联起来，还不是真正意义上的线程</strong></p>
<p>NEW-&gt;RUNNABLE代表Java层面的线程对象成功与操作系统的线程关联起来了并且启动线程的运行</p>
<h4 id="情况-2-RUNNABLE-WAITING-TIMED-WAITING"><a href="#情况-2-RUNNABLE-WAITING-TIMED-WAITING" class="headerlink" title="情况 2 RUNNABLE &lt;--&gt; WAITING/TIMED_WAITING"></a>情况 2 <code>RUNNABLE &lt;--&gt; WAITING/TIMED_WAITING</code></h4><p><strong>t 线程</strong>用 <code>synchronized(obj)</code> 获取了对象锁后 </p>
<ul>
<li><p>调用 <code>obj.wait()</code> 方法时，<strong>t 线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> </p>
</li>
<li><p>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时 </p>
<p>阶段一：线程被notify之后不会直接参与竞争锁，因为唤醒他们的线程正在使用锁，根本就没有竞争锁的机会，所以线程被notify之后是直接从waitset等待队列进入entrylist阻塞队列，对应的状态就是从WAITING变为BLOCKED</p>
<p>阶段二：等待占有锁的线程释放锁后，阻塞队列entrylist中的线程就会竞争锁，如果竞争成功，线程的状态就会从WATING切换到RUNNABLE，如果失败则继续阻塞等待下一次的锁的竞争</p>
</li>
<li><p>如果<code>obj.wait(long timeOut)</code>带超时时间，超时之后同样是从waitset等待队列进入entrylist阻塞队列中，原理和没有超时基本是一致的，只是多个超时时间控制</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWaitNotify</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;其它代码....&quot;</span>); <span class="comment">// 断点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;其它代码....&quot;</span>); <span class="comment">// 断点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            obj.notifyAll(); <span class="comment">// 唤醒obj上所有等待线程 断点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="情况-3-RUNNABLE-WAITING-TIMED-WAITING"><a href="#情况-3-RUNNABLE-WAITING-TIMED-WAITING" class="headerlink" title="情况 3 RUNNABLE &lt;--&gt; WAITING/TIMED_WAITING"></a>情况 3 <code>RUNNABLE &lt;--&gt; WAITING/TIMED_WAITING</code></h4><ul>
<li><strong>当前线程</strong>调用 <code>t.join()</code> 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> 注意是<strong>当前线程</strong>在<strong>t 线程对象</strong>的监视器上等待 </li>
<li><strong>如果t 线程</strong>运行结束，或者调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li>
<li><code>join</code>方法底层就是wait，<strong>无论是有无超时时间，他们的状态转换原理和wait基本是一致的</strong></li>
</ul>
<p><strong>细节：区分好t.wait()方法和t.join()方法阻塞的线程对象是谁，虽然二者都是阻塞当前正在运行的线程，但其实二者正在运行的线程对象是不一样的</strong></p>
<p>比如t.wait()方法代表t线程就是当前正在运行的线程，而t.join()方法中t线程并不是当前正在运行的线程</p>
<h4 id="情况-4-RUNNABLE-TIMED-WAITING"><a href="#情况-4-RUNNABLE-TIMED-WAITING" class="headerlink" title="情况 4 RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况 4 <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h4><ul>
<li><strong>当前线程</strong>调用 <code>Thread.sleep(long n)</code> ，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code> </li>
<li><strong>当前线程</strong>等待时间超过了 n 毫秒，<strong>当前线程</strong>从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ul>
<p><strong>在线程状态转换原理上和wait方法的区别：</strong></p>
<p><code>wait(long n)</code>会先进入到waitset等待队列中，直到锁释放才会进入到entrylist阻塞队列中竞争锁，而sleep方法是直接进入到entrylist阻塞队列中，不需要进入到waitset等待队列中</p>
<h4 id="情况-5-RUNNABLE-TIMED-WAITING"><a href="#情况-5-RUNNABLE-TIMED-WAITING" class="headerlink" title="情况 5 RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况 5 <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h4><ul>
<li><strong>当前线程</strong>调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING </code></li>
<li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING--&gt; RUNNABLE</code></li>
</ul>
<h4 id="情况-6-RUNNABLE-BLOCKED"><a href="#情况-6-RUNNABLE-BLOCKED" class="headerlink" title="情况 6 RUNNABLE &lt;--&gt; BLOCKED"></a>情况 6 <code>RUNNABLE &lt;--&gt; BLOCKED</code></h4><ul>
<li><strong>t 线程</strong>用 <code>synchronized(obj)</code> 获取了对象锁时如果竞争失败，从 <code>RUNNABLE --&gt; BLOCKED</code> </li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 <strong>t 线程</strong>竞争 成功，从 <code>BLOCKED --&gt; RUNNABLE</code> ，其它失败的线程仍然 <code>BLOCKED</code></li>
</ul>
<h4 id="情况-7-RUNNABLE-TERMINATED"><a href="#情况-7-RUNNABLE-TERMINATED" class="headerlink" title="情况 7 RUNNABLE &lt;--&gt; TERMINATED"></a>情况 7 <code>RUNNABLE &lt;--&gt; TERMINATED</code></h4><ul>
<li>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></li>
</ul>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><strong>线程状态的转换实际上把前面所有知识都串联起来了，这里面涉及重量级锁Monitor的原理，<code>start(),wait(),join(),notify()/notifyAll(),park(),unpark()</code>等方法的原理知识</strong></p>
<p>1.调用线程的<code>start()</code>方法可以让线程从NEW-&gt;RUNNABLE</p>
<p>2.调用线程的<code>sleep(),wait(),join(),park()</code>方法让线程从RUNNABLE-&gt;WAITING&#x2F;TIME_WAITING</p>
<p>3.调用线程的<code>interrupt(),notify()/notifyAll(),unpark()</code>让线程从WAITING&#x2F;TIMED_WAITING-&gt;RUNNABLE</p>
<p>4.竞争重量级锁Mointor成功和失败则可以让线程在RUNNABE&lt;–&gt;BLOCKED两个状态之间切换</p>
<h2 id="线程的活跃性"><a href="#线程的活跃性" class="headerlink" title="线程的活跃性"></a>线程的活跃性</h2><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h4><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁 </p>
<p><strong>核心理解：线程之间彼此都想获取对方手上的资源但又不想释放自己手上的资源，就会发生死锁现象</strong></p>
<p><code>t1 线程</code> 获得 <code>A对象</code> 锁，接下来想获取 <code>B对象</code> 的锁 <code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code> 的锁 例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12:22:06.962 [t2] c.TestDeadLock - lock B </span><br><span class="line">12:22:06.962 [t1] c.TestDeadLock - lock A</span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<ul>
<li>ReentrantLock</li>
</ul>
<h4 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a><strong>定位死锁</strong></h4><p><strong>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt; jps</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8</span><br><span class="line">12320 Jps</span><br><span class="line">22816 KotlinCompileDaemon</span><br><span class="line">33200 TestDeadLock // JVM 进程</span><br><span class="line">11508 Main</span><br><span class="line">28468 Launcher</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt; jstack 33200</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8</span><br><span class="line">2018-12-29 05:51:40</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;DestroyJavaVM&quot;</span> <span class="comment">#13 prio=5 os_prio=0 tid=0x0000000003525000 nid=0x2f60 waiting on condition </span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">	java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry </span></span><br><span class="line">[0x000000001f54f000]</span><br><span class="line">	java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at thread.TestDeadLock.lambda$main<span class="variable">$1</span>(TestDeadLock.java:28)</span><br><span class="line">        - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">        at thread.TestDeadLock$$Lambda<span class="variable">$2</span>/883049899.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> <span class="comment">#11 prio=5 os_prio=0 tid=0x000000001eb68800 nid=0x1b28 waiting for monitor entry </span></span><br><span class="line">[0x000000001f44f000]</span><br><span class="line">	java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at thread.TestDeadLock.lambda$main<span class="variable">$0</span>(TestDeadLock.java:15)</span><br><span class="line">        - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">         - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line"> 		at thread.TestDeadLock$$Lambda<span class="variable">$1</span>/495053715.run(Unknown Source)</span><br><span class="line"> 		at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"> </span><br><span class="line">// 略去部分输出</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line"> 	waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),</span><br><span class="line"> 	<span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">	 waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),</span><br><span class="line"> 	<span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">         at thread.TestDeadLock.lambda$main<span class="variable">$1</span>(TestDeadLock.java:28)</span><br><span class="line">         - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">         - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">         at thread.TestDeadLock$$Lambda<span class="variable">$2</span>/883049899.run(Unknown Source)</span><br><span class="line">         at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">         at thread.TestDeadLock.lambda$main<span class="variable">$0</span>(TestDeadLock.java:15)</span><br><span class="line">         - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">         - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">         at thread.TestDeadLock$$Lambda<span class="variable">$1</span>/495053715.run(Unknown Source)</span><br><span class="line">         at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<ul>
<li>避免死锁要注意加锁顺序 </li>
<li>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</li>
</ul>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a><strong>活锁</strong></h4><p><strong>核心理解：线程彼此都在改变对方线程结束的运行条件(让其不能结束运行)，那就会出现活锁现象</strong></p>
<p>通俗点来说：两个线程都在扰乱对方的正常运行，比如一个人在给泳池加水，另一个人却一直在泳池放水，那这不就导致泳池永远都加不满水，也放不尽水，两人隔着无休止的捣乱</p>
<p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<ul>
<li>错开线程的运行时间，使得一方不能改变另一方的结束条件。</li>
<li>将睡眠时间调整为随机数。</li>
</ul>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a><strong>饥饿</strong></h4><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题 </p>
<p>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题</p>
<p><img src="D:/VscodeProjects/source/_posts/死锁现象.png" alt="死锁现象"></p>
<p>顺序加锁的解决方案</p>
<p><img src="D:/VscodeProjects/source/_posts/顺序加锁方案解决死锁.png" alt="顺序加锁方案解决死锁"></p>
<p>说明：</p>
<ul>
<li>顺序加锁可以解决死锁问题，但也会导致一些线程一直得不到锁，产生饥饿现象。</li>
<li>解决方式：ReentrantLock</li>
</ul>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>1.线程的活跃性是什么？</p>
<p>线程的活跃性是指线程一直处于运行状态而不能有效停止，导致线程活跃性的原因有死锁，活锁</p>
<p>2.为什么需要线程的活跃性？</p>
<p>深入理解死锁，活锁，可以预防出现此类问题而导致线程处于一直运行状态而不能得到有效的停止</p>
<p>3.如何使用线程的活跃性？</p>
<p>我们是预防死锁，活锁的出现，当然，如果你想要重现这些场景，你可以根据死锁，活锁的原理进行复现</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于 synchronized 它具备如下特点 </p>
<ul>
<li><strong>可中断</strong> </li>
<li><strong>可以设置超时时间</strong> </li>
<li>可以设置为公平锁 </li>
<li><strong>支持多个条件变量</strong></li>
</ul>
<p>与 synchronized 一样，都支持可重入 </p>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// 释放锁</span></span><br><span class="line"> reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:59:11.862 [main] c.TestReentrant - execute method1 </span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method2 </span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure>



<h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>可打断指的是处于阻塞状态等待锁的线程可以被打断等待。注意<code>lock.lockInterruptibly()</code>和<code>lock.trylock()</code>方法是可打断的,<code>lock.lock()</code>不是。可打断的意义在于避免得不到锁的线程无限制地等待下去，防止死锁的一种方式</p>
<p><strong>核心理解：可以打断因竞争锁失败而导致的线程阻塞状态，避免获取不到锁的线程无休止的阻塞等待下去。这恰恰是优化了synchronized因为获取锁失败而无休止的阻塞等待的缺陷</strong></p>
<p><strong>缺陷：</strong></p>
<p>因为打断这种方式是由其他正在运行状态的线程对阻塞状态的线程进行打断，对于阻塞状态的线程而言是被动打断，仍然不能主动结束自己的打断状态，仍有一定的缺陷</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException </span><br><span class="line"> 		at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr</span><br><span class="line">onizer.java:898) </span><br><span class="line"> 		at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron</span><br><span class="line">izer.java:1222) </span><br><span class="line"> 		at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) </span><br><span class="line"> 		at cn.itcast.n4.reentrant.TestInterrupt.lambda$main<span class="variable">$0</span>(TestInterrupt.java:17) </span><br><span class="line"> 		at java.lang.Thread.run(Thread.java:748) </span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure>

<p><strong>当然ReentrantLock也支持不可打断，调用的是lock.lock()方法api</strong></p>
<p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:06:56.261 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:06:56.265 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="line">18:06:58.267 [main] c.TestInterrupt - 释放了锁</span><br><span class="line">18:06:58.267 [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure>



<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p><strong>核心理解：可以主动结束因为线程竞争锁失败而导致的阻塞状态，这是对打断(被动结束)方式的一种优化</strong></p>
<p>有两种实现方式：</p>
<p>1.立即失败，只要线程竞争锁失败，线程不会进入阻塞状态等待锁的释放，而是会正常执行下去</p>
<p>2.超时失败：线程在设定时间内，多次重复竞争锁资源，在超出设定时间后，线程不会在等待，而是会正常执行下去</p>
<p>立刻失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动... </span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure>

<p>超时失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:19:40.537 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:19:40.544 [t1] c.TestTimeout - 启动... </span><br><span class="line">18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回</span><br></pre></td></tr></table></figure>

<p>使用 tryLock 解决哲学家就餐问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>ReentrantLock 默认是不公平的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1s 之后去争抢锁</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;强行插入&quot;</span>).start();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>强行插入，有机会在中间输出</p>
<blockquote>
<p><strong>注意</strong>：该实验不一定总能复现</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t39 running... </span><br><span class="line">t40 running... </span><br><span class="line">t41 running... </span><br><span class="line">t42 running... </span><br><span class="line">t43 running... </span><br><span class="line">强行插入 start... </span><br><span class="line">强行插入 running... </span><br><span class="line">t44 running... </span><br><span class="line">t45 running... </span><br><span class="line">t46 running... </span><br><span class="line">t47 running... </span><br><span class="line">t49 running... </span><br></pre></td></tr></table></figure>

<p>改为公平锁后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>强行插入，总是在最后输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t465 running... </span><br><span class="line">t464 running... </span><br><span class="line">t477 running... </span><br><span class="line">t442 running... </span><br><span class="line">t468 running... </span><br><span class="line">t493 running... </span><br><span class="line">t482 running... </span><br><span class="line">t485 running... </span><br><span class="line">t481 running... </span><br><span class="line">强行插入 running... </span><br></pre></td></tr></table></figure>

<p><strong>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</strong></p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 </p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 </p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室(waitSet)等消息 </li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li>
</ul>
<p><strong>核心理解：</strong></p>
<p><strong>synchronized的条件变量只有waitSet一个，导致线程调用wait()方法都是进入的同一个等待队列，唤醒线程调用notifyAll时就会导致很多虚假唤醒。而ReentrantLock支持多个条件变量，也就是在调用await()方法后支持进入多个不同的等待队列，就可以解决掉虚假唤醒的问题。</strong></p>
<p><strong>虚假唤醒问题是什么？</strong></p>
<p>因为notifyAll唤醒了全部线程(因为所有线程都在一个waitSet中)，但实质上很多线程所需要的资源并没有准备好但其却被唤醒了</p>
<p><strong>为什么支持进入多个不同的等待队列就可以解决虚假唤醒问题呢？</strong></p>
<p>如果支持多个条件变量，意味着锁可以有多个等待队列(可以理解为多个waitSet)，那我们可以按照线程锁需要的资源去划分等待队列，自然就可以解决虚假唤醒问题了</p>
<p><strong>细节：</strong></p>
<p>解决了虚假唤醒问题并不意味着同一个waitSet队中的线程被唤醒后一定可以成功获取资源，因为虽然同一个waitSet等待队列中所需要的资源是一样的，但一个资源可以有多个线程去竞争，所以被唤醒后不一定就能成功获取到资源，这也就意味着我们需要用while不断的去获取资源而不是用if获取一次资源即可</p>
<h5 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h5><ul>
<li>await 前需要获得锁 </li>
<li>await 执行后，会释放锁，进入 conditionObject 等待 </li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 </li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<p><strong>核心理解：在使用方面和wait()，notify&#x2F;notifyAll基本是一致的，只是其支持多个条件变量罢了</strong></p>
<h5 id="详细API"><a href="#详细API" class="headerlink" title="详细API"></a>详细API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类似wait()....</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类似wait(long timeOut)....</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//类似wait(long timeOut,TimeUnit unit)....</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似notify()...</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似notifyAll()...</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitCigaretteQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitbreakfastQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendBreakfast();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">        hasCigrette = <span class="literal">true</span>;</span><br><span class="line">        waitCigaretteQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">        hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">        waitbreakfastQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:52:27.680 [main] c.TestCondition - 送早餐来了</span><br><span class="line">18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐</span><br><span class="line">18:52:28.683 [main] c.TestCondition - 送烟来了</span><br><span class="line">18:52:28.683 [Thread-0] c.TestCondition - 等到了它的烟</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>1.ReentrantLock是什么？</p>
<p>ReentrantLock同样是一种重量级锁</p>
<p>2.为什么需要ReentrantLock锁？使用场景是什么？</p>
<p>ReentrantLock锁的出现就是解决重量级锁synchronized的缺点，最重要就是解决了synchronized锁不能打断因竞争锁失败而导致的线程阻塞状态，进而导致线程一直阻塞于此而不能得到有效的运行的问题。ReentrantLock锁提供了被动打断和主动打断两种优化方案</p>
<p>其次还解决了synchronized锁条件变量过于单一而导致的虚假唤醒问题，ReentrantLock锁是通过支持多个条件变量来实现的</p>
<p>3.如何使用ReentrantLock锁?</p>
<p>在使用方面，基本synchronized锁一致，注意ReentrantLock锁对synchronized锁的优化方法的api的使用即可</p>
<h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a><font color='orange'>同步模式之顺序控制</font></h2><p><strong>概念：通过线程调度控制并发线程的执行顺序</strong></p>
<h4 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h4><p>比如，必须先 2 后 1 打印</p>
<p><strong>wait notify 版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">//flag模拟线程所需要的资源</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//       ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//方式1：ReentrantLock锁实现</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            try&#123;</span></span><br><span class="line"><span class="comment">//                log.info(&quot;2&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;finally &#123;</span></span><br><span class="line"><span class="comment">//                flag=true;</span></span><br><span class="line"><span class="comment">//                waitCondition.signalAll();</span></span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式2：synchronized锁实现</span></span><br><span class="line"><span class="comment">//            synchronized (lock)&#123;</span></span><br><span class="line"><span class="comment">//                log.info(&quot;2&quot;);</span></span><br><span class="line"><span class="comment">//                flag=true;</span></span><br><span class="line"><span class="comment">//                lock.notifyAll();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式3：join方法，底层同样是wait,所以同样也是synchronized锁实现</span></span><br><span class="line"><span class="comment">//            log.info(&quot;2&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式4：park &amp;&amp; unpark实现</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">            <span class="comment">//方式1：ReentrantLock锁实现</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while (!flag)&#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    waitCondition.await();</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                log.info(&quot;1&quot;);</span></span><br><span class="line"><span class="comment">//            &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式2：synchronized锁实现</span></span><br><span class="line"><span class="comment">//            synchronized (lock)&#123;</span></span><br><span class="line"><span class="comment">//                while (!flag)&#123;</span></span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        lock.wait();</span></span><br><span class="line"><span class="comment">//                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                log.info(&quot;1&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式3：join方法，底层同样是wait,所以同样也是synchronized锁实现</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                t1.join();</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            log.info(&quot;1&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式4：park &amp;&amp; unpark实现</span></span><br><span class="line">            log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>Park Unpark 版</strong></p>
<p>可以看到，实现上很麻烦： </p>
<ul>
<li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait </li>
<li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题 </li>
<li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li>
</ul>
<p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    <span class="comment">// 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行</span></span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』， 不需要『同步对象』和『运行标记』</p>
<h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p>
<p><strong>wait notify 版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t1Flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2Flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t3Flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遇到的问题是：无法控制abc的交替打印，问题就出现在我忽略了即使我唤醒了指定的线程(使用while循环判断资源实现)去获取锁资源，</span></span><br><span class="line">        <span class="comment">//但是我忘记我自己本身因为要循环打印5次同样会再次参与锁资源的竞争，所以这样做并不能保证一定是我唤醒的线程成功获取到锁资源</span></span><br><span class="line">        <span class="comment">//所以最终的解决方案是</span></span><br><span class="line">        <span class="comment">//我不仅要唤醒指定的线程，还要把自身线程打印所需要的资源置为false，</span></span><br><span class="line">        <span class="comment">//这样即使自身线程也参与到了锁的竞争并且成功获取到了锁资源也能够及时释放锁资源而不会扰乱线程的执行顺序</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (!t3Flag)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.info(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                    t1Flag = <span class="literal">true</span>;</span><br><span class="line">                    t3Flag = <span class="literal">false</span>;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (!t2Flag)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.info(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    t3Flag = <span class="literal">true</span>;</span><br><span class="line">                    t2Flag = <span class="literal">false</span>;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1Flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (!t1Flag)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.info(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    t2Flag=<span class="literal">true</span>;</span><br><span class="line">                    t1Flag=<span class="literal">false</span>;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>ReentrantLock锁的await和signalAll版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t1Flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2Flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t3Flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">t1Condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">t2Condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">t3Condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (!t3Flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t3Condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                    t1Flag = <span class="literal">true</span>;</span><br><span class="line">                    t3Flag = <span class="literal">false</span>;</span><br><span class="line">                    t1Condition.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!t2Flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t2Condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    t3Flag = <span class="literal">true</span>;</span><br><span class="line">                    t2Flag = <span class="literal">false</span>;</span><br><span class="line">                    t3Condition.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1Flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (!t1Flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t1Condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    t2Flag = <span class="literal">true</span>;</span><br><span class="line">                    t1Flag = <span class="literal">false</span>;</span><br><span class="line">                    t2Condition.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock锁这一版仅仅是优化了上一版仅有一个条件变量，会唤醒所有线程的小缺陷，因为他有多个条件变量，所以可以解决虚假唤醒问题</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>1.同步模式之顺序控制是什么？</p>
<p>同步模式之顺序控制是指在线程并发过程中我们可以<strong>通过锁实现并发线程的串行执行并通过线程调度控制线程串行执行的执行顺序</strong>。比如原来串行执行的顺序123，现在我通过线程调度可以变成312…</p>
<p>2.为什么需要同步模式之顺序控制？</p>
<p>因为我们不仅需要用锁解决线程并发安全问题，还需要控制并发线程的执行顺序才能达到我们想要的业务场景</p>
<p>3.如何实现同步模式之顺序控制？</p>
<p>实现的方式有很多种，常用的有wait&#x2F;notify，await&#x2F;signalAll，park&#x2F;unpark。以下是我对控制并发线程的执行顺序的领悟</p>
<p>A.<strong>通过同步模式顺序控制让我更深刻领悟到仅依靠竞争锁成功与失败(synchronized和lock.lock())只能实现并发线程串行执行(串行执行就是不能让并发线程交叉执行，要一个线程执行完才能轮到另一个线程)，但其并不能控制并发线程的串行执行顺序</strong></p>
<p>B.比如串行的执行顺序可以是123，也可以是132，231，213，312，321…你如果不能控制并发线程的串行执行顺序那就很难达到想要的功能</p>
<p>C.要想实现控制串行线程的执行顺序，就需要配合锁的wait&#x2F;notify，await&#x2F;signalAll，park&#x2F;unpark功能api实现，实质上这些api功能就是用来控制和调度线程的执行顺序的，那么他们是如何控制的呢？</p>
<p>D.他们可以实现即使线程成功获取到了锁资源但仍旧可以通过是否阻塞等待决定线程是否要让出锁资源，进而控制线程的执行顺序，<strong>核心就是一句话，线程竞争锁资源的顺序我们是无法控制的，但如果线程的执行顺序不满足我们的需求我们可以控制线程让出锁资源重新参与锁资源的竞争进而达到控制线程执行顺序的目的</strong></p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>本章我们需要<strong>重点掌握</strong>的是 </p>
<ul>
<li>分析多线程访问共享资源时，哪些代码片段属于<strong>临界区</strong></li>
<li>使用 synchronized 互斥解决临界区的线程安全问题 <ul>
<li>掌握 synchronized 锁对象语法 </li>
<li>掌握 synchronzied 加载成员方法和静态方法语法 </li>
<li>掌握 wait&#x2F;notify 同步方法</li>
</ul>
</li>
<li>使用 lock 互斥解决临界区的线程安全问题 <ul>
<li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li>
</ul>
</li>
<li>学会分析变量的线程安全性、掌握常见线程安全类的使用<ul>
<li>线程安全类的方法是原子性的，但方法之间的组合要具体分析。</li>
</ul>
</li>
<li>了解线程活跃性问题：死锁、活锁、饥饿。<ul>
<li>解决死锁、饥饿的方式：ReentranLock</li>
</ul>
</li>
<li><font color='green'>应用方面</font> <ul>
<li><strong>互斥</strong>：使用 synchronized 或 Lock 达到共享资源互斥效果**(通过重量级锁保证线程的串行执行，保证线程执行的原子性，原子性就是一个线程执行完才能轮到下一个线程执行，也就是不能出现线程交叉执行的情况)**</li>
<li><strong>同步</strong>：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果**(互斥效果只能保证线程串行执行，并不能保证线程串行执行的顺，可以使用同步来控制线程的执行顺序，还可以使用同步在线程间传递结果数据)**</li>
</ul>
</li>
<li><font color='blue'>原理方面</font> <ul>
<li>monitor、synchronized 、wait&#x2F;notify 原理 </li>
<li>synchronized 进阶原理 </li>
<li>park &amp; unpark 原理</li>
</ul>
</li>
<li><font color='orange'>模式方面</font> <ul>
<li>同步模式之保护性暂停(用于一对一对应关系的线程间传递结果数据)</li>
<li>异步模式之生产者消费者(用于多对多对应关系的线程间传递结果数据)</li>
<li>同步模式之顺序控制(用于控制串行执行的线程的执行顺序)</li>
</ul>
</li>
</ul>
<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 </p>
<p><strong>JMM的意义</strong></p>
<ul>
<li>计算机硬件底层的内存结构过于复杂，JMM的意义在于避免程序员直接管理计算机底层内存，用一些关键字synchronized、volatile等可以方便的管理内存。</li>
</ul>
<p>JMM 体现在以下几个方面 </p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响**(上面的共享模型之管程已经将的很详细了)**</li>
<li>可见性 - <strong>保证指令不会受 cpu 缓存的影响</strong> </li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化**(指令重排)**的影响</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>概念：一个线程对主存中数据的修改对另一个线程是不可见的，原因在于另一个线程在读取数据时经过JMM编译器优化，直接从CPU高速缓存中读取了，所以读取不到主存中已经被修改的数据(不可见)</strong></p>
<h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么呢？分析一下：</strong> </p>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ol>
<p><img src="D:/VscodeProjects/source/_posts/可见性问题分析1.png" alt="可见性问题分析1"></p>
<ol start="2">
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率</li>
</ol>
<p><img src="D:/VscodeProjects/source/_posts/可见性问题分析2.png" alt="可见性问题分析2"></p>
<ol start="3">
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值</li>
</ol>
<p><img src="D:/VscodeProjects/source/_posts/可见性问题分析3.png" alt="可见性问题分析3"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>volatile（易变关键字）</p>
<p><strong>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存</strong></p>
<h4 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h4><p><strong>核心的一句话：可见性并不能保证原子性，也就是可见性并不能阻止线程的交叉运行(更底层的说法是并不能阻止线程指令的交叉运行)</strong></p>
<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可 见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic run // 线程 t 获取 run <span class="literal">true</span> </span><br><span class="line">getstatic run // 线程 t 获取 run <span class="literal">true</span> </span><br><span class="line">getstatic run // 线程 t 获取 run <span class="literal">true</span> </span><br><span class="line">getstatic run // 线程 t 获取 run <span class="literal">true</span> </span><br><span class="line">putstatic run // 线程 main 修改 run 为 <span class="literal">false</span>， 仅此一次</span><br><span class="line">getstatic run // 线程 t 获取 run <span class="literal">false</span> </span><br></pre></td></tr></table></figure>

<p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0 </span><br><span class="line">getstatic i // 线程2-获取静态变量i的值 线程内i=0 </span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0 </span><br><span class="line">iconst_1 // 线程1-准备常量1 </span><br><span class="line">iadd // 线程1-自增 线程内i=1 </span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br><span class="line">iconst_1 // 线程2-准备常量1 </span><br><span class="line">isub // 线程2-自减 线程内i=-1 </span><br><span class="line">putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 </span><br></pre></td></tr></table></figure>



<p><strong>关于synchronized重量级锁为什么能保证指令执行的可见性和有序性解析，其中有序性在特定场景下是不能保证的</strong></p>
<p>A.能保证可见性是因为JMM编译器规定在加锁时(包括代码块的一切变量)只能从主存中读取数据，而不能从缓存中读取数据，解锁时必须将数据刷新到主存当中，而不是刷新到缓存中</p>
<p>B.能保证有序性是因为synchronized锁保证了代码块内的代码操作肯定是单线程操作，而JMM编译器对指令重排的优化就规定指令重排是不能影响结果的，但这个规定实际上是单线程下能保障不影响结果，多线程下不能保障的，而synchronized锁包裹的操作必然是单线程操作，所以可以保障有序性</p>
<p>C.但如果synchronized锁的同步代码块并没有完全包括操作变量数据，那代表着在没有包裹的变量数据区域内，是存在多线程操作，自然不能保障指令执行的有序性</p>
<blockquote>
<p><strong>注意</strong> </p>
<p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低 。</p>
<p>JMM关于synchronized的两条规定：</p>
<p>　　1）线程解锁前，必须把共享变量的最新值刷新到主内存中</p>
<p>　　2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p>
<p>　　　（注意：加锁与解锁需要是同一把锁）</p>
<p>通过以上两点，可以看到synchronized能够实现可见性。同时，由于synchronized具有同步锁，所以它也具有原子性</p>
<p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？(println方法中有synchronized代码块保证了可见性)</p>
<p><strong>synchronized关键字不能阻止指令重排，但在一定程度上能保证有序性（如果共享变量没有逃逸出同步代码块的话）。因为在单线程的情况下指令重排不影响结果，相当于保障了有序性</strong></p>
</blockquote>
<h4 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a><font color='orange'>模式之两阶段终止</font></h4><p>Two Phase Termination </p>
<p>在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p>
<h5 id="1-错误思路"><a href="#1-错误思路" class="headerlink" title="1.错误思路"></a>1.错误思路</h5><ul>
<li>使用线程对象的 stop() 方法停止线程 <ul>
<li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁</li>
</ul>
</li>
<li>使用 System.exit(int) 方法停止线程 <ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
</ul>
<h5 id="2-两阶段终止模式"><a href="#2-两阶段终止模式" class="headerlink" title="2.两阶段终止模式"></a>2.两阶段终止模式</h5><p><strong>利用 isInterrupted</strong></p>
<p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//打断sleep线程会清除打断标记，所以要添加标记</span></span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TPTInterrupt</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPTInterrupt</span>();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">t.stop();</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:45.413 c.TestTwoPhaseTermination [main] - stop </span><br><span class="line">11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure>

<h5 id="利用volatile修饰的停止标记"><a href="#利用volatile修饰的停止标记" class="headerlink" title="利用volatile修饰的停止标记"></a>利用volatile修饰的停止标记</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span></span><br><span class="line">    <span class="comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (stop)&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;打断标记来咯!结束运行线程&quot;</span>);</span><br><span class="line">                    <span class="comment">//监听到打断标记为true，结束线程的运行</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18:54:09.543 [Thread-0] INFO com.czq.three.Test - 打断标记来咯!结束运行线程</span><br></pre></td></tr></table></figure>

<p>两阶段终止模式是用来优化的停止一个线程的运行的，现在来对比两种实现方式，interrupt()打断方式和volatile关键字可见性性方式</p>
<p><strong>对比之前需要明确的一点是优雅的停止线程运行的核心都是设置一个停止运行的标志位，并且volatile关键字的作用只是用来保障停止运行的标志位数据对所有线程可见，他本身并不是停止运行的标志位</strong></p>
<p><strong>对比</strong></p>
<p>interrupt()打断方式较为麻烦，因为他存在重置打断标志位的问题，需要重复设置打断标记位，而volatile的方式通过保证停止标记位可见性的方式可以读取最新的停止标志位的数据从而停止线程的运行，较为方便，只需要给变量加一个volatile关键字即可</p>
<h4 id="模式之-Balking"><a href="#模式之-Balking" class="headerlink" title="模式之 Balking"></a><font color='orange'>模式之 Balking</font></h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回</p>
<p>通俗点来理解Balk模式的作用：就是用来解决多线程下的判断问题，如果为true则直接返回，false则继续执行</p>
<p>典型的应用案例是单例模式，判断单例对象是否已经创建好了，如果已经创建好则不需要继续执行下去，直接返回即可，否则需要继续执行下去，创建单例对象</p>
<p><strong>volatile关键字的作用</strong></p>
<p>保证了在多线程交叉运行的情况下能读取最新的数据，线程可以根据读取的数据可以判断是否要继续执行下去，但仍需要配合synchronized重量级锁解决原子性问题才能实现balking犹豫模式</p>
<h5 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h5><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">bulk</span> <span class="operator">=</span>  <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        starting();</span><br><span class="line">        starting();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test2.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bulk)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bulk = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           log.info(<span class="string">&quot;监控线程执行拉!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当前端页面多次点击按钮调用 start 时 </p>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">05</span>:<span class="number">03.141</span> [Thread-<span class="number">0</span>] INFO com.czq.three.Test2 - 监控线程执行拉!</span><br></pre></td></tr></table></figure>

<p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p>
<p><strong>其实两个模式都是用于线程通信的，保护性暂停模式是用于在线程间传输结果数据，而balkin模式是用来在线程间传递是否要重复执行的信号，如果一个线程已经执行过了通过标记变量即可给另一个线程传递执行信号，只是通信解决的问题不一样</strong></p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>**JVM 会在不影响正确性的前提下，可以调整语句的执行顺序(指令重排)**，思考下面一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> j;</span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作</span></span><br><span class="line">i = ...; </span><br><span class="line">j = ...; </span><br></pre></td></tr></table></figure>

<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ...; </span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>

<p>也可以是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = ...;</span><br><span class="line">i = ...; </span><br></pre></td></tr></table></figure>

<p>这种特性称之为『指令重排』，<strong>多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？</strong>从 CPU 执行指令的原理来理解一下吧</p>
<h4 id="指令级并行执行的原理"><a href="#指令级并行执行的原理" class="headerlink" title="指令级并行执行的原理"></a><font color='blue'>指令级并行执行的原理</font></h4><h5 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h5><p><strong>Clock Cycle Time</strong> </p>
<p>主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能 够识别的最小时间单位，比如说 4G 主频的 CPU 的 Clock Cycle Time 就是 0.25 ns，作为对比，我们墙上挂钟的 Cycle Time 是 1s </p>
<p>例如，运行一条加法指令一般需要一个时钟周期时间 </p>
<p><strong>CPI</strong> </p>
<p>有的指令需要更多的时钟周期时间，所以引出了 CPI （Cycles Per Instruction）指令平均时钟周期数 </p>
<p><strong>IPC</strong> </p>
<p>IPC（Instruction Per Clock Cycle） 即 CPI 的倒数，表示每个时钟周期能够运行的指令数 </p>
<p><strong>CPU 执行时间</strong> </p>
<p>程序的 CPU 执行时间，即我们前面提到的 user + system 时间，可以用下面的公式来表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序 CPU 执行时间 = 指令数 * CPI * Clock Cycle Time</span><br></pre></td></tr></table></figure>



<h5 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h5><p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？<strong>可以想到指令 还可以再划分成一个个更小的阶段</strong>，例如，每条指令都可以分为： <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 这 5 个阶段</p>
<p><img src="/%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5(%E6%9C%AA%E4%BC%98%E5%8C%96%E5%89%8D).png" alt="指令的执行阶段(D:/VscodeProjects/source/_posts/指令的执行阶段(未优化前).png)"></p>
<blockquote>
<p><strong>术语参考</strong>： </p>
<ul>
<li>instruction fetch (IF) </li>
<li>instruction decode (ID) </li>
<li>execute (EX) </li>
<li>memory access (MEM) </li>
<li>register write back (WB)</li>
</ul>
</blockquote>
<p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong>，这一技术在 80’s 中 叶到 90’s 中叶占据了计算架构的重要地位</p>
<blockquote>
<p><strong>提示</strong>： </p>
<p>分阶段，分工是提升效率的关键！</p>
</blockquote>
<p><strong>指令重排的前提是，重排指令不能影响结果</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以重排的例子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 指令2</span></span><br><span class="line">System.out.println( a + b );</span><br><span class="line"><span class="comment">// 不能重排的例子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a - <span class="number">5</span>; <span class="comment">// 指令2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考</strong>： </p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scoreboarding">Scoreboarding</a> and the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tomasulo_algorithm">Tomasulo algorithm</a> (which is similar to scoreboarding but makes use of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Register_renaming">register renaming</a> )are two of the most common techniques for implementing out-of-order execution and instruction-level parallelism.</p>
</blockquote>
<h5 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h5><p>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理 器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间最长的复杂指令），IPC &#x3D; 1，<strong>本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了 指令地吞吐率</strong></p>
<blockquote>
<p><strong>提示</strong>： </p>
<p>奔腾四（Pentium 4）支持高达 35 级流水线，但由于功耗太高被废弃</p>
</blockquote>
<p><img src="/%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5(%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E5%90%8E).png" alt="指令的执行阶段(D:/VscodeProjects/source/_posts/指令的执行阶段(使用指令流水线优化后).png)"></p>
<p><strong>小总结</strong></p>
<p><strong>所以为什么会出现指令重排序呢？</strong></p>
<p><strong>1.因为通过指令重排序和组合可以实现指令并行(严格来说是并发)执行，大大提高单位时间内指令的执行效率和指令的吞吐量(指令并行技术的核心就是指令流水线技术)</strong></p>
<p>2.将指令的执行细分成更小的执行阶段，让自可以在多个不同的指令执行阶段中切换执行，大大提高单位时间内的指令执行效率和吞吐量**(必须先切分更细小的阶段，才能让cpu更灵活的在不同的指令执行阶段中切换，从而大大提高cpu的利用率)**</p>
<p>通俗点来理解：</p>
<p>比如一个人要做煮饭，烧水，煮菜三件事，如果不将每一件事情切分成更小的执行单位，那么就意味着我们必须先要煮完饭才能烧水，烧完水才能煮菜，但实际上煮饭只要前期下好米，后面都是等待时间 ，烧水同样是加好水打完火就是等待时间了，煮菜也类似，那么人在这些等待时间中实际上是空闲的，不就浪费了人这个资源吗？</p>
<p>如果我们将煮饭，烧水，煮菜切分更细小的执行单位，意味着我们可以在下好米后，等待饭煮好的时间取烧水，在等待烧好水的时间段取煮菜，这不就把人的等待时间(空闲时间)利用好了，大大提高了人这个资源的利用率，提高了单位时间内工作的吞吐量(单位时间内可以完成更多的工作)</p>
<p><strong>所以指令流水线技术其实也就是将生活中的思想应用到程序上罢了(并发技术也是这个原理，所以为什么要把进程切分更细小的线程工作单位，这也是重要的原因之一，因为其可以大大提高计算机共享资源的利用率，不仅仅是cpu资源，还有内存，缓存…)</strong></p>
<h4 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">//指令未重排时</span></span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//指令重排后，此时的执行流程就有可能是线程2执行到ready=true，线程1就进行了判断，此时num处于默认赋值的状态，那就是0+0 = 0;所以结果就变成了0(诡异的结果)</span></span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ </p>
<p>有同学这么分析 </p>
<p>情况1：线程1 先执行，这时 ready &#x3D; false，所以进入 else 分支结果为 1 </p>
<p>情况2：线程2 先执行 num &#x3D; 2，但没来得及执行 ready &#x3D; true，线程1 执行，还是进入 else 分支，结果为1 </p>
<p>情况3：线程2 执行到 ready &#x3D; true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p>
<p><strong>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！</strong> </p>
<p>这种情况下是：线程2 执行 ready &#x3D; true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num &#x3D; 2 </p>
<p>相信很多人已经晕了 😵😵😵</p>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现： </p>
<p>借助 java 并发压测工具 jcstress <a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DinteractiveMode=<span class="literal">false</span> -DarchetypeGroupId=org.openjdk.jcstress -</span><br><span class="line">DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -</span><br><span class="line">DartifactId=ordering -Dversion=1.0 </span><br></pre></td></tr></table></figure>

<p>创建 maven 项目，提供如下测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install </span><br><span class="line">java -jar target/jcstress.jar </span><br></pre></td></tr></table></figure>

<p>会输出我们感兴趣的结果，摘录其中一次结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests </span><br><span class="line"> Some interesting behaviors observed. This is <span class="keyword">for</span> the plain curiosity. </span><br><span class="line"> </span><br><span class="line"> 2 matching <span class="built_in">test</span> results. </span><br><span class="line"> 	[OK] test.ConcurrencyTest </span><br><span class="line"> 	(JVM args: [-XX:-TieredCompilation]) </span><br><span class="line">    Observed state 	Occurrences 	Expectation Interpretation </span><br><span class="line">    0 				1,729 			ACCEPTABLE_INTERESTING !!!! </span><br><span class="line"> 	1 				42,617,915 		ACCEPTABLE ok </span><br><span class="line"> 	4 				5,146,627 		ACCEPTABLE ok </span><br><span class="line"> </span><br><span class="line"> 	[OK] test.ConcurrencyTest </span><br><span class="line"> 	(JVM args: []) </span><br><span class="line"> 	Observed state 	Occurrences 	Expectation Interpretation </span><br><span class="line"> 	0 				1,652 			ACCEPTABLE_INTERESTING !!!! </span><br><span class="line"> 	1 				46,460,657 		ACCEPTABLE ok </span><br><span class="line"> 	4 				4,571,072 		ACCEPTABLE ok </span><br></pre></td></tr></table></figure>

<p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>volatile 修饰的变量，可以禁用指令重排</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests </span><br><span class="line"> Some interesting behaviors observed. This is <span class="keyword">for</span> the plain curiosity. </span><br><span class="line"> 0 matching <span class="built_in">test</span> results. </span><br></pre></td></tr></table></figure>



<h4 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a><font color='blue'>volatile的原理</font></h4><p><strong>volatile 的底层实现原理是内存屏障</strong>，Memory Barrier（Memory Fence） </p>
<ul>
<li><strong>对 volatile 变量的写指令后会加入写屏障</strong> </li>
<li><strong>对 volatile 变量的读指令前会加入读屏障</strong></li>
</ul>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><ul>
<li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
</li>
<li><pre><code class="java">public void actor2(I_Result r) &#123;
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public void actor1(I_Result r) &#123;</span><br><span class="line">      // 读屏障</span><br><span class="line">      // ready 是 volatile 读取值带读屏障</span><br><span class="line">      if(ready) &#123;</span><br><span class="line">          r.r1 = num + num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.r1 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><img src="D:/VscodeProjects/source/_posts/violate通过读屏障和写保障保障可见性.png" alt="violate通过读屏障和写保障保障可见性"></p>
</li>
</ul>
<p><strong>能保证可见性的核心在于无论读写操作都是操作主存而非缓存</strong></p>
<h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><ul>
<li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
</li>
<li><pre><code class="java">public void actor2(I_Result r) &#123;
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public void actor1(I_Result r) &#123;</span><br><span class="line">      // 读屏障</span><br><span class="line">      // ready 是 volatile 读取值带读屏障</span><br><span class="line">      if(ready) &#123;</span><br><span class="line">          r.r1 = num + num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.r1 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><img src="D:/VscodeProjects/source/_posts/volatile关键字通过读屏障和写屏障保证有序性.png" alt="volatile关键字通过读屏障和写屏障保证有序性"></p>
</li>
</ul>
<p>还是那句话，不能解决指令交错： </p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去 </li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/violate关键字只能保证可见性和有序性并不能保证原子性.png" alt="violate关键字只能保证可见性和有序性并不能保证原子性"></p>
<p><strong>从图示案例可以清晰看出,volatile关键字并不能阻止指令的交叉运行，也就是并不能保证线程指令执行的原子性</strong></p>
<p><strong>典型的没有保障指令执行的有序性的案例</strong></p>
<p>双检锁实现单例设计模式</p>
<h5 id="double-checked-locking的-问题"><a href="#double-checked-locking的-问题" class="headerlink" title="double-checked locking的 问题"></a>double-checked locking的 问题</h5><p>以著名的 double-checked locking 单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//双检锁实现模式思想解读</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//而实际上单例设计模式只有第一次创建是写操作，后续都是读操作，并发情况下是只有写操作会出现线程安全问题，并发读是不会出现的</span></span><br><span class="line">        <span class="comment">//所以实际上只有第一次写操作需要锁的同步代码块进行保护，后续的读操作都是不会出现</span></span><br><span class="line">        <span class="comment">//所以只需要保证第一次写操作是安全的即可，后续的读操作实际上是无需加锁的(读写分离思想)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123; <span class="comment">//此处再加一层if判断就可以分离读写操作，写操作会进入到同步代码块中受到保护，读操作则不会进入到同步代码块中</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance== <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance= <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是： </p>
<ul>
<li>懒惰实例化 </li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 </li>
<li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">3: ifnonnull 37</span><br><span class="line">6: ldc <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">8: dup</span><br><span class="line">9: astore_0</span><br><span class="line">10: monitorenter</span><br><span class="line">11: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">14: ifnonnull 27</span><br><span class="line">17: new <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial <span class="comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">24: putstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit</span><br><span class="line">29: goto 37</span><br><span class="line">32: astore_1</span><br><span class="line">33: aload_0</span><br><span class="line">34: monitorexit</span><br><span class="line">35: aload_1</span><br><span class="line">36: athrow</span><br><span class="line">37: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">40: areturn</span><br></pre></td></tr></table></figure>

<p>其中 </p>
<ul>
<li>17 表示创建对象，将对象引用入栈 &#x2F;&#x2F; new Singleton </li>
<li>20 表示复制一份对象引用 &#x2F;&#x2F; 引用地址 </li>
<li>21 表示利用一个对象引用，调用构造方法 </li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p>
<p><img src="D:/VscodeProjects/source/_posts/双检索实现单例设计模式的有序性问题.png" alt="双检索实现单例设计模式的有序性问题"></p>
<p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 </p>
<p><strong>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例</strong> </p>
<p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p>
<p><strong>问题解析通俗版：</strong></p>
<p>instance&#x3D; new Singleton();包含两个操作，一是调用对象构造方法初始化对象，第二个是将对象的引用地址赋值给变量;如果指令重排将这两个操作的执行交换了，那么在多线程环境，其他线程拿到的对象引用有可能就是一个假的引用，因为此时对象并没有执行完构造函数，调用该对象的相关功能就必然出现异常</p>
<h5 id="double-checked-locking-解决"><a href="#double-checked-locking-解决" class="headerlink" title="double-checked locking 解决"></a>double-checked locking 解决</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码上看不出来 volatile 指令的效果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="line">0: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">3: ifnonnull 37</span><br><span class="line">6: ldc <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">8: dup</span><br><span class="line">9: astore_0</span><br><span class="line">10: monitorenter -----------------------&gt; 保证原子性、可见性</span><br><span class="line">11: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">14: ifnonnull 27</span><br><span class="line">17: new <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial <span class="comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">24: putstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit ------------------------&gt; 保证原子性、可见性</span><br><span class="line">29: goto 37</span><br><span class="line">32: astore_1</span><br><span class="line">33: aload_0</span><br><span class="line">34: monitorexit</span><br><span class="line">35: aload_1</span><br><span class="line">36: athrow</span><br><span class="line">37: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">40: areturn</span><br></pre></td></tr></table></figure>

<p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面 两点：</p>
<ul>
<li>可见性 <ul>
<li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中 </li>
<li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li>有序性 <ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 </li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
<li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/violate关键字解决单例设计模式的双检索中的有序性问题.png" alt="violate关键字解决单例设计模式的双检索中的有序性问题"></p>
<p>从图中可以清晰的看出，加了volatile关键字保证了有序性之后，对象的赋值操作必然是在对象执行构造函数之后才会赋值，也就是不会出现二者的指令重排序现在，进而实现了指令的有序性</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p><strong>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结</strong>，抛 开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 </p>
<p><strong>等于是总结了对操作共享变量支持可见性和有序性的规律总结，也可以说是攻略</strong></p>
<p><strong>对于这七种规律要以理解为主，不要死记硬背，理解后无论是出现什么情况，都可以自己分析明白</strong></p>
<ul>
<li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见(synchronized关键字的可见性、监视器规则)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见(volatile关键字的可见性、volatile规则)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见(程序顺序规则+线程启动规则)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）(线程终止规则)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）（线程中断机制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 </p>
</li>
<li><p>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code> ，配合 volatile 的防指令重排，有下面的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">    System.out.println(x); </span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量都是指成员变量或静态成员变量 </p>
<p>参考： 第17页</p>
<p>在JMM中有一个很重要的概念对于我们了解JMM有很大的帮助，那就是happens-before规则。happens-before规则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。JSR-133S使用happens-before概念阐述了两个操作之间的内存可见性。在JMM中，如果一个操作的结果需要对另一个操作可见，那么这两个操作则存在happens-before关系。</p>
<p>那什么是happens-before呢？在JSR-133中，happens-before关系定义如下：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么意味着第一个操作的结果对第二个操作可见，而且第一个操作的执行顺序将排在第二个操作的前面。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系指定的顺序来执行。如果重排序之后的结果，与按照happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）</li>
</ol>
<p>happens-before规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile规则：对一个volatile变量的写，happens-before于任意后续对一个volatile变量的读。</li>
<li>传递性：若果A happens-before B，B happens-before C，那么A happens-before C。</li>
<li>线程启动规则：Thread对象的start()方法，happens-before于这个线程的任意后续操作。</li>
<li>线程终止规则：线程中的任意操作，happens-before于该线程的终止监测。我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断操作：对线程interrupt()方法的调用，happens-before于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到线程是否有中断发生。</li>
<li>对象终结规则：一个对象的初始化完成，happens-before于这个对象的finalize()方法的开始。</li>
</ol>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77157725">happens-before规则解析 - 知乎 (zhihu.com)</a></p>
</blockquote>
</li>
</ul>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><h5 id="balking-模式习题"><a href="#balking-模式习题" class="headerlink" title="balking 模式习题"></a>balking 模式习题</h5><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        doInit();</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h5 id="线程安全单例习题"><a href="#线程安全单例习题" class="headerlink" title="线程安全单例习题"></a>线程安全单例习题</h5><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p>
<blockquote>
<p>饿汉式：类加载就会导致该单实例对象被创建 </p>
<p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>
<p><strong>实现1(饿汉式)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final(防止被子类继承从而重写方法改写单例)</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例(重写readResolve方法)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?(防止外部调用构造方法创建多个实例；不能)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?(能，线程安全性由类加载器保障)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由(可以保证instance的安全性，也能方便实现一些附加逻辑)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实现2(枚举类)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的 (枚举类会按照声明的个数在类加载时实例化对象)</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题(没有，由类加载器保障安全性)</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例(不能)</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例(不能)</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式(饿汉)</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做(写构造方法)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    INSTANCE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实现3(synchronized方法)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点(没有线程安全问题，同步代码块粒度太大，性能差)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125; </span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实现4：DCL+volatile</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile ?(防止putstatic和invokespecial重排导致的异常)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义 (缩小了锁的粒度，提高了性能)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; <span class="comment">// t2 </span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实现5(内部类初始化)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式  懒汉式，类的加载总是懒惰的，外部类是一定要用到，所以一开始就会加载，而内部类则不一定，是在调用内部类的相关方法时才会加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><p>本章重点讲解了 JMM 中的 </p>
<ul>
<li>可见性 - <strong>由 JVM 缓存优化引起</strong> </li>
<li>有序性 - <strong>由 JVM 指令重排序优化引起</strong> </li>
<li>happens-before 规则 </li>
<li><font color='blue'>原理方面</font><ul>
<li>CPU 指令并行 </li>
<li>volatile</li>
</ul>
</li>
<li><font color='orange'>模式方面 </font><ul>
<li>两阶段终止模式的 volatile 改进 </li>
<li>同步模式之 balking</li>
</ul>
</li>
</ul>
<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><h2 id="问题提出-应用之互斥"><a href="#问题提出-应用之互斥" class="headerlink" title="问题提出 (应用之互斥)"></a>问题提出 (应用之互斥)</h2><p>有如下需求，保证 account.withdraw 取款方法的线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment"> * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance() </span><br><span class="line">                           + <span class="string">&quot; cost: &quot;</span> + (end-start)/<span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原有实现并不是线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafe</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某次的执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">330 cost: 306 ms</span><br></pre></td></tr></table></figure>



<h5 id="为什么不安全"><a href="#为什么不安全" class="headerlink" title="为什么不安全"></a><strong>为什么不安全</strong></h5><p><code>withdraw</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：Integer虽然是不可变类，其方法是线程安全的，但是以上操作涉及到了多个方法的组合，是不能阻止线程交叉运行的，所以是线程不安全的</p>
<h5 id="解决思路-锁（悲观互斥）"><a href="#解决思路-锁（悲观互斥）" class="headerlink" title="解决思路-锁（悲观互斥）"></a><strong>解决思路-锁</strong>（悲观互斥）</h5><p>首先想到的是给 Account 对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost: 399 ms </span><br></pre></td></tr></table></figure>



<h5 id="解决思路-无锁（乐观重试）"><a href="#解决思路-无锁（乐观重试）" class="headerlink" title="解决思路-无锁（乐观重试）"></a><strong>解决思路-无锁</strong>（乐观重试）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">        <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Account.demo(<span class="keyword">new</span> <span class="title class_">AccountSafe</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某次的执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost: 302 ms</span><br></pre></td></tr></table></figure>



<h2 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a>CAS 与 volatile</h2><p><strong>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全，那么它是如何实现的呢？</strong></p>
<p><strong>无锁实现共享变量的线程安全性的核心是CAS操作，而CAS操作的核心思想是比较并交换和不断重试机制，具体过程如下</strong></p>
<p>1.通过比较确认本线程操作的数据是否是原来的数据，如果不是原来的数据意味着该数据已经被其他线程修改过，意味着存在线程交叉运行的情况，即有可能会出现线程安全问题，所以此次操作只能以失败告终，只能不断的重试，直到比较的结果是原来的数据，才不会出现线程安全问题</p>
<p>2.需要注意的是即使比较的结果是原来的数据也并不意味着该数据没有被其他线程修改过，因为有可能其他线程的修改结果和原数据的结果是一致的，所以CAS操作并不能感知到共享数据是否被其他线程修改过，这也是典型的CAS操作的ABA问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span></span><br><span class="line"><span class="comment">             - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">             比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">             那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">             - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//或者简洁一点：</span></span><br><span class="line">            <span class="comment">//balance.getAndAdd(-1 * amount);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是 <strong>compareAndSet</strong>，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>
<p><img src="D:/VscodeProjects/source/_posts/CAS操作原理.png" alt="CAS操作原理"></p>
<blockquote>
<p><strong>注意</strong> </p>
<p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交 换】的原子性。</p>
<p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 的。</p>
</blockquote>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 </p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p>
<blockquote>
<p><strong>注意</strong> </p>
<p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原 子性）</p>
</blockquote>
<p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
<p><strong>为什么无锁效率高</strong> </p>
<ul>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，类似于自旋。而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。线程的上下文切换是费时的，在重试次数不是太多时，无锁的效率高于有锁。</li>
<li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 </li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换。<strong>所以总的来说，当线程数小于等于cpu核心数时，使用无锁方案是很合适的，因为有足够多的cpu让线程运行。当线程数远多于cpu核心数时，无锁效率相比于有锁就没有太大优势，因为依旧会发生上下文切换</strong></li>
</ul>
<p>线程上下文切换的成本可以<strong>结合计组的中断执行原理来理解</strong>，线程上下文切换需要保存操作现场，此过程会耗费很多资源，其次在恢复操作现场时，也会耗费很多资源</p>
<p><img src="D:/VscodeProjects/source/_posts/Java-Api层面，线程的六种状态.png" alt="Java-Api层面，线程的六种状态"></p>
<h5 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h5><p>结合 CAS 和 volatile <strong>可以实现无锁并发，适用于线程数少、多核 CPU 的场景下</strong>。 </p>
<ul>
<li>CAS 是基于<strong>乐观锁的思想</strong>：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗</li>
<li>synchronized 是基于<strong>悲观锁的思想</strong>：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。 </li>
<li><strong>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</strong> <ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>J.U.C 并发包提供了： </p>
<ul>
<li>AtomicBoolean </li>
<li>AtomicInteger </li>
<li>AtomicLong</li>
</ul>
<p>以 AtomicInteger 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line"><span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line"><span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line"><span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>以上方法都是以CAS为基础进行了封装，保证了方法的原子性和变量的可见性。</p>
</li>
<li><p>updateAndGet方法的手动实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> i.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span>(i.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>为什么需要原子引用类型？ </p>
<ul>
<li>AtomicReference </li>
<li>AtomicMarkableReference </li>
<li>AtomicStampedReference</li>
</ul>
<p><strong>实际开发的过程中我们使用的不一定是int、long等基本数据类型，也有可能时BigDecimal这样的类型，这时就需要用到原子引用作为容器</strong>。原子引用设置值使用的是<code>unsafe.compareAndSwapObject()</code>方法。原子引用中表示数据的类型需要重写<code>equals()</code>方法。</p>
<p>有如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment"> * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着提供不同的 DecimalAccount 实现，实现安全的取款操作</p>
<h5 id="不安全实现"><a href="#不安全实现" class="headerlink" title="不安全实现"></a><strong>不安全实现</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountUnsafe</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="安全实现-使用锁"><a href="#安全实现-使用锁" class="headerlink" title="安全实现-使用锁"></a><strong>安全实现-使用锁</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeLock</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeLock</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">            <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="安全实现-使用-CAS"><a href="#安全实现-使用-CAS" class="headerlink" title="安全实现-使用 CAS"></a><strong>安全实现-使用 CAS</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    AtomicReference&lt;BigDecimal&gt; ref;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ref.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DecimalAccount.demo(new DecimalAccountUnsafe(new BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">DecimalAccount.demo(new DecimalAccountSafeLock(new BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">DecimalAccount.demo(new DecimalAccountSafeCas(new BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4310 cost: 425 ms </span><br><span class="line">0 cost: 285 ms </span><br><span class="line">0 cost: 274 ms</span><br></pre></td></tr></table></figure>



<h5 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="ABA 问题及解决"></a>ABA 问题及解决</h5><p><strong>概念：</strong>CAS操作并不能感知共享数据是否被其他线程修改过，因为可能修改的数据值和原线程操作的数据值是一致的，此时是完全感知不到共享数据是被修改过的</p>
<p>如果想要解决ABA问题，可以<strong>给操作的共享数据加一个版本号或者加一个boolean值标识其是否被其他线程修改过即可</strong></p>
<p><strong>ABA 问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:29:52.325 c.Test36 [main] - main start... </span><br><span class="line">11:29:52.379 c.Test36 [t1] - change A-&gt;B <span class="literal">true</span> </span><br><span class="line">11:29:52.879 c.Test36 [t2] - change B-&gt;A <span class="literal">true</span> </span><br><span class="line">11:29:53.880 c.Test36 [main] - change A-&gt;C <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望： </p>
<p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，<strong>这时，仅比较值是不够的，需要再加一个版本号</strong></p>
<p><strong>AtomicStampedReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">    <span class="comment">// 获取版本号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">    log.debug(<span class="string">&quot;版本 &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">    <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, </span><br><span class="line">                                                      ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, </span><br><span class="line">                                                      ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:41:34.891 c.Test36 [main] - main start... </span><br><span class="line">15:41:34.894 c.Test36 [main] - 版本 0 </span><br><span class="line">15:41:34.956 c.Test36 [t1] - change A-&gt;B <span class="literal">true</span> </span><br><span class="line">15:41:34.956 c.Test36 [t1] - 更新版本为 1 </span><br><span class="line">15:41:35.457 c.Test36 [t2] - change B-&gt;A <span class="literal">true</span> </span><br><span class="line">15:41:35.457 c.Test36 [t2] - 更新版本为 2 </span><br><span class="line">15:41:36.457 c.Test36 [main] - change A-&gt;C <span class="literal">false</span> </span><br></pre></td></tr></table></figure>



<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： <code>A -&gt; B -&gt; A -&gt; C</code> ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。 </p>
<p><strong>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过</strong>，所以就有了AtomicMarkableReference</p>
<p><strong>AtomicMarkableReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicMarkableReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">       <span class="comment">// 获取值 A</span></span><br><span class="line">       <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> ref.isMarked();</span><br><span class="line">       other();</span><br><span class="line">       Thread.sleep(<span class="number">10</span>);</span><br><span class="line">       log.info(<span class="string">&quot;marked:&#123;&#125;&quot;</span>,marked);</span><br><span class="line">       <span class="comment">// 尝试改为 C</span></span><br><span class="line">       log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> ref.isMarked();</span><br><span class="line">           <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">           log.info(<span class="string">&quot;marked:&#123;&#125;&quot;</span>,marked);</span><br><span class="line">           log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(pre, <span class="string">&quot;B&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>));</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">       Thread.sleep(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> ref.isMarked();</span><br><span class="line">           <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">           log.info(<span class="string">&quot;marked:&#123;&#125;&quot;</span>,marked);</span><br><span class="line">           log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(pre, <span class="string">&quot;A&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>));</span><br><span class="line">       &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">14:35:57.761 [main] DEBUG com.czq.four.Test3 - main start...</span><br><span class="line">14:35:57.805 [t1] INFO com.czq.four.Test3 - marked:<span class="literal">true</span></span><br><span class="line">14:35:57.806 [t1] DEBUG com.czq.four.Test3 - change A-&gt;B <span class="literal">true</span></span><br><span class="line">14:35:57.807 [t2] INFO com.czq.four.Test3 - marked:<span class="literal">false</span></span><br><span class="line">14:35:57.807 [t2] DEBUG com.czq.four.Test3 - change B-&gt;A <span class="literal">false</span></span><br><span class="line">14:35:57.817 [main] INFO com.czq.four.Test3 - marked:<span class="literal">true</span></span><br><span class="line">14:35:57.817 [main] DEBUG com.czq.four.Test3 - change A-&gt;C <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>实际上大多数情况ABA问题并不会影响CAS操作的正确性，因为即使发生了ABA问题，也就是共享数据让其他线程修改过，但他们的修改结果和原线程操作的数据结果是一致的，所以并不会影响CAS操作的正确性</p>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li>AtomicIntegerArray </li>
<li>AtomicLongArray </li>
<li>AtomicReferenceArray</li>
</ul>
<p>有如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment"> 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment"> 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment"> 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line"><span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line"><span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(</span></span><br><span class="line"><span class="params">    Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">    Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">    BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">    Consumer&lt;T&gt; printConsumer )</span> &#123;</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个线程对数组作 10000 次操作</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                putConsumer.accept(array, j%length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line">    printConsumer.accept(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>不安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    ()-&gt;<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">    (array)-&gt;array.length,</span><br><span class="line">    (array, index) -&gt; array[index]++,</span><br><span class="line">    array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698] </span><br></pre></td></tr></table></figure>



<p><strong>安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    ()-&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">    (array) -&gt; array.length(),</span><br><span class="line">    (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">    array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] </span><br></pre></td></tr></table></figure>



<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><ul>
<li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段 </li>
<li>AtomicIntegerFieldUpdater </li>
<li>AtomicLongFieldUpdater 利用字段更新器，<strong>可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be volatile <span class="built_in">type</span></span><br></pre></td></tr></table></figure>



<p><strong>前面的原子引用进行CAS操作时针对是对象的地址值进行操作，而无法针对对象里的内容(属性)进行CAS操作，那么字段更新器其就是针对这一点而出现的解决方案，可以针对对象的某个属性进行CAS操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">Test5</span> <span class="variable">test5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test5</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">20 </span><br><span class="line">20 </span><br></pre></td></tr></table></figure>





<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><p>jdk专门设计的了一个原子累加器LongAdder，比原子整数累加的性能足足提高了10倍有余</p>
<h4 id="累加器性能比较"><a href="#累加器性能比较" class="headerlink" title="累加器性能比较"></a>累加器性能比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">adder</span> <span class="operator">=</span> adderSupplier.get();</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                action.accept(adder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start());</span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start)/<span class="number">1000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较 AtomicLong 与 LongAdder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>(), adder -&gt; adder.increment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1000000 cost:43 </span><br><span class="line">1000000 cost:9 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:31 </span><br><span class="line">1000000 cost:27 </span><br><span class="line">1000000 cost:28 </span><br><span class="line">1000000 cost:24 </span><br><span class="line">1000000 cost:22 </span><br></pre></td></tr></table></figure>

<p><strong>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</strong></p>
<p><strong>性能提升的核心理解</strong></p>
<p>需要明确的一点是，CAS操作性能之所以低的原因是共享资源在多线程竞争环境下需要不断的重试，直到CAS操作执行成功为止，实质上不断的重试是在不断的消耗cpu资源，性能自然低下，而原子累加器通过将一个加法的数据拆分n份数据，每个线程单独操作他的数据进行累加，最后再进行合并，这样就会不会出现多线程操作共享资源出现竞争的情况，进而避免了不断重试的机制，大大提高了累加执行的性能</p>
<h4 id="源码之-LongAdder"><a href="#源码之-LongAdder" class="headerlink" title="源码之 LongAdder"></a><font color='blue'>源码之 LongAdder</font></h4><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧 </p>
<p>LongAdder 类有几个关键域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁(cellsBusy是加锁的标志位，加锁时置为1，解锁时置为0)</span></span><br><span class="line"><span class="comment">//使用的就是CAS锁来保证创建cells数组和扩容cells数组时的线程安全性</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<h4 id="CAS锁"><a href="#CAS锁" class="headerlink" title="CAS锁"></a>CAS锁</h4><p>实践上不推荐使用CAS锁解决线程安全问题，因为可能会出现一些不可控的问题，底层源码是做了全面的考虑的，所以不会有这些问题，但个人不建议使用**(了解即可)**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//CAS锁的原理就是CAS操作</span></span><br><span class="line">    <span class="comment">//具体过程是当多线程进来加锁时，通过CAS操作保证只有一个人能够加锁成功(CAS操作成功)，其他线程在没有释放锁时只能不断的重试(CAS操作失败)等待锁的释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为只要有一个线程CAS操作成功，将加锁的标记数据值修改了，那么其他线程在用原来的值进行CAS操作必然失败，只有不断的重试等到占有锁的线程释放锁，也即将标记数据值修改为原来的数据值，此时其他线程才有可能成功进行CAS操作(加锁操作)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁成功就将标记数据值改为1</span></span><br><span class="line">        <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加锁将标记数据值还原为0</span></span><br><span class="line">    state.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中 Cell 即为累加单元</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @sun.misc.Contended注解防止缓存行伪共享，提高多核CPU的执行性能</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="防止缓存行伪共享"><a href="#防止缓存行伪共享" class="headerlink" title="防止缓存行伪共享"></a>防止缓存行伪共享</h4><p><strong>概念：</strong>避免不同CPU核心操作的是内存地址上连续但实际上操作的是不同的数据而造成的牵一发而动全身的数据一致性问题，进而提高多核CPU的执行性能**(因为可以在一定程度上减少了数据同步造成的资源消耗)**</p>
<p>得从缓存说起 </p>
<p>缓存与内存的速度比较</p>
<p><img src="D:/VscodeProjects/source/_posts/缓存和内存的速度比较.png" alt="缓存和内存的速度比较"></p>
<p><img src="D:/VscodeProjects/source/_posts/CPU读取各级缓存以及读取内存所需要的时钟周期对比.png" alt="CPU读取各级缓存以及读取内存所需要的时钟周期对比"></p>
<p><strong>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。</strong> </p>
<p>而**缓存以缓存行为单位，每个缓存行对应着一块内存(缓存和内存的映射关系)**，一般是 64 byte（8 个 long） </p>
<p>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 </p>
<p><strong>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/缓存之间的数据一致性.png" alt="缓存之间的数据一致性"></p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了： </p>
<ul>
<li>Core-0(即第一个CPU核心)  要修改 Cell[0] </li>
<li>Core-1(即第二个CPU核心)  要修改 Cell[1]</li>
</ul>
<p><strong>无论谁修改成功，都会导致对方 Core 的缓存行失效</strong>，比如Core-0 中<code>Cell[0]=6000, Cell[1]=8000</code>要累加<code>Cell[0]=6001, Cell[1]=8000</code> ，这时会让 Core-1 的缓存行失效 </p>
<p>@sun.misc.Contended 用来解决这个问题，<strong>它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/解决缓存行因缓存内存地址上连续数据而导致的牵一发而动全身的数据一致性问题.png" alt="解决缓存行因缓存内存地址上连续数据而导致的牵一发而动全身的数据一致性问题"></p>
<p><strong>小总结</strong></p>
<p><strong>问题：</strong></p>
<p>因CPU的与内存的速度差异极大，通过引入多级缓存方案解决，但引入多级缓存又会导致不同CPU核心之间的缓存数据一致性问题，如果是不同的CPU核心操作缓存同一块内存数据，那数据一致性的问题自然无法优化，但如果是不同的CPU核心操作的是内存地址上连续但不同的内存数据，也会造成其他CPU核心失效，失效的原因就是因为操作的数据在内存地址上是连续的，会作为一个整体被CPU核心读入到缓存行当中，只要修改地址上任意一个数据，那么整条连续的缓存数据都需要和其他CPU核心的缓存进行同步，以及和内存数据进行同步，非常浪费资源</p>
<p><strong>解决方案</strong></p>
<p>缓存行在缓存内存地址上连续的数据时，保证只缓存CPU核心想要读取的数据，而不会因为其内存上地址连续的原因进而把其他数据也缓存进来，如何保证呢？那就是在缓存好CPU核心想要读取的数据后，我们就在缓存数据前后个增加128字节的padding数据，保证缓存行不会因为地址连续而缓存了内存地址上连续的其他数据</p>
<h4 id="累加器执行流程源码解析"><a href="#累加器执行流程源码解析" class="headerlink" title="累加器执行流程源码解析"></a>累加器执行流程源码解析</h4><p><strong>add方法源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组</span></span><br><span class="line">    <span class="comment">// b 为基础值</span></span><br><span class="line">    <span class="comment">// x 为累加值</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">    <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">    <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// as 还没有创建</span></span><br><span class="line">            as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 当前线程对应的 cell 还没有</span></span><br><span class="line">            <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span></span><br><span class="line">            <span class="comment">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span></span><br><span class="line">            <span class="comment">// 除非刻意修改它</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 流程图</p>
<p><img src="D:/VscodeProjects/source/_posts/LongAdder累加器add方法的源码解析.png" alt="LongAdder累加器add方法的源码解析"></p>
<p>总结 ：</p>
<ul>
<li>如果已经<code>有了累加数组</code>或<code>给base累加发生了竞争导致失败</code><ul>
<li>如果<code>累加数组没有创建</code>或者<code>累加数组长度为1</code>或者<code>当前线程还没有对应的cell</code>或者<code>累加cell失败</code><ul>
<li>进入累加数组的创建流程</li>
</ul>
</li>
<li>否者说明累加成功，退出。</li>
</ul>
</li>
<li>否则累加成功</li>
</ul>
<p><strong>longAccumulate方法源码解析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe</span></span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collide 为 true 表示最后一个槽非空，需要扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="comment">// 已经有了 cells</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">            <span class="comment">// 成功则 break;</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上两种情况失败, 尝试给 base 累加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>longAccumulate 流程图</p>
<p><strong>cells未创建</strong>条件分支执行流程图</p>
<p><img src="D:/VscodeProjects/source/_posts/longAccumulate方法执行源码解析之cells未创建流程图.png" alt="longAccumulate方法执行源码解析之cells未创建流程图"></p>
<p><strong>cell未创建</strong>条件分支执行流程图</p>
<p><img src="D:/VscodeProjects/source/_posts/longAccumulate方法执行源码解析之cell未创建流程图.png" alt="longAccumulate方法执行源码解析之cell未创建流程图"></p>
<p><strong>cell已创建</strong>条件分支执行流程图</p>
<p>每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p>
<p><img src="D:/VscodeProjects/source/_posts/longAccumulate方法执行源码解析之cell已创建.png" alt="longAccumulate方法执行源码解析之cell已创建"></p>
<p>总结：</p>
<ul>
<li><p>先判断当前线程有没有对应的Cell</p>
<ul>
<li>如果没有，随机生成一个值，这个值与当前线程绑定，通过这个值的取模运算定位当前线程Cell的位置。</li>
</ul>
</li>
<li><p>进入for循环</p>
<ul>
<li><p>if 有Cells累加数组且长度大于0</p>
<ul>
<li><p>if 如果当前线程没有cell</p>
<ul>
<li><p>将新建的cell放入对应的槽位中，新建Cell成功，进入下一次循环，尝试cas累加。</p>
</li>
<li><p>将collide置为false，表示无需扩容。</p>
</li>
</ul>
</li>
<li><p>else if 有竞争</p>
<ul>
<li>将wasUncontended置为tue，进入分支底部，改变线程对应的cell来cas重试</li>
</ul>
</li>
<li><p>else if cas重试累加成功</p>
<ul>
<li>退出循环。</li>
</ul>
</li>
<li><p>else if  cells 长度已经超过了最大长度, 或者已经扩容,</p>
<ul>
<li>collide置为false，进入分支底部，改变线程对应的 cell 来重试 cas</li>
</ul>
</li>
<li><p>else if collide为false</p>
<ul>
<li>将collide置为true（确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了）</li>
</ul>
</li>
<li><p>else if 累加数组不繁忙且加锁成功</p>
<ul>
<li>退出本次循环，进入下一次循环（扩容）</li>
</ul>
</li>
<li><p>改变线程对应的 cell 来重试 cas</p>
</li>
</ul>
</li>
<li><p>else if 数组不繁忙且数组为null且加锁成功</p>
<ul>
<li>新建数组，在槽位处新建cell，释放锁，退出循环。</li>
</ul>
</li>
<li><p>else if 尝试给base累加成功</p>
<ul>
<li>退出循环</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>获取最终结果通过 sum 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无锁实现的缺陷"><a href="#无锁实现的缺陷" class="headerlink" title="无锁实现的缺陷"></a>无锁实现的缺陷</h2><ol>
<li><p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”</p>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销</p>
</li>
</ol>
<p>​	3.<strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作</p>
<p>​	举例说明：一旦遇到多个共享变量的操作时，需要同时操作多个原子对象时，操作就会变得非常复杂和麻烦，线程的安全性就难以实现，典型的案例就是后面线程安全集合CurrentHashMap实现统计26个字母的数量的案例，足足26个共享变量，使用无锁实现非常难以控制</p>
<p>​	4.虽然CAS操作本身是原子性的，但是多个线程之间仍然可能会发生并发读写竞争，导致数据不一致的问题。例如，如果一个线程正在读取某个共享变量的值，同时另外一个线程正在修改该变量的值，那么第一个线程读到的值就可能跟实际的值不一致。<strong>核心原因是CAS操作只能让写线程彼此互相感知，而读操作是不需要修改数据的，自然不需要CAS操作，就导致了读写线程彼此是不能互相感知的。</strong></p>
<p><strong>小总结</strong></p>
<p>1.无锁实现对比有锁实现虽然能够大幅度提高并发线程的效率，但是他并不能保障读写并发的数据一致性问题。对比有锁来说，无锁的好处具体体现在读读并发，读写并发两种并发操作类型读操作是不受影响的，并且读写并发不用切换线程上下文，从而达到大幅度提高线程并发的效果。</p>
<p>2.但有锁也能实现这样的效果，使用读写分离的思想即可，但是不如无锁实现的读读并发，读写并发的效率高，因为无锁实现的读操作是不受限制的，不需要像有锁实现那样需要加锁。当然无锁实现这样做的代价是牺牲了读写并发的数据一致性。</p>
<p>3.所以具体选用有锁实现还是无锁实现，有锁实现选择那种方案都要根据你的需求来，没有哪一种方案是十全十美的</p>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>Unsafe 对象提供了非常底层的，操作内存、线程的方法</strong>，Unsafe 对象不能直接调用，只能通过反射获得。jdk8直接调用<code>Unsafe.getUnsafe()</code>获得的unsafe不能用</p>
<p><strong>CAS的底层就是用Unsafe实现的，因为CAS的比较并交换是CPU指令级来保证原子性的，所以需要直接操作计算机底层的内存和线程资源，当然Java语言并没有提供操作计算机底层资源的操作，所以Unsafe底层是用C++来实现的，因为C++可以直接操作计算机底层的内存，线程等资源</strong></p>
<p>反射获取 Unsafe对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe对象的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下三个方法只执行一次，成功返回true，不成功返回false</span></span><br><span class="line"><span class="comment">//第二个参数就是操作属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line"><span class="comment">//第二个参数就是操作属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line"><span class="comment">//第二个参数就是操作属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>细节</strong></p>
<p>Unsafe对象对某一个对象的属性进行CAS操作时涉及到一个偏移量的概念，偏移量是该属性相对该对象的内存偏移地址，可以帮助我们准确的定位到该属性的内存空间，但是经过测试发现不同对象的同一个属性，他们的偏移量是一致的，所以偏移量应该是属于类的概念，而不是属于对象的概念，当然具体的细节得等后续学习JVM时了解对象的内存存储模型时才能知道</p>
<h4 id="Unsafe-实现CAS-操作"><a href="#Unsafe-实现CAS-操作" class="headerlink" title="Unsafe 实现CAS 操作"></a>Unsafe 实现CAS 操作</h4><p><strong>CAS 操作的核心思想就是比较并交换，无论是那种原子类型(原子整数，原子引用，原子数组…)，核心都是比较并交换，只是操作的数据类型不一致而已</strong></p>
<h5 id="unsafe实现字段更新"><a href="#unsafe实现字段更新" class="headerlink" title="unsafe实现字段更新"></a>unsafe实现字段更新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeAccessor.getUnsafe();</span><br><span class="line"><span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line"><span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 使用 cas 方法替换成员变量的值</span></span><br><span class="line"><span class="comment">//CAS操作底层就是调用compareAndSwapInt,compareAndSwapObject...来实现的</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 返回 true</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="built_in">id</span>=20, name=张三) </span><br></pre></td></tr></table></figure>



<h5 id="unsafe模拟实现原子整数"><a href="#unsafe模拟实现原子整数" class="headerlink" title="unsafe模拟实现原子整数"></a>unsafe模拟实现原子整数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="comment">//value属性的地址编译量，可以根据该编译量寻找到该属性的存储空间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        unsafe = Test.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> next)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="built_in">this</span>,valueOffset,pre,next))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">MyAtomicInteger</span> <span class="variable">myAtomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           myAtomicInteger.compareAndSet(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           myAtomicInteger.compareAndSet(myAtomicInteger.getValue(),<span class="number">2</span>);</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       Thread.sleep(<span class="number">10</span>);</span><br><span class="line">       System.out.println(myAtomicInteger.getValue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>CAS 与 volatile </li>
<li>API <ul>
<li>原子整数 </li>
<li>原子引用 </li>
<li>原子数组 </li>
<li>字段更新器 </li>
<li>原子累加器</li>
</ul>
</li>
<li><strong>Unsafe</strong> </li>
<li><font color='blue'>原理方面 </font><ul>
<li>LongAdder 源码 </li>
<li>伪共享</li>
</ul>
</li>
</ul>
<h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><h2 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h2><h5 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h5><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果，例如：</p>
<h5 id="思路-同步锁"><a href="#思路-同步锁" class="headerlink" title="思路 - 同步锁"></a>思路 - 同步锁</h5><p>这样虽能解决问题，但带来的是<strong>性能上的损失</strong>，并不算很好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="思路-不可变"><a href="#思路-不可变" class="headerlink" title="思路 - 不可变"></a>思路 - 不可变</h5><p><strong>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！</strong>这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看 DateTimeFormatter 的文档：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@implSpec</span></span><br><span class="line"><span class="comment">//This class is immutable and thread-safe.</span></span><br></pre></td></tr></table></figure>

<p>不可变对象，实际是另一种避免竞争的方式。</p>
<h2 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h2><h4 id="String类的设计"><a href="#String类的设计" class="headerlink" title="String类的设计"></a>String类的设计</h4><p>另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>将类声明为final，避免被带外星方法的子类继承，从而破坏了不可变性</li>
<li>将字符数组设置private，不提供给外部类访问，自然无法修改字符数组中的内容</li>
<li>将字符数组声明为final，避免其引用被修改</li>
<li>hash虽然不是final的，但是其只有在调用<code>hash()</code>方法的时候才被赋值，除此之外再无别的方法修改</li>
</ul>
<h4 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h4><p>发现该类、类中所有属性都是 final 的 </p>
<ul>
<li>属性用 final 修饰保证了该属性是只读的，不能修改 </li>
<li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>
<h4 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h4><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String </span><br><span class="line">    <span class="title function_">ng</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出 了修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果发现也没有，<strong>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避 免共享的手段称之为【保护性拷贝（defensive copy）】</strong></p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><font color='orange'>享元模式</font></h4><p><strong>前情提要：</strong></p>
<p>因为不可变类的设计会导致创建大量的对象资源，耗费的空间资源非常多。那些设计不可变类的人就想到了一种优化方法，既然每次都会创建一个新的对象，那我能不能复用这些已创建的对象资源呢？答案是可以的，这种方案就是使用著名的享元设计模式来实现的</p>
<p><strong>定义：</strong></p>
<p>​	运用共享技术来有效地支持<strong>大量细粒度对象的复用</strong>，它通过共享已经存在的对象来大幅度减少需要创建的对象数量、<strong>避免大量相似对象的开销</strong>，从而提高系统资源的利用率</p>
<p><strong>享元模式的核心思想：复用共享资源(池化复用)，避免共享资源重复创建而导致的浪费</strong></p>
<h5 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h5><p><strong>包装类</strong></p>
<p><strong>每种类型的包装类都有对应的常量池复用对应的包装类对象</strong></p>
<p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>： </p>
<ul>
<li>Byte, Short, Long 缓存的范围都是 -128~127 </li>
<li>Character 缓存的范围是 0~127 </li>
<li>Integer的默认范围是 -128~127 <ul>
<li>最小值不能变 </li>
<li>但最大值可以通过调整虚拟机参数 <code>  -Djava.lang.Integer.IntegerCache.high</code> 来改变</li>
</ul>
</li>
<li>Boolean 缓存了 TRUE 和 FALSE</li>
</ul>
</blockquote>
<p><strong>String 串池</strong>（不可变、线程安全）</p>
<p>详见jvm</p>
<p><strong>BigDecimal BigInteger</strong>(不可变、线程安全)</p>
<p>一部分数字使用了享元模式进行了缓存。</p>
<h5 id="手动实现一个连接池"><a href="#手动实现一个连接池" class="headerlink" title="手动实现一个连接池"></a>手动实现一个连接池</h5><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.定义连接池的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> poosSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义连接数组(连接池)  并发情况下获取和归还连接也存在线程安全问题</span></span><br><span class="line">    <span class="comment">//因为连接状态和连接对象是唯一的映射关系，只需保证一个线程安全另一个被包裹在其中，自然就是线程安全的了</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.定义连接状态数组 0表示空闲 1表示忙 并发情况存在多线程同时修改同一个连接的状态，需要保证线程安全(原子数组实现)</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.初始化连接池对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poosSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.poosSize = poosSize;</span><br><span class="line">        connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poosSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poosSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poosSize]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.获取连接对象</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//4.1判断连接数组中是否有空闲连接对象，如果有则直接返回，没有则阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; states.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.get(i) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//CAS无锁实现保证线程安全</span></span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i,<span class="number">0</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;get&#123;&#125;&quot;</span>,connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//阻塞等待，避免cpu空转浪费资源</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait....&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.归还连接对象，即将连接对象的状态设置为空闲状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection connection)</span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有连接对象，通过匹配找到归还的连接对象在连接数组中的所在位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; connections.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == connection) &#123;</span><br><span class="line">                <span class="comment">//归还连接对象不需要保证线程安全是因为此时连接对象并不是共享资源，而是每个线程单独一个连接对象，没有线程安全问题</span></span><br><span class="line">                <span class="comment">//前提是需要保证获取连接对象时是线程安全的，如果获取时不是线程安全的就有可能出现多个线程对象共享同一个连接对象的情况</span></span><br><span class="line">                states.set(i,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//唤醒阻塞等待获取连接的所有线程</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>,connection);</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用连接池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> pool.borrow();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pool.free(conn);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实现没有考虑： </p>
<ul>
<li>连接的动态增长与收缩 </li>
<li>连接保活（可用性检测） </li>
<li>等待超时处理 </li>
<li>分布式 hash</li>
</ul>
<p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p>
<h4 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a><font color='blue'>final原理</font></h4><h5 id="设置final-变量的原理"><a href="#设置final-变量的原理" class="headerlink" title="设置final 变量的原理"></a>设置final 变量的原理</h5><p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial <span class="comment">#1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">4: aload_0</span><br><span class="line">5: bipush 20</span><br><span class="line">7: putfield <span class="comment">#2 // Field a:I</span></span><br><span class="line"> &lt;-- 写屏障</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，这样对final变量的写入不会重排序到构造方法之外，保证在其它线程读到 它的值时不会出现为 0 的情况。普通变量不能保证这一点了**(写操作前会加入写屏障保证可见性和有序性)**</p>
<h5 id="读取final变量原理"><a href="#读取final变量原理" class="headerlink" title="读取final变量原理"></a>读取final变量原理</h5><p>有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> Short.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UseFinal1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">        System.out.println(TestFinal.B);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">TestFinal</span>().a);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">TestFinal</span>().b);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestFinal</span>().test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UseFinal2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译UseFinal1中的test方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">test</span><span class="params">()</span>V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">31</span> L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    BIPUSH <span class="number">10</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">32</span> L1</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="number">32768</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L2</span><br><span class="line">    LINENUMBER <span class="number">33</span> L2</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    NEW cn/itcast/n5/TestFinal</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL cn/itcast/n5/TestFinal.&lt;init&gt; ()V</span><br><span class="line">    INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;</span><br><span class="line">    POP</span><br><span class="line">    BIPUSH <span class="number">20</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L3</span><br><span class="line">    LINENUMBER <span class="number">34</span> L3</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    NEW cn/itcast/n5/TestFinal</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL cn/itcast/n5/TestFinal.&lt;init&gt; ()V</span><br><span class="line">    INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;</span><br><span class="line">    POP</span><br><span class="line">    LDC <span class="number">2147483647</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L4</span><br><span class="line">    LINENUMBER <span class="number">35</span> L4</span><br><span class="line">    NEW cn/itcast/n5/TestFinal</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL cn/itcast/n5/TestFinal.&lt;init&gt; ()V</span><br><span class="line">    INVOKEVIRTUAL cn/itcast/n5/TestFinal.test1 ()V</span><br><span class="line">   L5</span><br><span class="line">    LINENUMBER <span class="number">36</span> L5</span><br><span class="line">    RETURN</span><br><span class="line">   L6</span><br><span class="line">    LOCALVARIABLE <span class="built_in">this</span> Lcn/itcast/n5/UseFinal1; L0 L6 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">3</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，jvm对final变量的访问做出了优化<strong>：另一个类中的方法调用final变量是，不是从final变量所在类中获取（共享内存），而是直接复制一份到方法栈栈帧中的操作数栈中（工作内存），这样可以提升效率，是一种优化</strong></p>
<p>总结：</p>
<ul>
<li>对于较小的static final变量：复制一份到操作数栈中</li>
<li>对于较大的static final变量：复制一份到当前类的常量池中</li>
<li>对于非静态final变量，优化同上</li>
</ul>
<p><strong>核心的优化思想是如果使用final修饰变量，那底层将会在所有使用该变量的地方copy一份，避免其成为共享变量，就不需要使用各种耗费性能的手段解决线程安全问题，自然性能会得到很大的提升</strong></p>
<h5 id="final总结"><a href="#final总结" class="headerlink" title="final总结"></a>final总结</h5><p><strong>final关键字的好处：</strong></p>
<p>（1）final关键字提高了性能。<strong>JVM和Java应用都会缓存final变量</strong></p>
<p>（2）<strong>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销</strong></p>
<p>（3）使用final关键字，JVM会对方法、变量及类进行优化</p>
<p><strong>关于final的重要知识点</strong></p>
<p>1、final关键字可以用于成员变量、本地变量、方法以及类</p>
<p>2、final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误</p>
<p>3、你不能够对final变量再次赋值</p>
<p>4、本地变量必须在声明时赋值</p>
<p>5、<strong>在匿名类中所有变量都必须是final变量(为了保证二者数据的一致性，因为是通过拷贝机制复制值的，如果二者任意一个值发生改变，另一个值是感知不到的，那就会发生数据一致性问题，导致程序运行出错)</strong></p>
<p>6、final方法不能被重写</p>
<p>7、final类不能被继承</p>
<p>8、final关键字不同于finally关键字，后者用于异常处理</p>
<p>9、final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法</p>
<p>10、接口中声明的所有变量本身是final的</p>
<p>11、final和abstract这两个关键字是反相关的，final类就不可能是abstract的</p>
<p>12、<strong>final方法在编译阶段绑定，称为静态绑定(static binding)</strong></p>
<p>13、<strong>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”</strong></p>
<p>14、将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化</p>
<p>15、按照Java代码惯例，final变量就是常量，而且通常常量名要大写</p>
<p>16、对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.php.cn/java-article-413390.html">Java中final实现原理的深入分析（附示例）-java教程-PHP中文网</a></p>
</blockquote>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的 </p>
<blockquote>
<p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p>
</blockquote>
<p>无状态的意思就是没有成员变量也没有静态变量自然就没有共享资源，没有共享资源自然就不会发生线程安全问题</p>
<h1 id="共享模型之工具"><a href="#共享模型之工具" class="headerlink" title="共享模型之工具"></a>共享模型之工具</h1><p><strong>进程是什么？线程是什么？进程和线程的关系是什么？</strong></p>
<p>进程是操作系统资源分配的基本单位，进程是程序运行的实例，线程是CPU任务调度的基本单位，那为什么资源分配的基本单位不能是线程呢？任务调度的基本单位不能是线程呢？</p>
<p>​	答案早期进程确实是任务调度的基本单位，CPU也是通过调度进程来完成任务的，但后面发现单进程效率和性能更低了，就向着多进程执行程序的方向前进，但后面又发现多进程的话，进程的通信成本非常高，进行的上下文切换成本也非常高，为什么成本非常高呢？因为创建一个进程所需要的系统资源是巨大的，而且每个进程是独立分配一份资源，没有共享资源，通信成本自然高，而且创建一个进程需要耗费巨大的资源，那你切换进程的上下文，需要切换的资源，重新加载的资源就是巨大的，自然进程的上下文也会耗费巨大的资源</p>
<p>​	主要的原因是创建进程是非常耗费资源的，而且又是独立分配资源，自然通信成本高，进程上下文切换成本高，提高进程的并发性成本就更高，所以科学家就研究出了一个更细小的可执行单位，线程，线程因为共享进程资源，导致其成本相较于进程大大降低，也正因为其共享资源，所以线程之间的通信成本也更低，自然而然线程的成本更低，并发性能还能更好，所以进程就专心做资源分配和管理的基本单位啦，具体进程中的任务就给成本更低，性能更好的线程啦</p>
<p><strong>进程的上下文又是什么呢？线程的上下文又是什么呢？</strong></p>
<p>进程的上下文就是进程运行所需要的环境支持，线程的上下文就是线程运行所需要的环境支持，具体是什么支持可以自行去网上搜索，我这里就不一一罗列了</p>
<p><strong>CPU和进程的关系是什么？</strong></p>
<p>CPU属于系统资源的一种，操作系统将CPU资源分配给进程，进程是资源分配的基本单位，也可以直接通俗的把进程看作是资源的容器</p>
<p>CPU与线程的关系又是什么？</p>
<p>实质上操作系统将CPU资源是分配给进程中的线程，因为线程才是任务调度的基本单位，而线程本身也归属于进程，所以也可以说操作系统将CPU资源分配了进程</p>
<p><strong>内核是什么？内核的作用是什么？</strong></p>
<p>​	内核是提供应用程序和硬件之间的桥梁，让应用程序可以屏蔽硬件的实现细节，通过内核中统一提供的接口来访问系统资源，既保护了系统资源的安全又让应用程序可以简单高效的利用系统资源，而不用让应用程序自己去搞懂硬件设备的细节</p>
<p><strong>用户态和内核态是什么？为什么要区分用户态和内核态</strong></p>
<p>​	为了更好区分应用程序的空间和系统程序的空间，操作系统的内核分为两种状态，一种是用户态，供应用程序进行访问和调用，另一种是内核态，供系统程序进行访问和调用。这样做的好处是更好的保护系统资源，让计算机处于一个更安全更可靠的环境上，应用程序的权限较少，如果要访问系统资源，用户态需要关联内核态的相关资源，发起系统调用方可调用系统资源</p>
<h2 id="并发和并行的理解"><a href="#并发和并行的理解" class="headerlink" title="并发和并行的理解"></a>并发和并行的理解</h2><p>并发和并行都是多任务处理的概念，但它们有着本质的区别</p>
<p>​	并发指的是在一段时间内同时处理多个任务，这些任务之间可能会相互干扰或者依赖。例如，在一个操作系统中，可能会同时运行多个应用程序，每个应用程序都独立运行，但是它们共享计算机的资源，如CPU、内存等。在并发处理中，并不需要同时执行每个任务，而是通过时间分片的方式轮流执行各个任务，让用户感觉好像所有任务都在同时执行。</p>
<p>​	而并行则指的是同时执行多个任务，这些任务之间没有相互干扰或者依赖关系。例如，在一个拥有多个CPU核心的计算机系统中，可以将多个不同的任务分配给不同的CPU核心同时执行。在并行处理中，每个任务被分配给不同的处理单元进行处理，从而提高了整个系统的处理能力。</p>
<p>因此，可以说<strong>并发强调的是多个任务在时间上的交错执行，而并行则强调多个任务在空间上的同时执行</strong></p>
<h2 id="多线程的理解"><a href="#多线程的理解" class="headerlink" title="多线程的理解"></a>多线程的理解</h2><h5 id="多线程的作用和意义"><a href="#多线程的作用和意义" class="headerlink" title="多线程的作用和意义"></a><strong>多线程的作用和意义</strong></h5><p>​	多线程的主要作用和意义是提高程序的并发性和性能，通过同时处理多个任务，最大限度地利用系统资源，加快程序的执行速度。多线程可以分为两种类型：<strong>CPU密集型任务和IO密集型任务</strong>。在CPU密集型任务的情况下，单线程会花费很长时间来完成计算，而多线程则可以把任务分成多个子任务，利用多个CPU核心同时执行，提高计算效率，进而提高程序的性能</p>
<p>​	在IO密集型任务的情况下，单线程可能会花费很长时间在等待IO操作完成上，而多线程则可以将IO操作和计算任务分开，利用IO操作的等待时间，同时执行其他任务，充分利用系统资源，提高程序的性能。然而，使用多线程也会带来一些成本，比如线程管理和同步、锁和互斥、上下文切换等开销。因此，在使用多线程时，需要仔细权衡多线程的作用和带来的成本，综合考虑因素，以达到最优的应用效果</p>
<p>多线程的作用和意义核心总结：<br><strong>多线程是通过最大限度利用系统资源，从而达到提高程序的执行效率和性能的目的</strong></p>
<h5 id="最大限度利用系统资源"><a href="#最大限度利用系统资源" class="headerlink" title="最大限度利用系统资源"></a>最大限度利用系统资源</h5><p>那么最大限度利用系统资源，这里的资源主要指什么呢？</p>
<p>从多线程的两种类型来理解：CPU密集型任务和IO密集型任务<br>前者主要是利用多核CPU的优势，不能让其他CPU闲着，充分利用多核CPU的生产力</p>
<p>后者是在IO任务执行时，CPU其实是不需要参与的，处于空闲状态，而且CPU的执行速度和IO的执行速度差距巨大，如果让CPU等待IO任务执行完，那么CPU就空闲了很久了，所以可以利用多线程切换CPU的控制权，充分利用CPU空闲等待的时间，大大提高CPU资源的利用率，实质上也是不能让CPU闲着</p>
<p>答案很明显了，<strong>系统资源主要指的是CPU资源和内存资源</strong>，CPU资源上面已经解释过了。接下来简单解释一下内存，任何数据要想使用都是要加载到内存中的，都是需要相应的磁盘空间去存储的，所以内存资源也是非常关键的系统资源</p>
<h5 id="多线程主要耗费的资源-成本"><a href="#多线程主要耗费的资源-成本" class="headerlink" title="多线程主要耗费的资源(成本)"></a><strong>多线程主要耗费的资源(成本)</strong></h5><p>1.CPU资源：由于多线程需要在不同的时间片上进行调度和执行，因此多线程会占用一定的CPU资源，尤其对于计算密集型的任务，需要尽可能利用CPU资源提高计算效率</p>
<p>2.内存资源：每个线程都需要分配一定的内存空间，用于存储线程的上下文信息、栈空间、状态等。多线程的内存占用量随着线程数量的增加而增加，因此需要注意线程数目的控制</p>
<p>3.线程上下文切换资源：多个线程之间的切换需要保存当前线程的上下文信息并恢复下一个线程的上下文信息，这个过程称之为上下文切换。上下文切换需要消耗一定的CPU时间和内存空间，如果线程数目过多或者切换频繁，会导致系统性能下降</p>
<p>4.线程管理成本：系统需要维护一个线程池来管理所有的线程，包括线程的创建、销毁、调度、同步、互斥等操作。线程管理的开销随着线程数量的增加而增加，需要注意合理管理线程，以避免开销过大</p>
<p>5.锁和同步成本：多线程需要共享同一个资源或者变量时，需要采取锁或其他同步机制，以避免出现竞争和不一致的现象。锁和同步机制需要消耗额外的计算资源和内存空间，同时容易引起死锁、卡顿等问题</p>
<p><strong>如何权衡多线程的作用和其带来的成本</strong></p>
<p>在权衡好多线程的作用和其带来的成本时，需要考虑以下因素：</p>
<p>1.任务类型：任务类型是选择使用多线程还是单线程的重要条件之一</p>
<p>如果任务是CPU密集型任务，则可以尝试使用多线程来提高执行效率。如果任务是IO密集型任务，则需要根据具体情况来进行选择，可能需要通过采用异步IO等机制来提升效率</p>
<p>2.多线程耗费的资源和成本(上文有详解)</p>
<p>综上所述，在使用多线程实现程序时，需要根据任务类型、多线程带来的性能提升以及相应的成本消耗等因素进行综合评估和规划，以达到最优的程序效率和可靠性</p>
<p>至于具体如何权衡好多线程的作用以及其相应带来的成本，这个得大量的实践经验才能熟知<br>一般情况下的项目只需要根据实际的需求是CPU密集型还是IO密集型，分配合理的线程资源执行程序即可，这个合理分配线程数究竟是分配多少，也是要根据具体业务场景来指定的</p>
<p><strong>多线程和并发并行的关系又是什么？</strong></p>
<p>想必读完前面你已经能清楚的知道，并发并行都是处理多任务的概念，那么多线程本身就能同一时间段处理多个任务，所以说多线程是实现并发并行的一种技术方案</p>
<h5 id="多进程和多线程对比"><a href="#多进程和多线程对比" class="headerlink" title="多进程和多线程对比"></a>多进程和多线程对比</h5><p>多进程和多线程都是实现并发的方式，它们各有优缺点。下面我们来分别介绍它们的特点和比较</p>
<p>多进程<br>优点：<br>1.多进程之间相互独立，不存在竞态条件和死锁等问题。<br>2.多进程可以更好地利用多核CPU，每个进程都可以充分利用一个CPU来执行任务，从而提高了整体的处理能力。<br>3.多进程具有更好的稳定性和可靠性，如果某个进程出现错误，可以将该进程杀死而不影响其它进程的正常运行。<br>4.多进程可以更好地支持分布式计算和负载均衡。<br>缺点：<br>1.进程切换开销大，由于每个进程都有自己的地址空间、文件描述符、网络连接等资源，因此在进程间切换时需要进行大量的上下文切换和复制内存操作，开销很大。<br>2.进程间通信需要额外的机制和开销，例如管道、共享内存、消息队列等。<br>3.创建和销毁进程开销很大，因为每个进程需要创建自己的地址空间、堆栈等资源，这些过程需要进行复杂的初始化和清理操作。</p>
<p>多线程<br>优点：<br>1.线程之间共享进程的地址空间和系统资源，相对于进程来说，线程的切换和数据共享更加高效。<br>2.多线程可以更好地利用多核CPU，并行计算能力更强。<br>3.线程之间通信比进程之间通信更加方便，例如使用锁、条件变量等机制实现同步和互斥操作。<br>4.创建和销毁线程的开销比进程小得多，因为线程共享进程的地址空间和资源。<br>缺点：<br>1.线程之间共享数据需要进行同步和互斥操作，这些操作需要额外的开销并且容易引起死锁和竞态条件等问题。<br>2.某个线程出现错误可能会影响到整个进程的稳定性。<br>3.程序设计和调试时需要注意线程安全的问题，否则容易导致代码难以维护和扩展。</p>
<p>总结<br>    多进程和多线程各有利弊，应根据具体需求和场景选择合适的方式。如果需要更好的共享数据和通信能力，可以考虑使用多线程；如果需要更好的稳定性和可靠性，或者需要进行分布式计算和负载均衡，可以考虑使用多进程。在程序设计和开发过程中，应注意多线程或多进程环境下的安全和稳定性问题，合理使用锁、条件变量、信号量等同步机制来保证数据的一致性和安全性。</p>
<p><strong>核心：要将CPU，进程，线程三个概念串联起来，才能更好的理解并发并行，多线程的概念</strong></p>
<p>究竟三者的关系是什么？三者分别的作用和意义又是什么？</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p><img src="D:/VscodeProjects/source/_posts/自定义线程池.png" alt="自定义线程池"></p>
<p><strong>步骤1：自定义拒绝策略接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A.在任务队列满时可以让调用者自行选择拒绝任务的策略，使用策略模式而非if-else实现，可以大大提高程序的扩展性，降低代码的侵入性</p>
<p><strong>步骤2：自定义任务队列(阻塞队列)</strong></p>
<p><strong>阻塞队列是用来在线程池没有空闲线程处理任务时，暂时存储任务数据</strong>，使用队列结构实现是因为任务消息的生产和任务消息的消费是一个入口一个出口，符合队列解构的先进先出的数据特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义任务队列(阻塞队列)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.双向链表实现任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.锁对象，保证存取队列元素的线程安全性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.消费者条件变量，两个条件变量是用来平衡生产者和消费的工作效率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.记录队列所能存储的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.获取队列元素的方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//锁保证获取元素时的线程安全性</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果队列为空就让线程阻塞等待，等待唤醒后再获取资源</span></span><br><span class="line">            <span class="comment">//多次判断资源和获取资源的机会用while来实现，因为一个条件变量中存在多个线程，只会有一个线程竞争成功，其他线程就得继续循环阻塞等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取完元素后要立即删除，避免元素被重复消费</span></span><br><span class="line">            <span class="comment">//获取了队列元素后，说明队列已经不可能处于满容量的状态了，唤醒那些因为队列满了而无法存储元素到队列的阻塞等待线程</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullCondition.signalAll();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取元素的plus版本：带超时时间的获取队列元素方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeOut, TimeUnit unit)</span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//统一时间单位为纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeOut);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果剩余等待时间已经小于0了，说明已经超时，直接返回null即可</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//awaitNanos(timeOut)方法的返回值就是剩余的等待时间，如果想深究实现原理可以回到前面wait(timeOut)原理上看</span></span><br><span class="line">                    nanos = emptyCondition.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullCondition.signalAll();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.存储元素到队列中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span>&#123;</span><br><span class="line">        <span class="comment">//锁保证存储元素时的线程安全性</span></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果队列存储的容量已经达到最大容量，则让线程阻塞等待队列释放元素空间</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);</span><br><span class="line">                    fullCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//给队列中添加元素后说明队列已经不为空了，唤醒那些因为队列为空而阻塞等待获取元素的队列</span></span><br><span class="line">            log.debug(<span class="string">&quot;task &#123;&#125; 加入任务队列&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyCondition.signalAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时时间的存储元素到阻塞队列的版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task,<span class="type">long</span> timeOut,TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="comment">//锁保证存储元素时的线程安全性</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//统一转化时间单位为纳秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeOut);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果队列存储的容量已经达到最大容量，则让线程阻塞等待队列释放元素空间</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//已超时，无需继续阻塞等待任务队列释放空间，直接返回即可</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);</span><br><span class="line">                    nanos = fullCondition.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//给队列中添加元素后说明队列已经不为空了，唤醒那些因为队列为空而阻塞等待获取元素的队列</span></span><br><span class="line">            log.debug(<span class="string">&quot;task &#123;&#125; 加入任务队列&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyCondition.signalAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        <span class="comment">//加锁保证操作过程中的线程安全性</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//判断任务队列是否已满，如果未满则将任务添加到队列即可，如果已满则执行相应的任务拒绝策略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() ==  capacity)&#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task &#123;&#125; 加入任务队列&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyCondition.signalAll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A.ReentrantLock锁保证存储和获取任务队列中的任务元素时的线程安全性，不使用synchronized锁的原因是因为其只有一个条件变量，会有虚假唤醒问题</p>
<p>B.使用emptyCondition和fullCondition两个条件变量来平衡生产者和消费者的工作效率(线程间的通信)，如果生产者效率太高，导致任务队列达到容量上限，则生产者线程切换成阻塞等待状态并且唤醒消费者线程消费任务，消费者同理</p>
<p>C.如何实现带超时时间的存储任务元素和获取任务元素版本</p>
<p><strong>步骤3：自定义线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="comment">//1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">//2.核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取任务的超时时间(超时后仍没有任务获取就结束线程的运行)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.时间单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit unit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.线程集合(集合是非线程安全实现)</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务队列满时的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.线程池分配线程执行指定的任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">        <span class="comment">//6.1线程池分配线程去执行任务时会出现线程安全问题，使用synchronized同步代码块解决</span></span><br><span class="line">        <span class="comment">//6.2线程数是否小于核心数，如果小于则继续创建线程，并将线程添加到线程集合中复用</span></span><br><span class="line">        <span class="comment">//6.3如果线程数大于等于核心数，则暂时没有空闲的线程处理任务，将任务添加到队列中暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size()&lt;coreSize)&#123;</span><br><span class="line">                <span class="comment">//创建线程并启动线程，让线程执行任务</span></span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增worker&#123;&#125;,task&#123;&#125;&quot;</span>,worker,task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//为了提高程序的扩展性，降低代码的侵入性，那么多种策略我们就不能使用if-else来实现了，选择使用策略模式来实现</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//1.死等策略</span></span><br><span class="line">                <span class="comment">//2.超时策略</span></span><br><span class="line">                <span class="comment">//3.让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">//4.让调用者抛出异常</span></span><br><span class="line">                <span class="comment">//5.既然线程池没有空闲线程，那可以让调用者自己的线程自己执行任务</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//问题：为什么不能直接在线程池种中定义并执行拒绝策略的方法，而是需要把方法定义任务队列中？</span></span><br><span class="line">                <span class="comment">// 目前的答案，因为本来就是因为任务队列已满做的拒绝策略，属于任务队列的职责</span></span><br><span class="line">              </span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">int</span> timeOut, TimeUnit unit,<span class="type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeOut = timeOut;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.线程执行任务</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//7.1 task任务对象不为空，执行任务</span></span><br><span class="line">            <span class="comment">//7.2 task任务对象为空，说明该任务执行完毕了，需要继续从任务队列中获取任务执行，直到任务队列没有任务为止(充分压榨线程资源)</span></span><br><span class="line">            <span class="comment">//执行任务并不会出现线程安全问题，以为任务是每个线程独有的，并不是共享资源</span></span><br><span class="line">            <span class="keyword">while</span> (task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>,task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//从任务队列中获取下一个任务继续执行(没有任务时就阻塞等待，直到有任务执行为止)</span></span><br><span class="line"><span class="comment">//                    task = taskQueue.take();</span></span><br><span class="line">                    <span class="comment">//超时版本，没有任务时会阻塞等待一定的时间，超时后不会再继续等待</span></span><br><span class="line">                    task = taskQueue.poll(timeOut,unit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//7.3线程的任务执行完了，从集合中移除该线程(不太理解，为什么不是让线程一直处于线程集合中复用该线程资源呢?)</span></span><br><span class="line">            <span class="comment">//因为线程进入终止状态后，是不可逆的(同一个线程只能启动一次)</span></span><br><span class="line">            <span class="comment">//且该线程已经在不断的执行任务，直到任务队列为空时线程才进入到终止状态，线程资源在每执行一次任务时就是复用了一次，实际上已经复用了很多次了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//移除worker是操作共享资源worker队列，所以需要锁保证线程安全性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A.线程池分配线程去执行任务时会出现线程安全问题，使用synchronized同步代码块解决</p>
<p>B.线程只能启动一次，也就是线程走完他的生命周期后就无法复用了，那这里的线程池是如何复用线程的呢？他是这样设计的：只要任务队列中还有任务，就让线程不断的获取任务并执行任务，直到任务队列中没有任务时才会让线程结束运行，在这个过程中，线程资源在每多执行一次任务时就是复用了一次，实际上已经复用了很多次了</p>
<p>C.任务队列满时的拒绝任务策略设计(策略模式实现)</p>
<p>D.在任务队列空时，线程空闲时，等待获取任务的超时时间控制，超过超时时间仍没有任务消费时，线程结束运行</p>
<p>步骤4：编写测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,<span class="number">10</span>, TimeUnit.MILLISECONDS,<span class="number">1</span>,(queue,task)-&gt;&#123;</span><br><span class="line">            <span class="comment">//1.死等策略</span></span><br><span class="line">            <span class="comment">//queue.put(task);</span></span><br><span class="line">            <span class="comment">//2.超时策略</span></span><br><span class="line">            <span class="comment">//queue.offer(task,1500,TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">//3.让调用者放弃任务执行</span></span><br><span class="line">            <span class="comment">//log.debug(&quot;放弃&#123;&#125;&quot;,task);</span></span><br><span class="line">            <span class="comment">//4.让调用者抛出异常</span></span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;任务执行失败&quot;+task);</span></span><br><span class="line">            <span class="comment">//5.既然线程池没有空闲线程，那可以让调用者自己的线程自己执行任务</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&quot;</span>+j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>美团大佬写的关于自定义线程池的技术文章</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)</a></p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>JDK线程池的类图解构</p>
<p><img src="D:/VscodeProjects/source/_posts/线程池的类图解构.png" alt="线程池的类图解构"></p>
<p>说明：</p>
<ul>
<li>ScheduledThreadPoolExecutor是带调度**(定时器的任务调度)**的线程池</li>
<li>ThreadPoolExecutor是不带调度的线程池</li>
</ul>
<h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<table>
<thead>
<tr>
<th align="center">状态名</th>
<th align="center">高3位</th>
<th align="center">接收新任务</th>
<th align="center">处理阻塞队列任务</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">不会接收新任务，但会处理阻塞队列剩余 任务</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">会中断正在执行的任务，并抛弃阻塞队列 任务</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">任务全执行完毕，活动线程为 0 即将进入 终结</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">终结状态</td>
</tr>
</tbody></table>
<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING(第一位符号位是1，是负数，所以排在最后)</p>
<p><strong>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值，如果用两个变量分别表示线程状态和线程数量，就要进行两次CAS操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>



<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数目 (最多保留的线程数) </li>
<li>maximumPoolSize 最大线程数目 </li>
<li>keepAliveTime 生存时间 - 针对救急线程**(救急线程数 &#x3D; 最大线程数-核心线程数 )**   也可以称为非核心线程数</li>
<li>unit 时间单位 - 针对救急线程 </li>
<li>workQueue 阻塞队列 </li>
<li>threadFactory 线程工厂 - <strong>可以为线程创建时起个好名字，用来区别不同的线程池不同的线程，方便定位线程中的问题</strong> </li>
<li>handler 拒绝策略</li>
</ul>
<h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">subgraph 阻塞队列</span><br><span class="line">size=2</span><br><span class="line">t3(任务3)</span><br><span class="line">t4(任务4)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph 线程池c-2,m=3</span><br><span class="line">ct1(核心线程1)</span><br><span class="line">ct2(核心线程2)</span><br><span class="line">mt1(救急线程1)</span><br><span class="line">ct1 --&gt; t1(任务1)</span><br><span class="line">ct2 --&gt; t2(任务2)</span><br><span class="line">end</span><br><span class="line">t1(任务1)</span><br><span class="line"></span><br><span class="line">style ct1 fill:#ccf,stroke:#f66,stroke-width:2px</span><br><span class="line">style ct2 fill:#ccf,stroke:#f66,stroke-width:2px</span><br><span class="line">style mt1 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p>
</li>
<li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程</p>
</li>
<li><p><strong>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急</strong></p>
</li>
<li><p><strong>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现</p>
<ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务 </li>
<li>DiscardPolicy 放弃本次任务 </li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 </li>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题 </li>
<li>Netty 的实现，是创建一个新线程来执行任务 </li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
<li><p><strong>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/JDK线程池的四种拒绝策略实现.png" alt="JDK线程池的四种拒绝策略实现"></p>
</li>
</ul>
<p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池。</p>
<p><strong>核心的参数只有三个：核心线程数，最大线程数，任务队列</strong></p>
<p>​	<strong>首先你得明确知道的一点是，线程是操作系统非常宝贵的资源，频繁的创建和销毁非常耗费系统的资源，那么就凭这一点就注定了线程数是不可能无限的创建的，一定是要在系统资源合理承担范围内制定要创建的线程数</strong></p>
<p>​	一旦超出这个线程数量，系统有可能会崩溃，或者出现各种各样的异常，所以到达最大线程数时一定是要拒绝任务。当然很多情况几个线程池也没有到达系统所能承担的最大线程数量，但是我们需要指定这个需求所需要的核心线程数以及的最大线程数，尽可能的最合理和最大化利用线程资源</p>
<p>​	核心线程数和最大线程数：一定要根据实际的需求去制定每个线程池真正需要的线程数量是多少而设置核心线程数以及最大线程数</p>
<p>​	任务队列：当任务数超过核心线程数处理的速度时，就需要任务队列暂存任务，等待核心线程数空闲时再处理(排队的过程)</p>
<p>​	</p>
<p>个人对于线程池7个参数的理解问题</p>
<p>1.没有理解<strong>非核心线程数的作用和意义</strong></p>
<p>​		在某些场景下，任务量非常大但是这种场景持续的时间是非常是短暂的，如果超过了饭店所能容纳的客流量，那么饭店会先让客人排队，客人后续其实都是能吃上饭的，只是排队时间久一点，如果排队的客流量也超出了排队的人数上限，也就是饭店知道大概排队多少人，直到晚上关店是可以把这些客流量完全消化掉的，但是一旦排队数量超过上限，那就是不紧急加人手和地方是忙不过来的，这种时候就是救急工人**(非核心线程)**出场的时候了。如果你一开始就聘请救急工人救场，其实是浪费资源了，因为饭店是完全可以消化掉这部分排队的客流量的，你请了工人只是把消化这部分客流量的时间提前了，对于饭店方来说没有任何意义，还徒增了人力成本</p>
<p>B.没有理解<strong>任务队列对线程池的作用和意义</strong><br>      比如在节假日的饭店场景，饭店的座位已经坐满了，那么后续来吃饭的人就只能先排队等待里面的人吃完饭空出座位来，排队的队列就是任务队列了，但当排队的人数也超出饭店人数上限后，这时候就得临时聘请救急工人了。任务队列最大的作用就是缓冲，在客人想吃饭的时候但饭店没有位置的时候充当一个缓冲区，让客人可以专心等待，饭店可以专心服务完店内的客人</p>
<h5 id="线程池通俗的理解"><a href="#线程池通俗的理解" class="headerlink" title="线程池通俗的理解"></a>线程池通俗的理解</h5><p>线程池就是一群工人去干活，没活干得话就先休息，有活分配就去干活。工人的数量是有限的</p>
<p>分配任务的人<br>由主管，上司去分配任务，非线程池中的线程</p>
<p>干活的人<br>线程池中的线程<br>有活干的时候，主管会叫醒那些休息的工人，让他们去工作<br>工作完了后发现暂时没有工作就又回到摸鱼状态</p>
<p>问题：<br>1.工人怎么判断有没有活干？<br>主管有派发任务就有活干，没有派发任务就没有活干<br>2.主管怎么叫醒那些休息的工人<br>本质是线程状态的切换，休息的工人是切换到等待状态，叫醒就是主管调用singall方法叫醒所有工人<br>3.工人怎么回到摸鱼状态的<br>工人完成自己的本职任务后，看看还有没有搁置的任务没有处理，如果有则继续完成任务，如果没有则等待一定时间仍没有任务后，工人线程就切换回等待状态</p>
<p>A.工人群体<br>B.由主管方主动去观察工人群体中还有没有空闲的工人，如果有就分配工人去干活，如果没有则将任务暂时搁置，等待工人空闲再分配(生产者，负责派发任务)<br>C.工人群体(消费者)，负责执行任务</p>
<h4 id="jdk自带的四种常见的线程池"><a href="#jdk自带的四种常见的线程池" class="headerlink" title="jdk自带的四种常见的线程池"></a>jdk自带的四种常见的线程池</h4><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>源码解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部调用了：ThreadPoolExecutor的一个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认工厂以及默认构造线程的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">    Thread.currentThread().getThreadGroup();</span><br><span class="line">    namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">        poolNumber.getAndIncrement() +</span><br><span class="line">        <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认拒绝策略：抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br></pre></td></tr></table></figure>

<p>特点 </p>
<ul>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
<blockquote>
<p><strong>评价</strong> 适用于任务量已知，相对耗时的任务**(相对耗时不太理解)**</p>
</blockquote>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点 </p>
<ul>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，<ul>
<li>意味着全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>
</ul>
<p><strong>实现存储任务和消费任务的同步性，不存在暂存任务的情况，如果没有空闲的线程可以消费任务消息，那我就阻塞等待一个新的线程创建并消费任务消息，生产消息和消费消息是同步的，没有暂存任务的阻塞队列机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;put...&quot;</span>);</span><br><span class="line">                integers.put(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;putted...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;put2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                integers.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;putted2...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        integers.poll();</span><br><span class="line">        log.debug(<span class="string">&quot;take1 ...&quot;</span>);</span><br><span class="line">        integers.poll();</span><br><span class="line">        log.debug(<span class="string">&quot;take2...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">17:51:58.451 [Thread-0] DEBUG com.czq.six.TestSynchronousQueue - put...</span><br><span class="line">17:51:58.451 [Thread-1] DEBUG com.czq.six.TestSynchronousQueue - put2...</span><br><span class="line">17:51:59.453 [main] DEBUG com.czq.six.TestSynchronousQueue - take1 ...</span><br><span class="line">17:51:59.453 [Thread-1] DEBUG com.czq.six.TestSynchronousQueue - putted2...</span><br><span class="line">17:51:59.453 [main] DEBUG com.czq.six.TestSynchronousQueue - take2...</span><br><span class="line">17:51:59.453 [Thread-0] DEBUG com.czq.six.TestSynchronousQueue - putted...</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>评价</strong> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 <strong>适合任务数比较密集，但每个任务执行时间较短的情况</strong></p>
</blockquote>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景： </p>
<p>**希望多个任务排队执行(在多线程的环境下实现任务的串行执行)**。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放</p>
<p><strong>与自己直接创建一个线程执行的区别：</strong></p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作</li>
<li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改**(线程池的安全性可以得到保证)**<ul>
<li>FinalizableDelegatedExecutorService 应用的是<strong>装饰器模式</strong>，在调用构造方法时将ThreadPoolExecutor对象传给了内部的ExecutorService接口。只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法，也不能重新设置线程池的大小</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line"><span class="comment">//会等待最长执行时间的任务执行完毕后才会进行获取结果，因为最长时间的任务都执行完毕了，代表除去因为没有空闲线程执行任务而进入阻塞队列的任务之外，其他任务都执行完毕了</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间，时间超时后，会放弃执行后面的任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<p>测试submit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ExecutorService executorService)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        log.debug(<span class="string">&quot;get &#123;&#125;&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:59:40.981 [pool-1-thread-1] DEBUG com.czq.six.TestSubmit - running</span><br><span class="line">17:59:41.984 [main] DEBUG com.czq.six.TestSubmit - ok</span><br></pre></td></tr></table></figure>

<p>测试invokeAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ExecutorService executorService)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = executorService.invokeAll(Arrays.asList(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会等待最长执行时间的任务执行完毕后才会进行获取结果</span></span><br><span class="line">        <span class="comment">//因为最长时间的任务都执行完毕了，代表除去因为没有空闲线程执行任务而进入阻塞队列的任务之外，其他任务都执行完毕了</span></span><br><span class="line">        futureList.forEach(future-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">                log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>,result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">00</span>:<span class="number">20.351</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] DEBUG com.czq.six.TestSubmit - <span class="number">2</span></span><br><span class="line"><span class="number">18</span>:<span class="number">00</span>:<span class="number">20.351</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] DEBUG com.czq.six.TestSubmit - <span class="number">1</span></span><br><span class="line"><span class="number">18</span>:<span class="number">00</span>:<span class="number">20.560</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] DEBUG com.czq.six.TestSubmit - <span class="number">3</span></span><br><span class="line"><span class="number">18</span>:<span class="number">00</span>:<span class="number">21.359</span> [main] DEBUG com.czq.six.TestSubmit - result:<span class="number">1</span></span><br><span class="line"><span class="number">18</span>:<span class="number">00</span>:<span class="number">21.361</span> [main] DEBUG com.czq.six.TestSubmit - result:<span class="number">2</span></span><br><span class="line"><span class="number">18</span>:<span class="number">00</span>:<span class="number">21.361</span> [main] DEBUG com.czq.six.TestSubmit - result:<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>测试invokeAny</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ExecutorService executorService)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> executorService.invokeAny(Arrays.asList(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:01:21.282 [pool-1-thread-1] DEBUG com.czq.six.TestSubmit - 1</span><br><span class="line">18:01:21.282 [pool-1-thread-2] DEBUG com.czq.six.TestSubmit - 2</span><br><span class="line">18:01:22.285 [pool-1-thread-2] DEBUG com.czq.six.TestSubmit - 3</span><br><span class="line">18:01:22.285 [main] DEBUG com.czq.six.TestSubmit - result:2</span><br></pre></td></tr></table></figure>



<h5 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h5><p><strong>shutdown</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完(包括正在运行的任务以及阻塞队列中的任务)</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shutdownNow</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将阻塞队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 打断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="comment">// 一般task是Callable类型的时候不用此方法，因为futureTask.get方法自带等待功能。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p><strong>测试shutdown、shutdownNow、awaitTermination</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;take 1 finished&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;take 2 finished&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;take 3 finished&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//shutdown并不会阻塞调用者线程</span></span><br><span class="line">        <span class="comment">//executorService.shutdown();</span></span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        List&lt;Runnable&gt; tasks = executorService.shutdownNow();</span><br><span class="line">        log.debug(<span class="string">&quot;blockingQueue tasks &#123;&#125;&quot;</span>,tasks);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>shutdown是优雅的结束线程池，会将线程池中的任务全部执行完毕再结束，而shutdownNow是暴力结束，会立即终止所有正在运行的任务，阻塞队列中的任务也不会被执行，而是直接返回交由调用者处理</strong></p>
<h5 id="工作线程模式之-Worker-Thread"><a href="#工作线程模式之-Worker-Thread" class="headerlink" title="工作线程模式之 Worker Thread"></a><font color='orange'>工作线程模式之 Worker Thread</font></h5><p><strong>定义</strong></p>
<p><strong>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式</strong>，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。</p>
<p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message） </p>
<p><strong>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</strong> </p>
<p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p>
<p><strong>饥饿</strong></p>
<p>固定大小线程池会有饥饿现象。饥饿现象就是没有空闲的线程资源可以执行任务，导致其他依赖该任务的执行结果的线程也陷入阻塞状态，最后导致线程资源无法释放的现象，恶行循环</p>
<p><strong>原因</strong></p>
<p>原因版本1</p>
<p>核心的原因在于线程资源并非单一职责的专门处理某种任务类型，而是可以处理多种任务类型，从而引发了线程资源互相依赖但又不愿意释放手上的线程资源，就会导致越来越多的线程陷入阻塞状态，直到最后没有可用的线程资源(和死锁产生的原因非常类似)</p>
<p>原因版本2</p>
<p>核心原因就是线程资源不是单一职责的专门处理某种任务类型，否则即使任务之间存在依赖关系，但线程资源并不存在依赖关系，执行完相应的任务后就可以正常释放线程资源，即使线程资源不足也可以排队等候线程资源释放再执行，并不会出现线程资源无法释放的现象</p>
<ul>
<li><p>两个工人是同一个线程池中的两个线程 </p>
</li>
<li><p>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 </p>
<ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li>
<li>后厨做菜：做菜就完事了</li>
</ul>
</li>
<li><p>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 </p>
</li>
<li><p>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">cooking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐...  </span><br><span class="line">17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐... </span><br></pre></td></tr></table></figure>

<p><strong>案例解析</strong></p>
<p>饥饿的原因是工人即负责点餐任务又负责做菜任务，而且两个任务之间存在相互依赖关系，一旦所有工人都去处理了点餐任务，那么将发生永久没人工人处理做菜任务的饥饿现象，因为点餐任务依赖于做菜任务，做菜任务没有工人处理，那么点餐工人的任务也一直完成不了，无法释放点餐工人的生产力(点餐工人依赖于做菜工人是因为点餐工人等菜做完后还要上菜)</p>
<p>解决方案</p>
<p>可以增加线程池的大小，不过不是根本的解决方案，还是前面提到的，不同的任务类型，采用不同的线程池**(解除线程资源的相互依赖关系)**，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">cooking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点餐工人线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//做菜工人线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService1.execute(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理点餐&quot;</span>+ j);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            Future&lt;String&gt; future = executorService2.submit(()-&gt;&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>+j);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            executorService1.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">cook</span> <span class="operator">=</span> future.get();</span><br><span class="line">                    log.debug(<span class="string">&quot;上菜 &#123;&#125;...&quot;</span>,cook);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">21:37:13.696 [pool-2-thread-1] DEBUG com.czq.six.TestThreadHunger - 做菜1</span><br><span class="line">21:37:13.696 [pool-1-thread-1] DEBUG com.czq.six.TestThreadHunger - 处理点餐1</span><br><span class="line">21:37:13.698 [pool-2-thread-1] DEBUG com.czq.six.TestThreadHunger - 做菜2</span><br><span class="line">21:37:13.698 [pool-1-thread-1] DEBUG com.czq.six.TestThreadHunger - 处理点餐2</span><br><span class="line">21:37:13.698 [pool-1-thread-1] DEBUG com.czq.six.TestThreadHunger - 上菜 地三鲜...</span><br><span class="line">21:37:13.699 [pool-1-thread-1] DEBUG com.czq.six.TestThreadHunger - 上菜 烤鸡翅...</span><br></pre></td></tr></table></figure>



<p> <strong>创建多少线程池合适</strong></p>
<ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<p><strong>CPU 密集型运算</strong></p>
<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p>
<p> <strong>I&#x2F;O 密集型运算</strong></p>
<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 </p>
<p>经验公式如下 </p>
<p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>
<p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 </p>
<p><code>4 * 100% * 100% / 50% = 8</code> </p>
<p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 </p>
<p><code>4 * 100% * 100% / 10% = 40</code></p>
<p><strong>计算公式的核心是将CPU的等待时间充分利用起来</strong>，比如4核CPU的计算时间是50%，如果是CPU计算时间是100%的话，此时四个线程就足矣让CPU没有空闲等待时间了，但他才50%，也就是四个线程他的利用才百分之50，所以需要使用另外四个线程填充CPU百分之50的空闲等待时间</p>
<h5 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h5><p>在『任务调度线程池』功能加入之前(JDK1.3)，可以使用 java.util.Timer 来实现定时功能<strong>，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的</strong>，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">        timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23:11:00.888 [Timer-0] DEBUG com.czq.six.TestTimer - task 1</span><br><span class="line">23:11:02.902 [Timer-0] DEBUG com.czq.six.TestTimer - task 2</span><br></pre></td></tr></table></figure>

<p>使用 ScheduledExecutorService 改写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ScheduledExecutorService executorService)</span> &#123;</span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            int i = 10/0;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23:11:43.801 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - task 1</span><br><span class="line">23:11:43.801 [pool-1-thread-2] DEBUG com.czq.six.TestTimer - task 2</span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//initDeay参数可以设定初始延长时间，也就是可以指定什么时候开始以一定时间间隔执行任务</span></span><br><span class="line">		<span class="comment">//一定间隔时间重复执行任务，间隔时间取任务执行时间和延时时间的最大值，二者不会累加</span></span><br><span class="line">        executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">23:12:10.449 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 1</span><br><span class="line">23:12:12.456 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 1</span><br><span class="line">23:12:14.472 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 1</span><br><span class="line">23:12:16.483 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 1</span><br><span class="line">23:12:18.487 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 1</span><br></pre></td></tr></table></figure>

<p>scheduleWithFixedDelay 例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initDeay参数可以设定初始延长时间，也就是可以指定什么时候开始以一定时间间隔执行任务</span></span><br><span class="line"><span class="comment">//一定间隔时间重复执行任务，间隔时间取任务执行时间和延时时间的累加值</span></span><br><span class="line">executorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>输出分析：scheduleWithFixedDelay 的间隔时间是 上一个任务执行时间+延时时间，所以下一个任务开始 所 以间隔都是 3s</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">23:13:54.518 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 2</span><br><span class="line">23:13:57.540 [pool-1-thread-1] DEBUG com.czq.six.TestTimer - 2</span><br><span class="line">23:14:00.560 [pool-1-thread-2] DEBUG com.czq.six.TestTimer - 2</span><br><span class="line">23:14:03.570 [pool-1-thread-2] DEBUG com.czq.six.TestTimer - 2</span><br></pre></td></tr></table></figure>

<h5 id="定时任务的应用"><a href="#定时任务的应用" class="headerlink" title=" 定时任务的应用"></a><font color='green'> 定时任务的应用</font></h5><p>如何让每周四 18:00:00 定时执行任务？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 获取本周四 18:00:00.000</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">thursday</span> <span class="operator">=</span> </span><br><span class="line">    now.with(DayOfWeek.THURSDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span></span><br><span class="line"><span class="keyword">if</span>(now.compareTo(thursday) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    thursday = thursday.plusWeeks(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算时间差，即延时执行时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> Duration.between(now, thursday).toMillis();</span><br><span class="line"><span class="comment">// 计算间隔时间，即 1 周的毫秒值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">oneWeek</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<h5 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h5><p>不论是哪个线程池，在线程执行的任务发生异常后既不会抛出，也不会捕获，这时就需要我们做一定的处理。</p>
<p><strong>方法1：主动捉异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21:59:04.558 c.TestTimer [pool-1-thread-1] - task1 </span><br><span class="line">21:59:04.562 c.TestTimer [pool-1-thread-1] - error: </span><br><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line"> at cn.itcast.n8.TestTimer.lambda$main<span class="variable">$0</span>(TestTimer.java:28) </span><br><span class="line"> at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) </span><br><span class="line"> at java.util.concurrent.FutureTask.run(FutureTask.java:266) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:748) </span><br></pre></td></tr></table></figure>



<p><strong>方法2：使用 Future</strong></p>
<p>说明：</p>
<ul>
<li>lambda表达式内要有返回值，编译器才能将其识别为Callable，否则将识别为Runnable，也就不能用FutureTask</li>
<li>方法中如果出异常，<code>futuretask.get</code>会返回这个异常，否者正常返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">21:54:58.208 c.TestTimer [pool-1-thread-1] - task1 </span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: </span><br><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line"> at java.util.concurrent.FutureTask.report(FutureTask.java:122) </span><br><span class="line"> at java.util.concurrent.FutureTask.get(FutureTask.java:192) </span><br><span class="line"> at cn.itcast.n8.TestTimer.main(TestTimer.java:31) </span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero </span><br><span class="line"> at cn.itcast.n8.TestTimer.lambda$main<span class="variable">$0</span>(TestTimer.java:28) </span><br><span class="line"> at java.util.concurrent.FutureTask.run(FutureTask.java:266) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:748) </span><br></pre></td></tr></table></figure>





<h4 id="jdk提供的四种线程池实现总结"><a href="#jdk提供的四种线程池实现总结" class="headerlink" title="jdk提供的四种线程池实现总结"></a><strong>jdk提供的四种线程池实现总结</strong></h4><p>​	无论是那种线程池实现，本质都是调用底层线程池类的7个参数的构造方法，区别只是参数的值不一样，我们只要看核心参数的区别即可，核心参数有三个</p>
<p>​	<strong>核心线程数，最大线程数，任务队列，这三个参数透露出的本质是线程数要控制合理的范围内，任务数也要控制再合理的范围内，前者是因为线程资源宝贵和内存资源宝贵，后者是因为内存资源宝贵</strong></p>
<p>1.FixedThreadPool和SingleThreadExecutor线程池的致命缺陷都是队列是无界的，也就是任务数是无限的，不仅导致没有非核心线程数，最大的问题是任务数堆积太多会导致内存溢出</p>
<p>2.CachedThreadPool和ScheduledThreadPoolExecutor的致命缺陷是最大线程数是Integer.MAX，几乎等同于线程无界，创建了无数了线程资源，线程资源如此宝贵，无休止的创建必然导致系统的崩溃以及内存的溢出</p>
<p><strong>线程池详解的相关链接</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485808&idx=1&sn=1013253533d73450cef673aee13267ab&chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&token=510053261&lang=zh_CN&scene=21#wechat_redirect">新手也能看懂的线程池学习总结 (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147627756">线程池最佳实践！安排！ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。 (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)</a></p>
<h5 id="Tomcat-线程池"><a href="#Tomcat-线程池" class="headerlink" title="Tomcat 线程池"></a>Tomcat 线程池</h5><p>Tomcat 在哪里用到了线程池呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">subgraph Connector-&gt;NIO EndPoint</span><br><span class="line">t1(LimitLatch)</span><br><span class="line">t2(Acceptor)</span><br><span class="line">t3(SocketChannel 1)</span><br><span class="line">t4(SocketChannel 2)</span><br><span class="line">t5(Poller)</span><br><span class="line">subgraph Executor</span><br><span class="line">t7(worker1)</span><br><span class="line">t8(worker2)</span><br><span class="line">end</span><br><span class="line">t1 --&gt; t2</span><br><span class="line">t2 --&gt; t3</span><br><span class="line">t2 --&gt; t4</span><br><span class="line">t3 --有读--&gt; t5</span><br><span class="line">t4 --有读--&gt; t5</span><br><span class="line">t5 --socketProcessor--&gt; t7</span><br><span class="line">t5 --socketProcessor--&gt; t8</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 </li>
<li>Acceptor 只负责【接收新的 socket 连接】 </li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】 </li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理 </li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat线程池充分体现了线程池的分工合作思想，每个线程池都是单一职责的处理某种类型的任务,Acceptor线程池专门用来处理建立连接的任务，Poller线程池专门用来监听通信信道是否有IO事件发生，Executor线程池专门用来处理请求任务，<strong>分工合作的思想有什么好处呢？</strong></p>
<p>目前的答案是可以充分提高每一个岗位的生产效率，从而大大提高单位时间内处理任务的吞吐量，这个答案还有待深入学习探讨和完善</p>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同 </p>
<ul>
<li>如果总线程数达到 maximumPoolSize <ul>
<li>这时不会立刻抛 RejectedExecutionException 异常 </li>
<li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li>
</ul>
</li>
</ul>
<p>源码 tomcat-7.0.42</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    submittedCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.execute(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue)<span class="built_in">super</span>.getQueue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                Thread.interrupted();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            submittedCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> rx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskQueue.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> ( parent.isShutdown() ) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(</span><br><span class="line">        <span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task </span></span><br><span class="line">    is rejected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Connector 配置</p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>acceptorThreadCount </code></td>
<td align="center">1</td>
<td align="center">acceptor 线程数量</td>
</tr>
<tr>
<td align="center"><code>pollerThreadCount</code></td>
<td align="center">1</td>
<td align="center">poller 线程数量</td>
</tr>
<tr>
<td align="center"><code>minSpareThreads</code></td>
<td align="center">10</td>
<td align="center">核心线程数，即 corePoolSize</td>
</tr>
<tr>
<td align="center"><code>maxThreads</code></td>
<td align="center">200</td>
<td align="center">最大线程数，即 maximumPoolSize</td>
</tr>
<tr>
<td align="center"><code>executor</code></td>
<td align="center">-</td>
<td align="center">Executor 名称，用来引用下面的 Executor</td>
</tr>
</tbody></table>
<p>Executor 线程配置</p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>threadPriority</code></td>
<td align="center">5</td>
<td align="center">线程优先级</td>
</tr>
<tr>
<td align="center"><code>deamon</code></td>
<td align="center">true</td>
<td align="center">是否守护线程</td>
</tr>
<tr>
<td align="center"><code>minSpareThreads</code></td>
<td align="center">25</td>
<td align="center">核心线程数，即corePoolSize</td>
</tr>
<tr>
<td align="center"><code>maxThreads</code></td>
<td align="center">200</td>
<td align="center">最大线程数，即 maximumPoolSize</td>
</tr>
<tr>
<td align="center"><code>maxIdleTime</code></td>
<td align="center">60000</td>
<td align="center">线程生存时间，单位是毫秒，默认值即 1 分钟</td>
</tr>
<tr>
<td align="center"><code>maxQueueSize</code></td>
<td align="center">Integer.MAX_VALUE</td>
<td align="center">队列长度</td>
</tr>
<tr>
<td align="center"><code>prestartminSpareThreads</code></td>
<td align="center">false</td>
<td align="center">核心线程是否在服务器启动时启动</td>
</tr>
</tbody></table>
<p><img src="D:/VscodeProjects/source/_posts/Tomcat对JDK线程池扩展后的线程池逻辑.png" alt="Tomcat对JDK线程池扩展后的线程池逻辑"></p>
<p>Tomcat扩展Jdk线程池的点</p>
<p>1.Tomcat将线程池中的线程设置为了守护线程</p>
<p>2.Tomcat统计了实时运行的任务数，是通过任务数和核心线程数的比较来判断下一步的行为，而Jdk线程池是通过线程池中的活跃线程数和核心线程数比较的(存疑，实时运行的任务数和活跃线程数两种不同统计维度有什么差异？)</p>
<p><strong>3.Tomcat线程池在活跃线程数超过核心线程数时，是先选择启用救急线程，直到线程数量达到最大线程数，才会选择将任务加入到阻塞队列中。而Jdk线程池是与之相反的，是先选择将任务加入到阻塞队列中，阻塞队列满了才会启用救急线程</strong></p>
<h4 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算 </p>
<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解 </p>
<p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率 </p>
<p>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<p><strong>核心:</strong></p>
<p>1.Fork&#x2F;Join线程池是分治思想+多线程的综合应用线程池，分治思想负责将任务拆分成n个等价的小任务，每个任务分配一个线程去执行，使得原来任务的串行执行变成了并行执行，可以大大提高任务的执行效率</p>
<ol start="2">
<li></li>
</ol>
<p>但需要注意的是拆分后的任务不能有前后依赖关系，否则即使任务的执行是并行，但任务互相等待彼此的执行结果仍旧是串行，那么总体的执行效率仍旧是串行，目前该线程池的致命缺陷就是要我们程序员手动去拆分成任务，如果任务拆分的不好，那就达不到并行执行任务的效果了</p>
<h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a><font color='blue'>AQS 原理</font></h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架 </p>
<p>特点： </p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 <ul>
<li>getState - 获取 state 状态 </li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException） </p>
<ul>
<li>tryAcquire </li>
<li>tryRelease </li>
<li>tryAcquireShared </li>
<li>tryReleaseShared </li>
<li>isHeldExclusively</li>
</ul>
<p>获取锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">    <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h3><h5 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a><strong>自定义同步器</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquires == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(acquires == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a><strong>自定义锁</strong></h5><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">22:29:28.727 c.TestAqs [t1] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t1] - unlocking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - unlocking... </span><br></pre></td></tr></table></figure>

<p>不可重入测试 </p>
<p>如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h5 id="起源"><a href="#起源" class="headerlink" title="起源"></a><strong>起源</strong></h5><p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不 够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。</p>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h5><p>AQS 要实现的功能目标 </p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li>
<li>获取锁超时机制</li>
<li>通过打断取消机制 </li>
<li>独占机制及共享机制 </li>
<li>条件不满足时的等待机制</li>
</ul>
<p>要实现的性能目标 </p>
<blockquote>
<p>Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.</p>
</blockquote>
<h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a><strong>设计</strong></h5><p> AQS 的基本思想其实很简单 </p>
<p>获取锁的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;</span><br><span class="line">    <span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line">        入队并阻塞</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure>

<p>释放锁的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;</span><br><span class="line">    恢复阻塞的线程(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点 </p>
<ul>
<li>原子维护 state 状态 </li>
<li>阻塞及恢复线程 </li>
<li>维护队列</li>
</ul>
<ol>
<li>state 设计 <ul>
<li>state 使用 volatile 配合 cas 保证其修改时的原子性 </li>
<li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想</li>
</ul>
</li>
</ol>
<ol start="2">
<li>阻塞恢复设计 <ul>
<li>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume  那么 suspend 将感知不到 </li>
<li>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没 问题 </li>
<li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细 </li>
<li>park 线程还可以通过 interrupt 打断</li>
</ul>
</li>
<li>队列设计 <ul>
<li>使用了 FIFO 先入先出队列，并不支持优先级队列 </li>
<li>设计时借鉴了 CLH 队列，它是一种单向无锁队列</li>
</ul>
</li>
</ol>
<p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态 入队伪代码，只需要考虑 tail 赋值的原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 原来的 tail</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 用 cas 在原来 tail 的基础上改为 node</span></span><br><span class="line">&#125; <span class="keyword">while</span>(tail.compareAndSet(prev, node))</span><br></pre></td></tr></table></figure>

<p>出队伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prev 是上一个节点</span></span><br><span class="line"><span class="keyword">while</span>((Node prev=node.prev).state != 唤醒状态) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置头节点</span></span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure>

<p>CLH 好处： </p>
<ul>
<li>无锁，使用自旋</li>
<li>快速，无阻塞</li>
</ul>
<p>AQS 在一些方面改进了 CLH</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 队列中还没有元素 tail 为 null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 head 从 null -&gt; dummy</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 的 prev 设置为原来的 tail</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 将 tail 从原来的 tail 设置为 node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 原来 tail 的 next 设置为 node</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="主要用到-AQS-的并发工具类"><a href="#主要用到-AQS-的并发工具类" class="headerlink" title="主要用到 AQS 的并发工具类"></a>主要用到 AQS 的并发工具类</h5><p><img src="/AQS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7(%E6%A1%86%E6%9E%B6)%E7%B1%BB%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="AQS并发编程工具(D:/VscodeProjects/source/_posts/AQS并发编程工具(框架)类图结构.png)类图结构"></p>
<p><strong>关于AQS并发编程工具(框架)原理可以结合美团技术文章来理解，因为黑马视频中关于AQS的视频缺少了很多，可以不夸张的说Java层面的锁的思想和原理基本上都是依赖于AQS</strong></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html#:~:text=AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A2%AB%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%A9%BA%E9%97%B2%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E5%B0%86%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%89%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B0%86%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%94%81%E5%AE%9A%E7%8A%B6%E6%80%81%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%A2%AB%E5%8D%A0%E7%94%A8%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E4%B8%80%E5%AE%9A%E7%9A%84%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E6%9D%A5%E4%BF%9D%E8%AF%81%E9%94%81%E5%88%86%E9%85%8D%E3%80%82,%E8%BF%99%E4%B8%AA%E6%9C%BA%E5%88%B6%E4%B8%BB%E8%A6%81%E7%94%A8%E7%9A%84%E6%98%AFCLH%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%98%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%B0%86%E6%9A%82%E6%97%B6%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97%E4%B8%AD%E3%80%82">从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队 (meituan.com)</a></p>
<h2 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h2><p><img src="D:/VscodeProjects/source/_posts/ReentrantLock锁类图结构.png" alt="ReentrantLock锁类图结构"></p>
<h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><h5 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h5><p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync 继承自 AQS 没有竞争时</p>
<p><img src="D:/VscodeProjects/source/_posts/Reentrant锁，加锁没有竞争时.png" alt="Reentrant锁，加锁没有竞争时"></p>
<p>第一个竞争出现时</p>
<p><img src="D:/VscodeProjects/source/_posts/ReentrantLock锁，加锁有竞争时.png" alt="ReentrantLock锁，加锁有竞争时"></p>
<p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列 <ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 </li>
<li>Node 的创建是懒惰的 </li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ol>
<p><img src="D:/VscodeProjects/source/_posts/ReentrantLock阻塞队列中的哨兵节点.png" alt="ReentrantLock阻塞队列中的哨兵节点"></p>
<p>当前线程进入 acquireQueued 逻辑 </p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li>
</ol>
<p><img src="D:/VscodeProjects/source/_posts/线程再次尝试重复获取ReentrantLock失败时，node节点的同步状态设为-1.png" alt="线程再次尝试重复获取ReentrantLock失败时，node节点的同步状态设为-1"></p>
<ol>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><img src="D:/VscodeProjects/source/_posts/竞争Reentrant锁资源失败，进入到阻塞队列中并使用park方法阻塞失败线程.png" alt="竞争Reentrant锁资源失败，进入到阻塞队列中并使用park方法阻塞失败线程"></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="D:/VscodeProjects/source/_posts/多个线程竞争ReentrantLock锁失败并进入阻塞队列，修改线程的状态为阻塞状态.png" alt="多个线程竞争ReentrantLock锁失败并进入阻塞队列，修改线程的状态为阻塞状态"></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功 </p>
<ul>
<li>设置 exclusiveOwnerThread 为 null </li>
<li>state &#x3D; 0</li>
</ul>
<p><img src="D:/VscodeProjects/source/_posts/Thread-0释放ReentrantLock锁.png" alt="Thread-0释放ReentrantLock锁"></p>
<p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程 </p>
<p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 </p>
<p>回到 Thread-1 的 acquireQueued 流程</p>
<p><img src="D:/VscodeProjects/source/_posts/无竞争时，Thread-1成功获取到锁资源.png" alt="无竞争时，Thread-1成功获取到锁资源"></p>
<p>如果加锁成功（没有竞争），会设置 </p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1 </li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p>
<p><img src="D:/VscodeProjects/source/_posts/有竞争时,可能是其他线程成功获取到锁资源.png" alt="有竞争时,可能是其他线程成功获取到锁资源"></p>
<p>如果不巧又被 Thread-4 占了先 </p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1 </li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<h5 id="加锁源码"><a href="#加锁源码" class="headerlink" title="加锁源码"></a>加锁源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire </span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//将当前node加入等待队列末尾等待，并返回当前node</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//非公平同步器中有head和tail两个引用分别指向了等待队列的第一个和最后一个节点</span></span><br><span class="line">        <span class="comment">//pred指的是node的前驱，从队尾插入，所以pred为tail</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, 说明已经有了等待队列了，cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将node的前驱节点设置为pred</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//尝试将队列的tial从当前的pred修改为node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pred为null，说明等待队列还未创建，调用enq方法创建队列</span></span><br><span class="line">        <span class="comment">// 尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//该方法就是创建等待队列，并将node插入队列的尾部。</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                    <span class="comment">//将head赋值给tail，head和tail同时指向哨兵节点</span></span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                <span class="comment">//设置node的前驱节点为队列的最后一个节点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//尝试将队列的尾部从当前的tail设置为node</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    <span class="comment">//将node设为上一个tail的后继节点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//在队列中循环等待，只有当排队排到第一名并且获得了锁才能出队并从方法中退出。</span></span><br><span class="line">    <span class="comment">//返回打断状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//找到当前node的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//判断acquire失败以后是否应该阻塞等待。从规则上来讲：</span></span><br><span class="line">    <span class="comment">//1.如果前驱节点都阻塞了，那么当前节点也应该阻塞</span></span><br><span class="line">    <span class="comment">//2.如果前驱节点取消，那么应该将前驱节点前移，直到其状态不为取消为止。</span></span><br><span class="line">    <span class="comment">//3.如果前两种情况都不是，尝试将前驱节点状态设为SIGNAL，返回false（不用阻塞，等到下次在阻塞）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<p>是否需要 unpark 是由当前节点的前驱节点的 waitStatus &#x3D;&#x3D; Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定</p>
</blockquote>
<p>总结：</p>
<ul>
<li>调用<code>lock</code>，尝试将state从0修改为1<ul>
<li>成功：将owner设为当前线程</li>
<li>失败：调用<code>acquire</code>-&gt;<code>tryAcquire</code>-&gt;<code>nonfairTryAcquire</code>，判断state&#x3D;0则获得锁，或者state不为0但当前线程持有锁则重入锁，以上两种情况<code>tryAcquire</code>返回true，剩余情况返回false。<ul>
<li>true：获得锁</li>
<li>false：调用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>,其中<code>addwiter</code>将关联线程的节点插入AQS队列尾部，进入<code>acquireQueued</code>中的for循环:<ul>
<li>如果当前节点是头节点，并尝试获得锁成功，将当前节点设为头节点，清除此节点信息，返回打断标记。</li>
<li>调用<code>shoudParkAfterFailure</code>,第一次调用返回false，并将前驱节点改为-1，第二次循环如果再进入此方法，会进入阻塞并检查打断的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>加锁的核心过程：如果成功获取到锁则设置当前线程为锁的持有者，否则将当前线程加入到阻塞队列中并调用unpark方法阻塞当前线程</strong></p>
<h5 id="解锁源码"><a href="#解锁源码" class="headerlink" title="解锁源码"></a>解锁源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 队列不为 null</span></span><br><span class="line">                h != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">                h.waitStatus != <span class="number">0</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0</span></span><br><span class="line">        <span class="comment">// 不成功也可以</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>unlock</code>-&gt;<code>syn.release</code>(1)-&gt;<code>tryRelease</code>(1),如果当前线程并不持有锁，抛异常。state减去1,如果之后state为0，解锁成功，返回true；如果仍大于0，表示解锁不完全，当前线程依旧持有锁，返回false。</li>
<li>返回true：检查AQS队列第一个节点状态图是否为<code>SIGNAL</code>(意味着有责任唤醒其后记节点)，如果有，调用<code>unparkSuccessor</code>。<ul>
<li>再<code>unparkSuccessor</code>中，不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点，如果有，将其唤醒。</li>
</ul>
</li>
<li>返回false：</li>
</ul>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>当持有锁的线程再次尝试获取锁时，会将state的值加1，state表示锁的重入量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state-- </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p><strong>不可打断模式</strong></p>
<p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，并将打断信号存储在一个interrupt变量中。一直要等到获得锁后方能得知自己被打断了,并且调用<code>selfInterrupt</code>方法打断自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//响应打断标记，打断自己</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可打断模式</strong></p>
<p>此模式下即使线程在等待队列中等待，一旦被打断，就会立刻抛出打断异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p>简而言之，公平与非公平的区别在于，公平锁中的tryAcquire方法被重写了，新来的线程即便得知了锁的state为0，也要先判断等待队列中是否还有线程等待，只有当队列没有线程等待式，才获得锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//存疑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            (</span><br><span class="line">            <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">            s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁</strong>。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。<strong>所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁</strong></p>
<h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<h4 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h4><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 </p>
<p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><img src="D:/VscodeProjects/source/_posts/条件变量等待队列conditionObject.png" alt="条件变量等待队列conditionObject"></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><img src="D:/VscodeProjects/source/_posts/占有锁资源的线程释放锁并唤醒阻塞队列中的线程.png" alt="占有锁资源的线程释放锁并唤醒阻塞队列中的线程"></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="D:/VscodeProjects/source/_posts/占有锁资源的线程释放锁后，如果没有其他线程竞争，那么则是head节点的后一个节点关联的线程成功竞争到锁资源.png" alt="占有锁资源的线程释放锁后，如果没有其他线程竞争，那么则是head节点的后一个节点关联的线程成功竞争到锁资源"></p>
<p>park 阻塞 Thread-0</p>
<p><img src="D:/VscodeProjects/source/_posts/将释放锁的线程状态通过unpark切换为阻塞态.png" alt="将释放锁的线程状态通过unpark切换为阻塞态"></p>
<p>总结：</p>
<ul>
<li>创建一个节点，关联当前线程，并插入到当前Condition队列的尾部</li>
<li>调用<code>fullRelease</code>，完全释放同步器中的锁，并记录当前线程的锁重入数</li>
<li>唤醒(park)AQS队列中的第一个线程</li>
<li>调用park方法，阻塞当前线程。</li>
</ul>
<p><strong>线程切换到等待状态的核心过程是将关联线程的节点加入到等待队列中，释放手中的锁资源并唤醒阻塞队列中的第一个线程，最后再阻塞当前线程</strong></p>
<h4 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h4><p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="D:/VscodeProjects/source/_posts/唤醒等待队列中的线程signal流程一.png" alt="唤醒等待队列中的线程signal流程一"></p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="D:/VscodeProjects/source/_posts/唤醒等待队列中的线程signal流程二.png" alt="唤醒等待队列中的线程signal流程二"></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p>
<p><img src="D:/VscodeProjects/source/_posts/唤醒等待队列中的线程signal流程三.png" alt="唤醒等待队列中的线程signal流程三"></p>
<p>Thread-1 释放锁，进入 unlock 流程，略</p>
<p>总结：</p>
<ul>
<li>当前持有锁的线程唤醒等待队列中的线程，调用doSignal或doSignalAll方法，将等待队列中的第一个（或全部）节点插入到AQS队列中的尾部。</li>
<li>将插入的节点的状态从Condition设置为0，将插入节点的前一个节点的状态设置为-1（意味着要承担唤醒后一个节点的责任）</li>
<li>当前线程释放锁，parkAQS队列中的第一个节点线程。</li>
</ul>
<p><strong>唤醒的核心过程就是将等待队列的节点全部唤醒(等待队列置为空)，再将节点一一加入到阻塞队列中</strong></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ㈠ 添加一个 Node 至等待队列</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">            !transferForSignal(first) &amp;&amp;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            (first = firstWaiter) != <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 上一个节点被取消</span></span><br><span class="line">            ws &gt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">            !compareAndSetWaitStatus(p, ws, Node.SIGNAL) </span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ㈤ 应用打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向Condition中的等待队列中新增节点，并将此节点返回</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前节点是否在同步器中的队列中等待锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">         * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">         * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">         * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">         * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">         * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具方法 省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>可以并发，提高性能。 类似于数据库中的<code>select ... from ... lock in share mode</code> </p>
<p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试<code>读锁-读锁</code>可以并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:05:14.341 c.DataContainer [t2] - 获取读锁... </span><br><span class="line">14:05:14.341 c.DataContainer [t1] - 获取读锁... </span><br><span class="line">14:05:14.345 c.DataContainer [t1] - 读取</span><br><span class="line">14:05:14.345 c.DataContainer [t2] - 读取</span><br><span class="line">14:05:15.365 c.DataContainer [t2] - 释放读锁... </span><br><span class="line">14:05:15.386 c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure>

<p>测试<code>读锁-写锁</code>相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.838</span> c.DataContainer [t1] - 获取读锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.838</span> c.DataContainer [t2] - 获取写锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.841</span> c.DataContainer [t2] - 写入</span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">22.843</span> c.DataContainer [t2] - 释放写锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">22.843</span> c.DataContainer [t1] - 读取</span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">23.843</span> c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure>

<p><code>写锁-写锁</code>也是相互阻塞的，这里就不测试了</p>
<p><strong>注意事项</strong> </p>
<ul>
<li>读锁不支持条件变量 </li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                        cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a><font color='green'>应用之缓存</font></h3><h5 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h5><p>更新时，是先清缓存还是先更新数据库 </p>
<p><strong>先清缓存</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/缓存更新策略之先清缓存.png" alt="缓存更新策略之先清缓存"></p>
<p><strong>先更新数据库</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/缓存更新策略之先更新数据库再清缓存.png" alt="缓存更新策略之先更新数据库再清缓存"></p>
<p>补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p>
<p><img src="D:/VscodeProjects/source/_posts/缓存更新策略之先更新数据库再清缓存的极端情况.png" alt="缓存更新策略之先更新数据库再清缓存的极端情况"></p>
<p>这种情况的出现几率非常小，见 facebook 论文</p>
<p><strong>总结</strong></p>
<p><strong>无论是那种缓存更新策略，都存在一定的问题，因为问题产生的原因是读写并发造成二者的指令交叉执行，要想真正保障缓存和持久层数据库的强一致性，只能通过加锁来实现</strong>，当然如果业务场景只要求弱一致性可以选择第二种更新策略</p>
<h5 id="读写锁实现一致性缓存"><a href="#读写锁实现一致性缓存" class="headerlink" title="读写锁实现一致性缓存"></a>读写锁实现一致性缓存</h5><p>使用读写锁实现一个简单的按需加载缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericCachedDao</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// HashMap 作为缓存非线程安全, 需要保护</span></span><br><span class="line">    HashMap&lt;SqlPair, T&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(); </span><br><span class="line">    <span class="type">GenericDao</span> <span class="variable">genericDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericDao</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... params)</span> &#123;</span><br><span class="line">        <span class="type">SqlPair</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlPair</span>(sql, params);</span><br><span class="line">        <span class="comment">// 加写锁, 防止其它线程对缓存读取和更改</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> genericDao.update(sql, params);</span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="keyword">return</span> rows;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">queryOne</span><span class="params">(Class&lt;T&gt; beanClass, String sql, Object... params)</span> &#123;</span><br><span class="line">        <span class="type">SqlPair</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlPair</span>(sql, params);</span><br><span class="line">        <span class="comment">// 加读锁, 防止其它线程对缓存更改</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加写锁, 防止其它线程对缓存读取和更改</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span></span><br><span class="line">            <span class="comment">// 为防止重复查询数据库, 再次验证</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有, 查询数据库</span></span><br><span class="line">                value = genericDao.queryOne(beanClass, sql, params);</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 作为 key 保证其是不可变的</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SqlPair</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String sql;</span><br><span class="line">        <span class="keyword">private</span> Object[] params;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SqlPair</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sql = sql;</span><br><span class="line">            <span class="built_in">this</span>.params = params;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">SqlPair</span> <span class="variable">sqlPair</span> <span class="operator">=</span> (SqlPair) o;</span><br><span class="line">            <span class="keyword">return</span> sql.equals(sqlPair.sql) &amp;&amp;</span><br><span class="line">                Arrays.equals(params, sqlPair.params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Objects.hash(sql);</span><br><span class="line">            result = <span class="number">31</span> * result + Arrays.hashCode(params);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<ul>
<li><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑 </p>
<ul>
<li><p>适合读多写少，如果写操作比较频繁，以上实现性能低 </p>
</li>
<li><p>没有考虑缓存容量(缓存数据淘汰策略)</p>
</li>
<li><p>没有考虑缓存过期 (缓存数据过期策略)</p>
</li>
<li><p>只适合单机 </p>
</li>
<li><p><strong>并发性还是低，目前只会用一把锁(这把锁的粒度太粗了，锁住了所有表的写操作，能不能一个表一个锁，降低锁的粒度，提高线程的并发性)</strong></p>
</li>
<li><p>更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）</p>
</li>
</ul>
</li>
<li><p>乐观锁实现：用 CAS 去更新</p>
</li>
</ul>
</blockquote>
<h3 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a><font color='blue'>读写锁原理</font></h3><h4 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h4><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p>
<p><strong>t1 w.lock，t2 r.lock</strong></p>
<p>1） t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，<strong>不同是写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位</strong></p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图1.png" alt="读写锁原理图1"></p>
<p>2）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败</p>
<blockquote>
<p>tryAcquireShared 返回值表示 </p>
<ul>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节点不会继续唤醒 </li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li>
</ul>
</blockquote>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图2.png" alt="读写锁原理图2"></p>
<p>3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图3.png" alt="读写锁原理图3"></p>
<p>4）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁 </p>
<p>5）如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图4.png" alt="读写锁原理图4"></p>
<p><strong>t3 r.lock，t4 w.lock</strong> </p>
<p>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图5.png" alt="读写锁原理图5"></p>
<p><strong>t1 w.unlock</strong> </p>
<p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图6.png" alt="读写锁原理图6"></p>
<p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行 </p>
<p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图7.png" alt="读写锁原理图7"></p>
<p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图8.png" alt="读写锁原理图8"></p>
<p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图9.png" alt="读写锁原理图9"></p>
<p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图10.png" alt="读写锁原理图10"></p>
<p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图11.png" alt="读写锁原理图11"></p>
<p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p>
<p><strong>t2 r.unlock，t3 r.unlock</strong></p>
<p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图12.png" alt="读写锁原理图12"></p>
<p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图13.png" alt="读写锁原理图13"></p>
<p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p>
<p><img src="D:/VscodeProjects/source/_posts/读写锁原理图14.png" alt="读写锁原理图14"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="写锁上锁流程"><a href="#写锁上锁流程" class="headerlink" title="写锁上锁流程"></a><strong>写锁上锁流程</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">            <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">		<span class="comment">//表示有写锁或者有读锁</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁, 或者</span></span><br><span class="line">                w == <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞, 或者</span></span><br><span class="line">            <span class="comment">//非公平锁下，总是返回false</span></span><br><span class="line">            writerShouldBlock() ||</span><br><span class="line">            <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">            !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>lock</code> -&gt; <code>syn.acquire</code>  -&gt;<code>tryAquire</code><ul>
<li>如果有锁：<ul>
<li>如果是写锁或者锁持有者不为自己，返回false</li>
<li>如果时写锁且为自己持有，则重入</li>
</ul>
</li>
<li>如果无锁：<ul>
<li>判断无序阻塞并设置state成功后，将owner设为自己，返回true</li>
</ul>
</li>
</ul>
</li>
<li>成功，则获得了锁</li>
<li>失败：<ul>
<li>调用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>进入阻塞队列，将节点状态设置为EXCLUSIVE，之后的逻辑与之前的aquireQueued类似。</li>
</ul>
</li>
</ul>
<h5 id="写锁释放流程"><a href="#写锁释放流程" class="headerlink" title="写锁释放流程"></a><strong>写锁释放流程</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free) &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p><code>unlock</code>-&gt;<code>syn.release</code>-&gt;<code>tryRelease</code></p>
<ul>
<li>state状态减少<ul>
<li>如果减为零，表示解锁成功，返回true</li>
<li>没有减为0，当前线程依旧持有锁</li>
</ul>
</li>
</ul>
</li>
<li><p>成功：解锁成功</p>
<ul>
<li>如果ASQ队列不为空，则唤醒第一个节点。</li>
</ul>
</li>
<li><p>失败：解锁失败。</p>
</li>
</ul>
<h5 id="读锁上锁流程"><a href="#读锁上锁流程" class="headerlink" title="读锁上锁流程"></a><strong>读锁上锁流程</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">        <span class="comment">//大于0的情况在读写锁这里无区别，后面信号量会做进一步处理。</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> ( </span><br><span class="line">            exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">            !readerShouldBlock() &amp;&amp;</span><br><span class="line">            <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line">    <span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ㈠</span></span><br><span class="line">                        <span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                        <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 当前线程</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置自己为 head</span></span><br><span class="line">        setHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">        <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared()) &#123;</span><br><span class="line">                <span class="comment">// 进入 ㈡</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                    <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>lock</code>-&gt;<code>syn.acquireShare</code>-&gt;<code>tryAcquireShare</code><ul>
<li>如果其他线程持有写锁：则失败，返回-1</li>
<li>否则：判断无需等待后，将state加上一个写锁的单位，返回1</li>
</ul>
</li>
<li>返回值大于等于0：成功</li>
<li>返回值小于0：<ul>
<li>调用doAcquireShare，类似之前的aquireQueued,将当前线程关联节点，状态设置为SHARE，插入AQS队列尾部。在for循环中判断当前节点的前驱节点是否为头节点<ul>
<li>是：调用<code>tryAcquireShare</code><ul>
<li><strong>如果返回值大于等于0，则获取锁成功，并调用<code>setHeadAndPropagate</code>，出队，并不断唤醒AQS队列中的状态为SHARE的节点，直到下一个节点为EXCLUSIVE。</strong>记录打断标记，之后退出方法（不返回打断标记）</li>
</ul>
</li>
</ul>
</li>
<li>判断是否在失败后阻塞<ul>
<li>是：阻塞住，并监测打断信号。</li>
<li>否则：将前驱节点状态设为-1。（下一次循环就又要阻塞了）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="读锁释放流程"><a href="#读锁释放流程" class="headerlink" title="读锁释放流程"></a><strong>读锁释放流程</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>unlock</code>-&gt;<code>releaseShared</code>-&gt;<code>tryReleaseShared</code>,将state减去一个share单元，最后state为0则返回true，不然返回false。</li>
<li>返回tue：调用<code>doReleaseShare</code>,唤醒队列中的节点。</li>
<li>返回false：解锁不完全。</li>
</ul>
<p><strong>细节：</strong></p>
<p>1.<strong>无论是ReentrantLock还是读写锁ReentrantReadWriteLock，他们都是悲观锁，都是在操作共享资源前要先加锁，保证操作的数据不会被其他线程修改</strong></p>
<p>2**.CAS算法只是保证比较并交换这两个操作是原子性的，并不能用有无CAS操作来辨别解决线程安全问题究竟是使用无锁实现还是有锁实现**，比如利用CAS的思想实现乐观锁(无锁实现)和ReentrantLock是利用CAS算法修改共享资源state状态来进行加锁和解锁(有锁实现)。AQS中大量的操作共享资源的操作都是用了CAS算法保证操作的原子性，但里面大多数是有锁实现</p>
<p>核心总结：</p>
<p>1**.ReentrantLock锁底层是AQS原理实现的，他是在Java层面实现的重量级锁，和C++层面实现的监听器Monitor锁(synchronized)的设计思想非常类似，在学习ReentrantLock的设计思想和源码时，二者可以类比学习**，只是ReentrantLock锁实现的更灵活更丰富</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html#:~:text=AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A2%AB%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%A9%BA%E9%97%B2%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E5%B0%86%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%89%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B0%86%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%94%81%E5%AE%9A%E7%8A%B6%E6%80%81%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%A2%AB%E5%8D%A0%E7%94%A8%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E4%B8%80%E5%AE%9A%E7%9A%84%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E6%9D%A5%E4%BF%9D%E8%AF%81%E9%94%81%E5%88%86%E9%85%8D%E3%80%82,%E8%BF%99%E4%B8%AA%E6%9C%BA%E5%88%B6%E4%B8%BB%E8%A6%81%E7%94%A8%E7%9A%84%E6%98%AFCLH%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%98%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%B0%86%E6%9A%82%E6%97%B6%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97%E4%B8%AD%E3%80%82">从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队 (meituan.com)</a></p>
<p>2**.在阅读ReentrantLock锁原理笔记时最好是结合流程图+流程解析+源码的方式去学习和理解，这样会更清晰，黑马的笔记缺乏流程图，但有流程解析和源码，我们可以结合美团大佬的技术博客去更好的学习这部分内容**</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html#:~:text=AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A2%AB%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%A9%BA%E9%97%B2%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E5%B0%86%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%89%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B0%86%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%94%81%E5%AE%9A%E7%8A%B6%E6%80%81%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%A2%AB%E5%8D%A0%E7%94%A8%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E4%B8%80%E5%AE%9A%E7%9A%84%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E6%9D%A5%E4%BF%9D%E8%AF%81%E9%94%81%E5%88%86%E9%85%8D%E3%80%82,%E8%BF%99%E4%B8%AA%E6%9C%BA%E5%88%B6%E4%B8%BB%E8%A6%81%E7%94%A8%E7%9A%84%E6%98%AFCLH%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%98%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%B0%86%E6%9A%82%E6%97%B6%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97%E4%B8%AD%E3%80%82">从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队 (meituan.com)</a></p>
<p>3.<strong>读写锁ReentrantReadWrite中的写锁和ReentrantLock实现的原理基本一致，有区别的是读锁的实现，在阅读源码时要重点去区分和理解读锁(共享锁)加锁和释放锁的原理，同样阅读读写锁源码时最好结合流程图+流程图解析+源码解析的方式去学习，这样会更好的理解，下面是腾讯大佬的技术博客(有流程图)</strong></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1469555">读写锁——ReentrantReadWriteLock原理详解 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>4.美团技术团队关于Java锁的深度的解析，可以借此更深入学习和理解Java锁的相关知识</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">【基本功】不可不说的Java“锁”事 (qq.com)</a></p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用 加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="comment">//获取戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="comment">//读取数据之后再验戳</span></span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果验戳失败，说明已经数据已经被修改，需要升级锁重新读。</span></span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试<code>读-读</code>可以优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，可以看到实际没有加读锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15:58:50.217 c.DataContainerStamped [t1] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - <span class="built_in">read</span> finish...256, data:1 </span><br><span class="line">15:58:51.220 c.DataContainerStamped [t1] - <span class="built_in">read</span> finish...256, data:1 </span><br></pre></td></tr></table></figure>

<p>测试<code>读-写</code>时优化读补加读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.write(<span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:57:00.219 c.DataContainerStamped [t1] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:57:00.717 c.DataContainerStamped [t2] - write lock 384 </span><br><span class="line">15:57:01.225 c.DataContainerStamped [t1] - updating to <span class="built_in">read</span> lock... 256 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> lock 513 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> finish...513, data:1000 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> unlock 513 </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<ul>
<li>StampedLock 不支持条件变量 </li>
<li>StampedLock 不支持可重入</li>
</ul>
</blockquote>
<p><strong>核心思想</strong></p>
<p>StampedLock优化读写锁中读锁的核心思想是将原来读写锁中的读锁从悲观锁变成乐观锁，因为读写锁加锁的原理是CAS操作修改state同步资源字段，每次加锁都要执行CAS操作修改state字段，非常耗费资源，所以优化的思路就是乐观锁思路，先不加锁(自然就不用执行CAS操作了)，等到出现其他线程修改共享数据时再升级为读锁(再加锁)</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3. 获取许可</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            <span class="comment">//对于非打断式获取，如果此过程中被打断，线程依旧会等到获取了信号量之后才进入catch块。</span></span><br><span class="line">            <span class="comment">//catch块中的线程依旧持有信号量，捕获该异常后catch块可以不做任何处理。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">07:35:15.485 c.TestSemaphore [Thread-2] - running... </span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-1] - running... </span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-0] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-2] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-0] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-1] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-3] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-5] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-4] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-5] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-4] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-3] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-6] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-7] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-9] - running... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-6] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-7] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-9] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-8] - running... </span><br><span class="line">07:35:19.492 c.TestSemaphore [Thread-8] - end... </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>Semaphore有两个构造器：<code>Semaphore(int permits)</code>和<code>Semaphore(int permits,boolean fair)</code></li>
<li>permits表示允许同时访问共享资源的线程数。</li>
<li>fair表示公平与否，与之前的ReentrantLock一样。</li>
<li>线程不是有序打印正是非公平锁的体现</li>
</ul>
<h3 id="Semaphore-应用"><a href="#Semaphore-应用" class="headerlink" title="Semaphore 应用"></a><font color='green'>Semaphore 应用</font></h3><p>semaphore 限制对共享资源的使用 </p>
<ul>
<li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，**当然它只适合限制单机 线程数量，并且仅是限制线程数，而不是限制资源数(线程数和资源数的差异？)**（例如连接数，请对比 Tomcat LimitLatch 的实现） </li>
<li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好， 注意下面的实现中线程数和数据库连接数是相等的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="comment">// 让许可数与资源数一致</span></span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(poolSize);</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;<span class="comment">// t1, t2, t3</span></span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 没有许可的线程，在此等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取空闲连接</span></span><br><span class="line">            <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                    <span class="keyword">return</span> connections[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Semaphore-原理"><a href="#Semaphore-原理" class="headerlink" title="Semaphore 原理"></a><font color='blue'>Semaphore 原理</font></h3><h4 id="加锁解锁流程-1"><a href="#加锁解锁流程-1" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><p>Semaphore有点像一个停车场，permits就好像停车位数量，当线程获得了permits就像是获得了停车位，然后停车场显示空余车位减一。 </p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">        <span class="comment">// permits 即 state</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获得共享锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires; </span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span></span><br><span class="line">                remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span></span><br><span class="line">                compareAndSetState(available, remaining)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再次尝试获取许可</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span></span><br><span class="line">                        <span class="comment">// r 表示可用资源数, 为 0 则不会继续传播</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置自己为 head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">    <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared()) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加锁流程总结："><a href="#加锁流程总结：" class="headerlink" title="加锁流程总结："></a>加锁流程总结：</h5><ul>
<li><code>acquire</code>-&gt;<code>acquireSharedInterruptibly(1)</code>-&gt;<code>tryAcquireShared(1)</code>-&gt;<code>nonfairTryAcquireShared(1)</code>,如果资源用完了，返回负数，<code>tryAcquireShared</code>返回负数，表示失败。否则返回正数，<code>tryAcquireShared</code>返回正数,表示成功。<ul>
<li>如果成功，获取信号量成功。</li>
<li>如果失败，调用<code>doAcquireSharedInterruptibly</code>,进入for循环：<ul>
<li>如果当前驱节点为头节点，调用<code>tryAcquireShared</code>尝试获取锁<ul>
<li>如果结果大于等于0，表明获取锁成功，调用<code>setHeadAndPropagate</code>，将当前节点设为头节点，之后又调用<code>doReleaseShared</code>，唤醒后继节点。</li>
</ul>
</li>
<li>调用<code>shoudParkAfterFailure</code>,第一次调用返回false，并将前驱节点改为-1，第二次循环如果再进入此方法，会进入阻塞并检查打断的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="解锁流程总结："><a href="#解锁流程总结：" class="headerlink" title="解锁流程总结："></a>解锁流程总结：</h5><ul>
<li><code>release</code>-&gt;<code>sync.releaseShared(1)</code>-&gt;<code>tryReleaseShared(1)</code>,只要不发生整数溢出，就返回true<ul>
<li>如果返回true，调用<code>doReleaseShared</code>，唤醒后继节点。</li>
<li>如果返回false，解锁失败。</li>
</ul>
</li>
</ul>
<p><strong>Semaphore的原理和读写锁中的读锁(共享锁)原理基本一致，只是共享锁是不限制共享的线程个数，而Semaphore锁是限制共享线程的个数，如果想更细致的研究源码可以直接去阅读读写锁中读锁的源码</strong></p>
<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p><strong>用来进行线程同步协作，等待所有线程完成倒计时，和join,wait作用类似，但是CountdownLatch是上层api，应用起来更简单和更方便</strong></p>
<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    latch.await();</span><br><span class="line">    log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:44:00.778 c.TestCountDownLatch [main] - waiting... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... </span><br><span class="line">18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 </span><br><span class="line">18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [main] - <span class="built_in">wait</span> end... </span><br></pre></td></tr></table></figure>



<p><strong>相比于join，CountDownLatch能配合线程池使用</strong>，因为线程池中的核心线程是不会主动停止运行的，而join方法是要等待目的线程停止运行才会唤醒当前线程的，所以不能配合线程池使用，如果使用wait虽然也可以实现，但是wait实现起来较为复杂，不建议使用底层api自己实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用之同步等待多线程准备完毕"><a href="#应用之同步等待多线程准备完毕" class="headerlink" title="应用之同步等待多线程准备完毕"></a><font color='green'>应用之同步等待多线程准备完毕</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>, (r) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;t&quot;</span> + num.getAndIncrement());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">String[] all = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> j;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//随机休眠，模拟网络延迟</span></span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            all[x] = Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + (i + <span class="string">&quot;%&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="comment">//\r可以让当前输出覆盖上一次的输出。</span></span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;\n游戏开始...&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<p>中间输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[t0(52%), t1(47%), t2(51%), t3(40%), t4(49%), t5(44%), t6(49%), t7(52%), t8(46%), t9(46%)] </span><br></pre></td></tr></table></figure>

<p>最后输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), </span><br><span class="line">t9(100%)] </span><br><span class="line">游戏开始... </span><br></pre></td></tr></table></figure>



<h3 id="应用之同步等待多个远程调用结束"><a href="#应用之同步等待多个远程调用结束" class="headerlink" title="应用之同步等待多个远程调用结束"></a><font color='green'>应用之同步等待多个远程调用结束</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCountDownlatchController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">order</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        map.put(<span class="string">&quot;total&quot;</span>, <span class="string">&quot;2300.00&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">product</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小爱音箱&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;price&quot;</span>, <span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小米手机&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;price&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/logistics/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">logistics</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;中通快递&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2500</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rest远程调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">4</span>);</span><br><span class="line">Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/order/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(f1.get());</span><br><span class="line">System.out.println(f2.get());</span><br><span class="line">System.out.println(f3.get());</span><br><span class="line">System.out.println(f4.get());</span><br><span class="line">log.debug(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:51:39.711 c.TestCountDownLatch [main] - begin </span><br><span class="line">&#123;total=2300.00, <span class="built_in">id</span>=1&#125; </span><br><span class="line">&#123;price=300, name=小爱音箱, <span class="built_in">id</span>=1&#125; </span><br><span class="line">&#123;price=2000, name=小米手机, <span class="built_in">id</span>=2&#125; </span><br><span class="line">&#123;name=中通快递, <span class="built_in">id</span>=1&#125; </span><br><span class="line">19:51:42.407 c.TestCountDownLatch [main] - 执行完毕</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><strong>这种等待多个带有返回值的任务的场景，还是用future比较合适，CountdownLatch适合任务没有返回值的场景。</strong></li>
<li>CountdownLatch有两个缺点，一是不能得到线程的执行结果(Future可以改进)，而是不能重用(CyclicBarrier可以实现)</li>
</ul>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CountdownLatch的缺点在于不能重用，见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task1 start...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task2 start...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 task2 finish...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要重复使用CountdownLatch进行同步，必须创建多个CountDownLatch对象。</p>
<p>[ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 当个数不足时，等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 2 秒后，线程个数够2，继续运行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<ul>
<li>CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比 喻为『人满发车』</li>
<li>CountDownLatch的计数和阻塞方法是分开的两个方法，而CyclicBarrier是一个方法。</li>
<li>CyclicBarrier的构造器还有一个Runnable类型的参数，在计数为0时会执行其中的run方法。</li>
</ul>
</blockquote>
<p><strong>以上的同步器组件都有其对应的应用场景，底层的原理都是基于AQS，在AQS的基础上根据自己应用场景进行拓展的，以下简单罗列以下这些同步器组件的应用场景</strong></p>
<p>1.ReentrantLock，属于重量级锁，想要使用重量级锁保障操作的原子性话的可以使用</p>
<p>2.ReentrantReadWriteLock读写锁，同样属于重量级锁，只是将读写分离了，提高读读并发的性能，适用于读多写少的场景</p>
<p>3.StampedLock，属于读写锁特定场景的优化版，优化了读写锁中的读锁，将读写锁中的读锁从悲观锁改为了乐观锁(无锁实现)实现，进一步提高读读并发的性能，同样适用于读多写少的场景</p>
<p>4.Semaphore，类似读写锁中读锁(共享锁)，但其限制共享资源的访问数量，也就是不能像读锁一样没有限制的共享，原理是通过同步资源state模拟信号量的机制限制共享资源的访问线程数，可用于高峰期限制共享资源的访问线程数(具体的实践应用场景还有待学习和探索)</p>
<p>5.CountdownLatch，属于为线程通信机制而生的同步器组件，作用和join,wait基本一致，但CountdownLatch属于上层api，使用起来更简单更友好</p>
<p>6.CyclicBarrier，同样是为线程通信机制而生的同步器组件，改进了CountdownLatch不可复用的缺点</p>
<h2 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h2><p><img src="D:/VscodeProjects/source/_posts/线程安全集合概述.png" alt="线程安全集合概述"></p>
<p>线程安全集合类可以分为三大类： </p>
<ul>
<li>遗留的线程安全集合如<code>Hashtable</code>，<code>Vector</code></li>
<li>使用<code>Collections</code>装饰的线程安全集合，如： <ul>
<li><code>Collections.synchronizedCollection </code></li>
<li><code>Collections.synchronizedList </code></li>
<li><code>Collections.synchronizedMap </code></li>
<li><code>Collections.synchronizedSet </code></li>
<li><code>Collections.synchronizedNavigableMap </code></li>
<li><code>Collections.synchronizedNavigableSet  </code></li>
<li><code>Collections.synchronizedSortedMap </code></li>
<li><code>Collections.synchronizedSortedSet </code></li>
<li>说明：以上集合均采用修饰模式设计，将非线程安全的集合包装后，在调用方法时包裹了一层synchronized代码块。其并发性并不比遗留的安全集合好。</li>
</ul>
</li>
<li>java.util.concurrent.*</li>
</ul>
<p>重点介绍<code>java.util.concurrent.* </code>下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent</p>
<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li>
<li>CopyOnWrite 之类容器修改开销相对较重 </li>
<li>Concurrent 类型的容器<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的 </li>
<li>求大小弱一致性，size 操作未必是 100% 准确 </li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出 ConcurrentModificationException，不再继续遍历</p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="应用之单词计数"><a href="#应用之单词计数" class="headerlink" title="应用之单词计数"></a><font color='green'>应用之单词计数</font></h3><p><strong>搭建练习环境：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//在main方法中实现两个接口</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//开启26个线程，每个线程调用get方法获取map，从对应的文件读取单词并存储到list中，最后调用accept方法进行统计。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="keyword">void</span>  <span class="title function_">calculate</span><span class="params">(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, BiConsumer&lt;Map&lt;String,V&gt;, List&lt;String&gt;&gt; consumer)</span> &#123;</span><br><span class="line">        Map&lt;String, V&gt; map = supplier.get();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                read(list,k);</span><br><span class="line">                consumer.accept(map,list);</span><br><span class="line">                count.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//读单词方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(List&lt;String&gt; list,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String element;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(i + <span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">while</span>((element = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//生成测试数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(str.charAt(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(i + <span class="number">1</span> + <span class="string">&quot;.txt&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> list.subList(i * <span class="number">200</span>, (i + <span class="number">1</span>) * <span class="number">200</span>).stream().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">                out.println(collect);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现一："><a href="#实现一：" class="headerlink" title="实现一："></a>实现一：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    <span class="comment">// 创建 map 集合</span></span><br><span class="line">    <span class="comment">// 创建 ConcurrentHashMap 对不对？</span></span><br><span class="line">    () -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Integer&gt;(),</span><br><span class="line">    <span class="comment">// 进行计数</span></span><br><span class="line">    (map, words) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">            <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter == <span class="literal">null</span> ? <span class="number">1</span> : counter + <span class="number">1</span>;</span><br><span class="line">            map.put(word, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=186, b=192, c=187, d=184, e=185, f=185, g=176, h=185, i=193, j=189, k=187, l=157, m=189, n=181, o=180, p=178, q=185, r=188, s=181, t=183, u=177, v=186, w=188, x=178, y=189, z=186&#125;</span><br><span class="line">47</span><br></pre></td></tr></table></figure>

<p>错误原因：</p>
<ul>
<li><strong>ConcurrentHashMap虽然每个方法都是线程安全的，但是多个方法的组合并不是线程安全的</strong></li>
<li><strong>解决线程安全问题要先定位线程安全问题在哪里，才能进一步采取有效的方案解决</strong></li>
<li>并且要注意很多线程安全类只是保障其方法api是线程安全的，调用完方法后就会释放锁，仍旧是线程不安全的，即使是多个线程安全的方法组合在一起他们仍旧是线程不安全的，因为方法调用完会释放锁，就一定出现指定的交叉运行</li>
</ul>
<h5 id="正确答案一："><a href="#正确答案一：" class="headerlink" title="正确答案一："></a>正确答案一：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    () -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, LongAdder&gt;(),</span><br><span class="line">    (map, words) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null</span></span><br><span class="line">            map.computeIfAbsent(word, (key) -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>()).increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>computIfAbsent方法的作用是：当map中不存在以参数1为key对应的value时，会将参数2函数式接口的返回值作为value，put进map中，然后返回该value。如果存在key，则直接返回value</li>
<li>以上两部均是线程安全的。</li>
</ul>
<h5 id="正确答案二："><a href="#正确答案二：" class="headerlink" title="正确答案二："></a>正确答案二：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    () -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Integer&gt;(),</span><br><span class="line">    (map, words) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 函数式编程，无需原子变量</span></span><br><span class="line">            map.merge(word, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="ConcurrentHashMap-原理"><a href="#ConcurrentHashMap-原理" class="headerlink" title="ConcurrentHashMap 原理"></a><font color='blue'>ConcurrentHashMap 原理</font></h3><h4 id="JDK-7-HashMap-并发死链"><a href="#JDK-7-HashMap-并发死链" class="headerlink" title="JDK 7 HashMap 并发死链"></a>JDK 7 HashMap 并发死链</h4><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><p>注意 </p>
<ul>
<li>要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了</li>
<li>以下测试代码是精心准备的，不要随便改动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 测试 java 7 中哪些数字的 hash 结果相等</span></span><br><span class="line">    System.out.println(<span class="string">&quot;长度为16时，桶下标为1的key&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash(i) % <span class="number">16</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;长度为32时，桶下标为1的key&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash(i) % <span class="number">32</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="comment">// 放 12 个元素</span></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">6</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">7</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">8</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">9</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">10</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">16</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">35</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;扩容前大小[main]:&quot;</span>+map.size());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">            map.put(<span class="number">50</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">            map.put(<span class="number">50</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="死链复现"><a href="#死链复现" class="headerlink" title="死链复现"></a>死链复现</h5><p>调试工具使用 idea </p>
<p>在 HashMap 源码 590 行加断点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br></pre></td></tr></table></figure>

<p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newTable.length==<span class="number">32</span> &amp;&amp;</span><br><span class="line"> (</span><br><span class="line"> Thread.currentThread().getName().equals(<span class="string">&quot;Thread-0&quot;</span>)||</span><br><span class="line"> Thread.currentThread().getName().equals(<span class="string">&quot;Thread-1&quot;</span>)</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<p>断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行 </p>
<p>运行代码，程序在预料的断点位置停了下来，输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长度为16时，桶下标为1的key </span><br><span class="line">1 </span><br><span class="line">16 </span><br><span class="line">35 </span><br><span class="line">50 </span><br><span class="line">长度为32时，桶下标为1的key </span><br><span class="line">1 </span><br><span class="line">35 </span><br><span class="line">扩容前大小[main]:12 </span><br></pre></td></tr></table></figure>

<p>接下来进入扩容流程调试 </p>
<p>在 HashMap 源码 594 行加断点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next; <span class="comment">// 593</span></span><br><span class="line"><span class="keyword">if</span> (rehash) <span class="comment">// 594</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件 Thread.currentThread().getName().equals(“Thread-0”)）</p>
<p>这时可以在 Variables 面板观察到 e 和 next 变量，使用<code>view as -&gt; Object</code>查看节点状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e (<span class="number">1</span>)-&gt;(<span class="number">35</span>)-&gt;(<span class="number">16</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">next</span> <span class="params">(<span class="number">35</span>)</span>-&gt;(<span class="number">16</span>)-&gt;<span class="literal">null</span> </span><br></pre></td></tr></table></figure>

<p>在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>] (<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩容后大小:13 </span><br></pre></td></tr></table></figure>

<p>这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e (<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">next</span> <span class="params">(<span class="number">35</span>)</span>-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br></pre></td></tr></table></figure>

<p>为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结 果正确，但它结束后 Thread-0 还要继续运行 </p>
<p>接下来就可以单步调试（F8）观察死链的产生了 </p>
<p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>] (<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">e</span> <span class="params">(<span class="number">35</span>)</span>-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">next</span> <span class="params">(<span class="number">1</span>)</span>-&gt;<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>] (<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">e</span> <span class="params">(<span class="number">1</span>)</span>-&gt;<span class="literal">null</span> </span><br><span class="line">next <span class="literal">null</span> </span><br></pre></td></tr></table></figure>

<p>再看看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 这时 e (1,35)</span></span><br><span class="line"><span class="comment">// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象</span></span><br><span class="line">newTable[<span class="number">1</span>] = e; </span><br><span class="line"><span class="comment">// 再尝试将 e 作为链表头, 死链已成</span></span><br><span class="line">e = next;</span><br><span class="line"><span class="comment">// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了</span></span><br></pre></td></tr></table></figure>

<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h5><p>HashMap 的并发死链发生在扩容时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 table 迁移至 newTable</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 1 处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 2 处</span></span><br><span class="line">            <span class="comment">// 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 map 中初始元素是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">原始链表，格式：[下标] (key,next)</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="number">35</span>)-&gt;(<span class="number">35</span>,<span class="number">16</span>)-&gt;(<span class="number">16</span>,<span class="literal">null</span>)</span><br><span class="line">线程 a 执行到 <span class="number">1</span> 处 ，此时局部变量 e 为 (<span class="number">1</span>,<span class="number">35</span>)，而局部变量 next 为 (<span class="number">35</span>,<span class="number">16</span>) 线程 a 挂起</span><br><span class="line">线程 b 开始执行</span><br><span class="line">第一次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第二次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第三次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">[<span class="number">17</span>] (<span class="number">16</span>,<span class="literal">null</span>)</span><br><span class="line">切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (<span class="number">1</span>,<span class="literal">null</span>)，而 next 的内</span><br><span class="line">容被改为 (<span class="number">35</span>,<span class="number">1</span>) 并链向 (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第一次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第二次循环，注意这时 e 是 (<span class="number">35</span>,<span class="number">1</span>) 并链向 (<span class="number">1</span>,<span class="literal">null</span>) 所以 next 又是 (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">[<span class="number">1</span>] (<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第三次循环，e 是 (<span class="number">1</span>,<span class="literal">null</span>)，而 next 是 <span class="literal">null</span>，但 e 被放入链表头，这样 e.next 变成了 <span class="number">35</span> （<span class="number">2</span> 处）</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="number">35</span>)-&gt;(<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="number">35</span>)</span><br><span class="line">已经是死链了</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合 </li>
<li>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能 够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</li>
</ul>
<h4 id="JDK-8-ConcurrentHashMap"><a href="#JDK-8-ConcurrentHashMap" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h4><h5 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReservationNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>



<h5 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><br><span class="line"><span class="comment">//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少</span></span><br><span class="line"><span class="comment">//在CAS算法中，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改</span></span><br><span class="line"><span class="comment">//因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果  属于乐观锁的思想</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span></span><br></pre></td></tr></table></figure>



<h5 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h5><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h5><p>初始化方法能保证线程安全性的核心原理是使用CAS算法实现线程的同步互斥效果，用CAS算法操作sizectl变量，只要有线程在初始化了就使用CAS算法将该标记变量设置为-1，其他线程因为标记变量的值发生了变化，CAS算法修改值失败，无法进入初始化流程，自然就实现了初始化过程中的线程同步互斥效果了</p>
<p>细节：因为concurrentHashMap是懒惰初始化，所以初始化流程是在put方法内部执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="comment">//sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//相当于0.75*n 设置一个扩容的阈值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果头结点已经是要查找的 key</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 正常遍历链表, 用 equals 比较</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>如果table不为空且长度大于0且索引位置有元素<ul>
<li>if 头节点key的hash值相等<ul>
<li>头节点的key指向同一个地址或者equals<ul>
<li>返回value</li>
</ul>
</li>
</ul>
</li>
<li>else if 头节点的hash为负数（数组在扩容或者是treebin节点）<ul>
<li>调用find方法查找</li>
</ul>
</li>
<li>进入循环（e不为空）：<ul>
<li>节点key的hash值相等，且key指向同一个地址或equals<ul>
<li>返回value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回null</li>
</ul>
<p><strong>为什么读操作get不用加锁就可以保证线程安全性呢？</strong></p>
<p>首先如果是并发读读操作不会产生线程安全问题，其次即使是并发读写操作，也只会产生读取脏数据，不可重复读的问题，其中读取脏数据是不能忍受的，而不可重复读基本不影响结果，一般不需要处理</p>
<p>读取脏数据的原因是线程的写操作对其他不可见，原理是线程读写操作有可能针对是缓存，自然其他线程对其缓存是不可见，只要保证线程读写操作都是操作的内存而非缓存，自然就可以实现可见性了，所以只要加volatile关键字即可实现可见性和有序性</p>
<h5 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h5><p>以下数组简称（table），链表简称（bin）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//不允许 key或value为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//计算hash值 其中 spread 方法会综合高位低位(异或实现), 具有更好的 hash 性</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//死循环 何时插入成功 何时跳出</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f 是链表头节点</span></span><br><span class="line">        <span class="comment">// fh 是链表头结点的 hash</span></span><br><span class="line">        <span class="comment">// i 是链表在 table 中的下标</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table为空的话，初始化table</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         <span class="comment">// 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">         <span class="comment">//根据hash值计算出在table里面的位置 这个位置也是链表头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁 (CAS无锁实现)</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数组正在扩容，则帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助之后, 进入下一轮循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 锁住链表头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次确认链表头节点没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到相同的 key</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 更新</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 已经是最后的节点了, 新增 Node, 追加至链表尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放链表头节点的锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 如果链表长度 &gt;= 树化阈值(8), 进行链表转为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 size 计数并盼到是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// 尝试将 sizeCtl 设置为 -1（表示初始化 table）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check 是之前 binCount 的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    <span class="comment">//计数部分使用原子累加器实现</span></span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 已经有了 counterCells, 向 cell 累加</span></span><br><span class="line">        (as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        <span class="comment">// 还没有, 向 baseCount 累加</span></span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)</span><br><span class="line">    ) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 还没有 counterCells</span></span><br><span class="line">            as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// cell cas 增加计数失败</span></span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 创建累加单元数组和cell, 累加重试</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 获取元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容部分省略..</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>1.做插入操作时，首先进入乐观锁(死循环for，直到put操作完成才会退出循环)</p>
<p>2.判断容器是否初始化(容器初始化流程也是用乐观锁思想来实现，即CAS来实现)</p>
<p>3.如果已经初始化，则判断该hash位置的节点是否为空，如果为空，则通过CAS操作进行插入</p>
<p>4.如果该节点不为空，再判断容器<strong>是否在扩容中</strong>，如果在扩容，则帮助其扩容</p>
<p>5.如果没有扩容，则进行最后一步，先加锁，然后找到hash值相同的那个节点(hash冲突)</p>
<p><strong>当出现hash冲突时，就会出现多个共享数据(链表 or 红黑树)，此时使用无锁(CAS)实现已经无法解决线程安全问题，只能使用有锁来实现，但jdk8对于锁的范围优化的非常好，充分利用了链表结构只能根据前一个节点才能找到一个节点的特性，只给了链表头节点上锁就可以实现线程的同步互斥效果了，也就是锁的范围变成了每个链表的头节点，而非整个数组+链表，大大缩小了锁的范围，从而大大提高了并发的性能</strong></p>
<p>6.循环判断这个节点上的链表，决定做更新操作还是插入操作</p>
<p>7.判断链表的长度是否大于等于8，如果是则需要将链表转换成红黑树</p>
<p>8.增加元素计数(<strong>原理是使用原子累加器实现</strong>)</p>
<p>9.检查容器是否需要扩容，如果需要则进行扩容操作</p>
<p>触发扩容的两种情况</p>
<p>A.容器中元素的数量已经达到了容器的当前阈值(负载因子 * 数组长度)</p>
<p>B.容器中的元素数量&lt;64且某一个桶的链表长度大于等于8</p>
<h5 id="扩容原理"><a href="#扩容原理" class="headerlink" title="扩容原理"></a>扩容原理</h5><p>A.判断容器是否需要扩容的addCount方法</p>
<p>addCount扩容判断流程流程</p>
<ol>
<li>判断是否需要扩容</li>
<li>如果正在扩容中，就协助扩容</li>
<li>如果还没有扩容，新建数组开始扩容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">      <span class="comment">//省略部分代码，省略部分是处理计数的</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">            <span class="comment">//sizeCtl正常就是值就是扩容点的值，首次设置在initTable方法设置的</span></span><br><span class="line">            <span class="comment">//s &gt;= sizeCtl说明达到了扩容点，后面两个方法是为了处理极端的情况的</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//这个方法的目的就是为每次扩容生成一个唯一的标识，在第一篇文章中介绍属性的时候</span></span><br><span class="line">                <span class="comment">//介绍了好几个属性，都是在这个方法中使用的，后面会分析这个方法，标记：说明1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">                <span class="comment">//sc小于零说明在扩容中，设置小于0的是下面哪个else if设置的</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//这个是判断sc的高16位是不是和rs相等，一会分析rs就知道了，只要处在同一轮扩容中，这个标志就是一样的</span></span><br><span class="line">                    <span class="comment">//后面几个方法都是在处理一些极端情况，最后一个transferIndex &lt;= 0这个一会需要说明下，标记：说明2</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//上面的条件就是判断一些极端条件，如果符合，上面就直接break了，如果不满足就通过CAS将sc加1</span></span><br><span class="line">                    <span class="comment">//这个其实就是把sizeCtl的低16位加1，意思是又多了一个协助扩容的线程，至于为什么要加1后面说明，标记：说明3</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        <span class="comment">//这里由于是协助扩容，所以传入的是nt = nextTable，因为已经创建好了</span></span><br><span class="line">                        <span class="comment">//这里其实就是解释了概述中提到的第一个问题，一次只能由一个线程创建表</span></span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果sc &gt;= 0,说明nextTable还没有创建，通过CAS竞争去创建</span></span><br><span class="line">                <span class="comment">//注意这里把sizeCtl加2，不是加1，意思可能是一方面要创建表，另一方面要扩容                //如果CAS成功，说明只能由要给线程去创建表</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    <span class="comment">//这里传入null</span></span><br><span class="line">                    transfer(tab, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//计算元素个数，与此次扩容无关</span></span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int resizeStamp(int n) &#123;</span><br><span class="line">    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Integer.numberOfLeadingZeros表示一个数从高位算起为0的位的个数，比如当n &#x3D; 1时，结果为31，当n &#x3D; 2时，结果为30。</li>
<li>1 &lt;&lt; (RESIZE_STAMP_BITS - 1)，由于RESIZE_STAMP_BITS &#x3D; 16，所以这个就是把1的二进制左移15位，也就是2^16，2的16次方。</li>
<li>上面两个结果做或运算，就相当于两个数向加，因为第二数的低16位全是0。假设n &#x3D; 16，最后的结果为：32795</li>
<li>由于每次传入的n不相同，所以每次结果也不同，也就是每次的标识也不同，这个值这么做的好处就是只在低16位有值，在下面计算sizeCtl的时候，只要继续左移16位，那低16位也就没有值了</li>
</ul>
<p><strong>说明2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span><br></pre></td></tr></table></figure>

<p>这段代码是否成立，要想搞清楚这段代码是否成立，要先搞清楚sc是多少。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (s &gt;= (long)(sc = sizeCtl)</span><br></pre></td></tr></table></figure>

<p>从while循环看，sc &#x3D; sizeCtl，那sizeCtl是多少，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br></pre></td></tr></table></figure>

<p>这个CAS操作，会修改sizeCtl的值，最后sizeCtl &#x3D; ( (rs &lt;&lt; 16) + 2)，可以知道最开始的那个不等式就相当于如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) &gt;&gt;&gt; RESIZE_STAMP_SHIFT != rs</span><br></pre></td></tr></table></figure>

<p>上面这个公式就很清楚了，相当于rs先有符号左移16位，之后加2，最后再无符号右移16位，由于加的2在低位，右移的时候就没了，所以最后的结果还是rs</p>
<p><strong>说明3</strong></p>
<p>经过上面两个说明，<strong>应该可以清楚的知道sizeCtl的高16位是标志位，就是每一轮扩容生成的一个唯一的标志，低16位标识参与扩容的线程数，所以这里进行加1操作</strong>。那问题来了，为什么要记录参与扩容的线程数？这个原因一会看扩容的代码就明白了，这里先提一下，记录参与扩容的线程数的原因是每个线程执行完扩容，sizeCtl就减1，当最后发现sizeCtl &#x3D; rs &lt;&lt;RESIZE_STAMP_SHIFT的时候，说明所有参与扩容的线程都执行完，防止最后以为扩容结束了，旧的数组都被干掉了，但是还有的线程在copy</p>
<p>B.真正的扩容原理和流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * transferIndex 表示转移时的下标，初始为扩容前的 length。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们假设长度是 32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">// 将 length / 8 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16。</span></span><br><span class="line">    <span class="comment">// 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 细分范围 stridea：TODO</span></span><br><span class="line">    <span class="comment">// 新的 table 尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容  2 倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">// 扩容失败， sizeCtl 使用 int 最大值。</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新成员变量</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 更新转移下标，就是 老的 tab 的 length</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新 tab 的 length</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">// 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 完成状态，如果是 true，就结束此方法。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标，死循环的作用是保证拷贝全部完成。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">// 如果当前线程可以向后推进；这个循环就是控制 i 递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间        //这个循环只是用来控制每个线程每轮最多copy的桶的个数，如果只有一个线程在扩容，也是可以完成的，只是分成多轮</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）</span></span><br><span class="line">            <span class="comment">// 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。</span></span><br><span class="line">            <span class="comment">// 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，            //将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;<span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            <span class="comment">// 这里的目的是：1. 当一个线程进入时，会选取最新的转移下标。2. 当一个线程处理完自己的区间时，如果还有剩余区间的没有别的线程处理。再次获取区间。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了</span></span><br><span class="line">                <span class="comment">// 这个 -1 会在下面的 if 块里判断，从而进入完成状态判断</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;<span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            &#125;<span class="comment">// CAS 修改 transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;<span class="comment">// 这个值就是当前线程可以处理的最小当前区间最小下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>; <span class="comment">// 初次对i 赋值，这个就是当前线程可以处理的当前区间的最大下标</span></span><br><span class="line">                advance = <span class="literal">false</span>; <span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进，这样对导致漏掉某个桶。下面的 if (tabAt(tab, i) == f) 判断会出现这样的情况。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 如果 i 小于0 （不在 tab 下标内，按照上面的判断，领取最后一段区间的线程扩容结束）</span></span><br><span class="line">        <span class="comment">//  如果 i &gt;= tab.length(不知道为什么这么判断)</span></span><br><span class="line">        <span class="comment">//  如果 i + tab.length &gt;= nextTable.length  （不知道为什么这么判断）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 如果完成了扩容</span></span><br><span class="line">                nextTable = <span class="literal">null</span>;<span class="comment">// 删除成员变量</span></span><br><span class="line">                table = nextTab;<span class="comment">// 更新 table</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 更新阈值</span></span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">// 结束方法。</span></span><br><span class="line">            &#125;<span class="comment">// 如果没完成             //说明1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;<span class="comment">// 尝试将 sc -1. 表示这个线程结束帮助扩容了，将 sc 的低 16 位减一。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<span class="comment">// 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。</span></span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 不相等，说明没结束，当前线程结束方法。</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;<span class="comment">// 如果相等，扩容结束了，更新 finising 变量</span></span><br><span class="line">                i = n; <span class="comment">// 再次循环检查一下整张表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>) <span class="comment">// 获取老 tab i 下标位置的变量，如果是 null，就使用 fwd 占位。</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);<span class="comment">// 如果成功写入 fwd 占位，再次推进一个下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">// 如果不是 null 且 hash 值是 MOVED。</span></span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed // 说明别的线程已经处理过了，再次推进一个下标</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点上锁。为什么上锁，防止 putVal 的时候向链表插入数据</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 判断 i 下标处的桶节点是否和 f 相同</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;<span class="comment">// low, height 高位桶，低位桶</span></span><br><span class="line">                    <span class="comment">// 如果 f 的 hash 值大于 0 。TreeBin 的 hash 是 -2</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 对老长度进行与运算（第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0）</span></span><br><span class="line">                        <span class="comment">// 由于 Map 的长度都是 2 的次方（000001000 这类的数字），那么取于 length 只有 2 种结果，一种是 0，一种是1</span></span><br><span class="line">                        <span class="comment">//  如果是结果是0 ，Doug Lea 将其放在低位，反之放在高位，目的是将链表重新 hash，放到对应的位置上，让新的取于算法能够击中他。</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f; <span class="comment">// 尾节点，且和头节点的 hash 值取于不相等</span></span><br><span class="line">                        <span class="comment">// 遍历这个桶                        //说明2</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">// 取于桶中每个节点的 hash 值</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 如果节点的 hash 值和首节点的 hash 值取于结果不同</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b; <span class="comment">// 更新 runBit，用于下面判断 lastRun 该赋值给 ln 还是 hn。</span></span><br><span class="line">                                lastRun = p; <span class="comment">// 这个 lastRun 保证后面的节点与自己的取于值相同，避免后面没有必要的循环</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;<span class="comment">// 如果最后更新的 runBit 是 0 ，设置低位节点</span></span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun; <span class="comment">// 如果最后更新的 runBit 是 1， 设置高位节点</span></span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;<span class="comment">// 再次循环，生成两个链表，lastRun 作为停止条件，这样就是避免无谓的循环（lastRun 后面都是相同的取于结果）</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="comment">// 如果与运算结果是 0，那么就还在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) <span class="comment">// 如果是0 ，那么创建低位节点</span></span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span> <span class="comment">// 1 则创建高位</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其实这里类似 hashMap </span></span><br><span class="line">                        <span class="comment">// 设置低位链表放在新链表的 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 设置高位链表，在原有长度上加 n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将旧的链表设置成占位符</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续向后推进</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="comment">// 如果是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="comment">// 和链表相同的判断，与运算 == 0 的放在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; <span class="comment">// 不是 0 的放在高位</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 低位树</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位数</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 旧的设置成占位符</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续向后推进</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上流程如下：</p>
<ol>
<li>根据CPU核数和集合length计算每个核一轮处理桶的个数，最小是16</li>
<li>修改transferIndex标志位，每个线程领取完任务就减去多少，比如初始大小是transferIndex &#x3D; table.length &#x3D; 64，每个线程领取的桶个数是16，第一个线程领取完任务后transferIndex &#x3D; 48，也就是说第二个线程这时进来是从第48个桶开始处理，再减去16，依次类推，这就是多线程协作处理的原理</li>
<li>领取完任务之后就开始处理，如果桶为空就设置为ForwardingNode,如果不为空就加锁拷贝，拷贝完成之后也设置为ForwardingNode节点</li>
<li>如果某个线程分配的桶处理完了之后，再去申请，发现transferIndex &#x3D; 0，这个时候就说明所有的桶都领取完了，但是别的线程领取任务之后有没有处理完并不知道，该线程会将sizeCtl的值减1，然后判断是不是所有线程都退出了，如果还有线程在处理，就退出</li>
<li>直到最后一个线程处理完，发现sizeCtl &#x3D; rs&lt;&lt; RESIZE_STAMP_SHIFT，才会将旧数组干掉，用新数组覆盖，并且会重新设置sizeCtl为新数组的扩容点</li>
</ol>
<p>以上过程总的来说分成两个部分：</p>
<ul>
<li>分配任务部分：这部分其实很简单，就是把一个大的数组给切分，切分多个小份，然后每个线程处理其中每一小份，当然可能就只有1个或者几个线程在扩容，那就一轮一轮的处理，一轮处理一份</li>
<li>处理任务部分：复制部分主要有两点，第一点就是加锁，第二点就是处理完之后置为ForwardingNode</li>
</ul>
<p>精华部分图解</p>
<p>1.ConCurrentHashMap 支持并发扩容，实现方式是，将表拆分，让每个线程处理自己的区间</p>
<p><img src="D:/VscodeProjects/source/_posts/ConCurrentHashMap的扩容原理图1.png" alt="ConCurrentHashMap的扩容原理图1"></p>
<p>2.而每个线程在处理自己桶中的数据的时候，是下图这样的</p>
<p>扩容前的状态</p>
<p><img src="D:/VscodeProjects/source/_posts/ConCurrentHashMap扩容原理图2.png" alt="ConCurrentHashMap扩容原理图2"></p>
<p>当对 4 号桶或者 10 号桶进行转移的时候，会将链表拆成两份，规则是根据节点的 hash 值取于 length，如果结果是 0，放在低位，否则放在高位</p>
<p><img src="D:/VscodeProjects/source/_posts/ConCurrentHashMap扩容原理图3.png" alt="ConCurrentHashMap扩容原理图3"></p>
<p>扩容结果</p>
<p><img src="D:/VscodeProjects/source/_posts/ConCurrentHashMap扩容原理图4.png" alt="ConCurrentHashMap扩容原理图4"></p>
<h5 id="扩容总结"><a href="#扩容总结" class="headerlink" title="扩容总结"></a>扩容总结</h5><p>通过给每个线程分配桶区间来支持多线程扩容，通过标记节点避免实现线程间扩容的可见性，通过加锁实现桶节点扩容过程中的安全性，扩容性能之所以高，是因为其中运用了大量的无锁实现而非直接加重量级锁，这才给多线程扩容提供了鼎立的支持</p>
<p>关于标记节点和加锁的说明</p>
<p>在多线程环境下，<strong>ConcurrentHashMap用两点来保证正确性：ForwardingNode和synchronized</strong>。当一个线程遍历到的节点如果是ForwardingNode，则继续往后遍历，如果不是，则将该节点加锁，防止其他线程进入，完成后设置ForwardingNode节点，以便要其他线程可以看到该节点已经处理过了，如此交叉进行，高效而又安全</p>
<p>参考文献</p>
<p>1.<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gunduzi/p/13651664.html">ConcurrentHashMap原理分析(二)-扩容 - 猿起缘灭 - 博客园 (cnblogs.com)</a></p>
<p>2.<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903607901356046">并发编程——ConcurrentHashMap#transfer() 扩容逐行分析 - 掘金 (juejin.cn)</a></p>
<h5 id="size-计算流程"><a href="#size-计算流程" class="headerlink" title="size 计算流程"></a>size 计算流程</h5><p>size 计算实际发生在 put，remove 改变集合元素的操作之中 </p>
<ul>
<li>没有竞争发生，向 baseCount 累加计数 </li>
<li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计<ul>
<li>counterCells 初始有两个 cell </li>
<li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">// 将 baseCount 计数与所有 cell 计数累加</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>ConcurrentHashMap为什么在多线程环境下性能仍然非常高呢？</p>
<p>原因在于其运用了大量的无锁实现，并没有上来就加重量级锁，即使后来加重量级锁也只是给桶节点的链表头节点加锁，大大缩小了锁的细粒度，即使在扩容过程中也是如此，线程的并发度非常高，性能自然就不会差</p>
<h5 id="分析源码的思路"><a href="#分析源码的思路" class="headerlink" title="分析源码的思路"></a>分析源码的思路</h5><p><strong>1.从源码的设计思想入手分析，最好是分析思路是依据源码的设计思路-&gt;具体的方法流程图分析-&gt;步骤总结三个步骤入手分析源码，一般吃透源码的思想是没有问题的，而且精华就在思想部分而不是具体的某些细节</strong></p>
<p>2.切记一上来就扎进代码中，没有任何意义，代码中的细节非常多，非常的复杂，分析起来会耗费大量的时间，且需要你自己从代码中归纳中源码的设计思想和具体实现，非常的困难，结果往往是浪费了大量的时间也分析不出个所以然出来</p>
<h4 id="JDK-7-ConcurrentHashMap"><a href="#JDK-7-ConcurrentHashMap" class="headerlink" title="JDK 7 ConcurrentHashMap"></a>JDK 7 ConcurrentHashMap</h4><p>它维护了一个 segment 数组，每个 segment 对应一把锁 </p>
<ul>
<li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的 </li>
<li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</li>
</ul>
<h5 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建 segments and segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="put-流程-1"><a href="#put-流程-1" class="headerlink" title="put 流程"></a>put 流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 计算出 segment 下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject </span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null,</span></span><br><span class="line">        <span class="comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入 segment 的put 流程</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">    <span class="comment">// 如果不成功, 进入 scanAndLockForPut 流程</span></span><br><span class="line">    <span class="comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程</span></span><br><span class="line">    <span class="comment">// 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span></span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123; </span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新增</span></span><br><span class="line">                <span class="comment">// 1) 之前等待锁时, node 已经被创建, next 指向链表头</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 2) 创建新 node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>; </span><br><span class="line">                <span class="comment">// 3) 扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 将 node 作为链表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rehash-流程"><a href="#rehash-流程" class="headerlink" title="rehash 流程"></a>rehash 流程</h5><p>发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) <span class="comment">// Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="literal">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 剩余节点需要新建</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容完成, 才加入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换为新的 HashEntry table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附，调试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ConcurrentHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">segmentIndex</span> <span class="operator">=</span> (hash &gt;&gt;&gt; <span class="number">28</span>) &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (segmentIndex == <span class="number">4</span> &amp;&amp; hash % <span class="number">8</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;\t&quot;</span> + segmentIndex + <span class="string">&quot;\t&quot;</span> + hash % <span class="number">2</span> + <span class="string">&quot;\t&quot;</span> + hash % <span class="number">4</span> +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + hash % <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">15</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 2 扩容为 4 15 的 hash%8 与其他不同</span></span><br><span class="line">    map.put(<span class="number">169</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">197</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 4 扩容为 8</span></span><br><span class="line">    map.put(<span class="number">341</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">484</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">545</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 8 扩容为 16</span></span><br><span class="line">    map.put(<span class="number">912</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">941</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="get-流程"><a href="#get-流程" class="headerlink" title="get 流程"></a>get 流程</h5><p>get 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新 表取内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// u 为 segment 对象在数组中的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// s 即为 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="size-计算流程-1"><a href="#size-计算流程-1" class="headerlink" title="size 计算流程"></a>size 计算流程</h5><ul>
<li>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回 </li>
<li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="type">long</span> sum; <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// previous sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="comment">// 超过重试次数, 需要创建所有 segment 并加锁</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="BlockingQueue-原理"><a href="#BlockingQueue-原理" class="headerlink" title="BlockingQueue 原理"></a><font color='blue'>BlockingQueue 原理</font></h3><h4 id="基本的入队出队"><a href="#基本的入队出队" class="headerlink" title="基本的入队出队"></a>基本的入队出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 		* 下列三种情况之一</span></span><br><span class="line"><span class="comment"> 		* - 真正的后继节点</span></span><br><span class="line"><span class="comment"> 		* - 自己, 发生在出队时</span></span><br><span class="line"><span class="comment"> 		* - null, 表示是没有后继节点, 是最后了</span></span><br><span class="line"><span class="comment"> 		*/</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p><strong>高明之处</strong>在于用了两把锁和 dummy 节点 </p>
<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行 </li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 <ul>
<li>消费者与消费者线程仍然串行 </li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p>线程安全分析 </p>
<ul>
<li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争 </li>
<li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争 </li>
<li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<p>put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//LinkedBlockingQueue不支持空元素</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 满了等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 倒过来读就好: 等待 notFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位, 入队且计数加一</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement(); </span><br><span class="line">        <span class="comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一个元素, 叫醒 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span></span><br><span class="line">    <span class="comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull()</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由 put 唤醒 put 是为了避免信号不足</p>
</blockquote>
<h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较 </p>
<ul>
<li>Linked 支持有界，Array 强制有界 </li>
<li>Linked 实现是链表，Array 实现是数组 </li>
<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组 </li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的 </li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 </p>
<ul>
<li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 </li>
<li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争 </li>
<li>只是这【锁】使用了 cas 来实现</li>
</ul>
<p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的 </p>
<p>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了 ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">subgraph Connector-&gt;NIO EndPoint</span><br><span class="line">t1(LimitLatch)</span><br><span class="line">t2(Acceptor)</span><br><span class="line">t3(SocketChannel 1)</span><br><span class="line">t4(SocketChannel 2)</span><br><span class="line">t5(Poller)</span><br><span class="line">subgraph Executor</span><br><span class="line">t7(worker1)</span><br><span class="line">t8(worker2)</span><br><span class="line">end</span><br><span class="line">t1 --&gt; t2</span><br><span class="line">t2 --&gt; t3</span><br><span class="line">t2 --&gt; t4</span><br><span class="line">t3 --有读--&gt; t5</span><br><span class="line">t4 --有读--&gt; t5</span><br><span class="line">t5 --socketProcessor--&gt; t7</span><br><span class="line">t5 --socketProcessor--&gt; t8</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ConcurrentLinkedQueue-原理"><a href="#ConcurrentLinkedQueue-原理" class="headerlink" title="ConcurrentLinkedQueue 原理"></a><font color='blue'>ConcurrentLinkedQueue 原理</font></h3><h4 id="模仿-ConcurrentLinkedQueue"><a href="#模仿-ConcurrentLinkedQueue" class="headerlink" title="模仿 ConcurrentLinkedQueue"></a>模仿 ConcurrentLinkedQueue</h4><p>初始代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.concurrent.thirdpart.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = head; p != <span class="literal">null</span>; p = p.next.get()) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(item).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        head = last = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*Node&lt;E&gt; h = head;</span></span><br><span class="line"><span class="comment"> 		Node&lt;E&gt; first = h.next;</span></span><br><span class="line"><span class="comment"> 		h.next = h;</span></span><br><span class="line"><span class="comment"> 		head = first;</span></span><br><span class="line"><span class="comment">        E x = first.item;</span></span><br><span class="line"><span class="comment"> 		first.item = null;</span></span><br><span class="line"><span class="comment"> 		return x;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E item, Node&lt;E&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(next);</span><br><span class="line">        &#125;</span><br><span class="line">        AtomicReference&lt;Node&lt;E&gt;&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>offer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取尾节点</span></span><br><span class="line">        AtomicReference&lt;Node&lt;E&gt;&gt; next = last.next;</span><br><span class="line">        <span class="comment">// S1: 真正尾节点的 next 是 null, cas 从 null 到新节点</span></span><br><span class="line">        <span class="keyword">if</span>(next.compareAndSet(<span class="literal">null</span>, n)) &#123;</span><br><span class="line">            <span class="comment">// 这时的 last 已经是倒数第二, next 不为空了, 其它线程的 cas 肯定失败</span></span><br><span class="line">            <span class="comment">// S2: 更新 last 为倒数第一的节点</span></span><br><span class="line">            last = n;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArraySet</code>是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更 改操作在新数组上执行，这时不影响其它线程的<strong>并发读</strong>，<strong>读写分离</strong>。 以新增为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获取旧的数组</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span></span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加新元素</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">// 替换旧的数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized</p>
</blockquote>
<p>其它读操作并未加锁，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (Object x : getArray()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) x;</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适合『读多写少』的应用场景 </p>
<h5 id="get-弱一致性"><a href="#get-弱一致性" class="headerlink" title="get 弱一致性"></a>get 弱一致性<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220317202641399.png" alt="image-20220317202641399"></h5><table>
<thead>
<tr>
<th align="center">时间点</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Thread-0 getArray()</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Thread-1 getArray()</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Thread-1 setArray(arrayCopy)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Thread-0 array[index]</td>
</tr>
</tbody></table>
<blockquote>
<p>不容易测试，但问题确实存在</p>
</blockquote>
<h5 id="迭代器弱一致性"><a href="#迭代器弱一致性" class="headerlink" title="迭代器弱一致性"></a>迭代器弱一致性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;).start();</span><br><span class="line">sleep1s();</span><br><span class="line"><span class="comment">//此时主线程的iterator依旧指向旧的数组。</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要觉得弱一致性就不好 </p>
<ul>
<li>数据库的 MVCC 都是弱一致性的表现 </li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>
</blockquote>
<p><strong>关于线程安全集合这章的原理+源码解析，个人觉得黑马的视频后面讲的太宽泛了，太水了，没有深入细节的讲解，只是粗略过了一遍，很多都没有讲为什么这样设计，甚至忽略了很多点，所以在这一章节基本没有学到什么，只是把黑马的源码笔记copy下来(因为他的源码有注释)，后续希望从各种途径再继续深入学习这一章节的原理</strong></p>
<p><strong>集合之所以能够保证线程安全性，正是应用了前面学习有锁实现和无锁实现，深入学习线程安全性集合的原理有助于我们深入理解无锁，有锁实现的原理和应用，所以深入学习线程安全性集合是如何保证线程安全性是非常有必要的</strong></p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p><strong>线程并发会出现的情况以及会导致的问题，我将其分为三类</strong></p>
<p>1.并发读读，不会出现线程安全性问题，因为不涉及共享数据的写操作</p>
<p>2.并发读写，会出现读到脏数据(一个线程更新了数据但该更新操作对其他线程不可见，原因在于cpu的内存的缓存机制，可以用volatile时间可见性解决)，不可重复读的问题(一般不影响结果，也不需要解决)</p>
<p>3.并发写写，会出现丢失更新数据的问题(因为线程会互相覆盖彼此的更新数据，所以就会丢失更新数据)，要<strong>想解决该问题就要实现并发线程的互斥</strong>，可以用无锁来实现，也可以用有锁来实现</p>
<p><strong>JUC并发编程的整体知识脉络(知识体系)</strong></p>
<p>JUC并发编程学下来给我的感觉就是解决并发过程中出现的三大问题<strong>，如何保障原子性，可见性，有序性</strong>，除此之外还有线程间的通信方式，各种通信模式的应用(保护性暂停模式，生产者消费者模式…)，最后还有并发工具类的使用，诸如线程池，各种原子类，线程安全的集合等</p>
<p>1.原子性</p>
<p>A.就是因为没有保障原子性，才会出现线程的交叉执行，指令的交叉执行，从而出现线程安全问题。解决原子性的方案有无锁-&gt;有锁(偏向锁-&gt;轻量级锁-&gt;重量级锁，其中重量级锁有两种典型的实现，Monitor监听器和ReentrantLock，前者是利用操作系统底层的互斥来实现的，后者是利用AQS+CAS算法实现的)</p>
<p>B.一般有限采用无锁实现，因为无锁实现一般要比有锁实现性能高，具体原因上面讲无锁实现已经很详细了就不再重复了，但无锁实现有个致命的缺点，无锁只能实现单个共享资源的线程安全对于多个共享资源就难以实现，此时只能使用有锁实现来解决了。有锁实现，如果锁的范围非常大的话，那么并发度就会非常低，如果更好细化锁的范围，控制好锁的粗细度，才能让有锁实现有更好的性能，这是一个难点也是有锁的优化思路</p>
<p>2.可见性和有序性</p>
<p>通过violate关键字可以保障有序性和可见性，有序性就是cpu访问内存而非缓存，让线程能获取最新的数据而非缓存的旧数据，可见性就是防止指令重排序造成的数据问题。具体的原理可以去看violate的原理</p>
<p>3.线程间的通信</p>
<p>主要是通过wait&#x2F;notity，await&#x2F;singal，park&#x2F;unpark来实现线程间的通信，具体的原理可以在上述笔记中找到</p>
<p>4.线程池</p>
<p>线程池主要是应用了典型的享元模式实现大量重复线程资源的复用+生产者消费模式实现线程间的通信+线程安全的阻塞队列</p>
<p>5.各种封装好的无锁实现线程安全的原子类，还有线程安全的集合等，值得注意的是线程安全的集合的了解还非常浅显，需要好时间深入学习和理解</p>
<h1 id="多线程在项目中的应用"><a href="#多线程在项目中的应用" class="headerlink" title="多线程在项目中的应用"></a>多线程在项目中的应用</h1><p>伙伴匹配系统的第六期：<br>在线回放：<a target="_blank" rel="noopener" href="https://meeting.tencent.com/v2/cloud-record/share?id=65c1d5f7-8465-4c70-99bb-eb3e148ceb0c&amp;from=3%EF%BC%88%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81%EF%BC%9Awr5M%EF%BC%89">https://meeting.tencent.com/v2/cloud-record/share?id=65c1d5f7-8465-4c70-99bb-eb3e148ceb0c&amp;from=3（访问密码：wr5M）</a></p>
<p>Mysql批量插入100W条数据的开发思路<br>1.测试单条插入和批量插入，分析插入性能瓶颈在那里<br>2.测试单次传输的数据量大小对性能的影响。比如单次传输的数据量是5000条，1W条，5W条，10W条<br>3.测试批量插入数据在单线程执行和并发执行的性能对比，从10个线程-&gt;20-&gt;40个线程，为什么后面线程数越来越多，反而速度更慢了，性能瓶颈究竟卡在那了</p>
<p>关键思考点：罗列主要的性能影响因素，通过测试实践发现性能瓶颈究竟卡在那了，是CPU核数，网络io还是数据库本身是性能瓶颈</p>
<p>批量插入数据的性能影响</p>
<p>1.并发性对批量插入数据的性能影响</p>
<p>2.网络IO资源，比如建立多少次数据库连接，传输带宽等因素</p>
<p>3.数据库方面，比如SQL语句，数据库配置等等</p>
<p>4.磁盘io</p>
<p>批量插入数据性能测试<br>单条插入<br>1000条 		1w条						10w条						  100w条						  1000w条<br>4.3s			  28.2850132s		   250.1833812s		   时间原因，没测		      时间原因，没测</p>
<p>批量插入<br>1000条		1w条						10w条 						  100w条						  1000w条<br>1.25s			3.05s						17.04s						  144s							   1479s 接近25分钟</p>
<p>后续要单独测试每次批量的数据量不一致，看看对性能的影响，主要是看网络传输的带宽对性能的影响</p>
<p>批量插入<br>插入数据量 			1w条			 10w条							100w条						       1000w条</p>
<p>一次传输数据量	 1w				 1w&#x2F;10w						  1k&#x2F;1w&#x2F;10w&#x2F;100w		     1w&#x2F;10w&#x2F;100w</p>
<p>​								3.05s			 17.2s&#x2F;17.04s				 132s&#x2F;130s&#x2F;111s&#x2F;130s      2083s 接近34分钟&#x2F;</p>
<p>​		</p>
<p>多线程+批量插入100w条数据对性能的影响</p>
<p>一次批量插入的数据量是1w条<br>5个线程			10个线程			15个线程 		20个线程<br>43s					42s					  35s				  36s			</p>
<p>100w条 数据，固定10个线程，测试多线程+批量插入的batchSize对性能的影响</p>
<p>一次传输数据量							1k					1w					10w</p>
<p>​														27s				 42s					48s</p>
<p>经过实践测试，暂时有以下结论<br>1.批量插入远比单条插入的性能要高得多，是几十倍的性能提升</p>
<p>2.批量插入的数据量大小如何确定，通过一次次调整批量插入的数据量大小对性能影响，最终得出一个性能较高的数据量大小。但带宽对性能影响不是很大，可能就是8&#x2F;1-10&#x2F;1的优化吧</p>
<p>小解读：带宽越大，需要建立的数据连接越少，所以关于网络带宽和数据库连接要综合考虑以及多次测试才能得出一个恰当的数据</p>
<p>鱼皮小tips：极限值是数据库连接资源最大化利用+带宽资源最大化利用，当然千万不要在生产环境这样弄，上来就占用那么多资源，其他需要资源的功能怎么办，而且推荐测试循序渐进，数据量逐渐增多，可以及早发现的问题，不然一上来数据量就这么大，问题一出就会很严重</p>
<p>3.多线程(线程池)+批量插入。线程池中的核心线程数，最大线程数应如何确定？</p>
<p>​	关于核心线程数，最大线程数如何确定的问题，这里借美团技术团队的文章来浅答以下(我自己的水平有限)</p>
<p>​	通过阅读美团技术团队对线程池参数的解读，发现线程池的参数是很难有一个标准答案，不同的业务差异是非常大的，不同的任务类型差距业非常大，所以美团选择了一个折中的方案，就是动态化+实时监控线程池的状态，根据实际业务状况实时调整线程池的参数</p>
<p>4.确定了线程池的核心参数后，那么业务实际分配的线程数又该如何确定呢？</p>
<p>我从鱼皮视频中学到的思路就是不断的测试，实践才能得到真知，线程数，数据量逐渐增大，每个层级的线程数和数据量进行测试，当经过了大量的测试后，得到一个较为恰当的答案应该是没问题的</p>
<p>实验中的测试案例</p>
<p>​	其实你会发现多线程到15个的时候，无论再怎么增加线程数，性能都不会有多大变化，证明性能的瓶颈到了，且瓶颈不是线程数的问题，也不是数据库连接数的问题了(因为已经用批量插入优化了，也测试过了)，很有可能就是数据库同一时刻只能处理这么多插入数据，是数据库本身的性能瓶颈到了，但是多线程对比单线程性能是足足提高了50%-60%，至于业务实际要分配多少个线程数，我想没什么比实践的结果来得更可靠，一次一次测试，直到得到最恰当的数值，自然就是业务所需的实际线程数分配了</p>
<p>5.遗留的问题<br>    为什么我直接使用线程池而不是结合CompletableFuture执行插入任务的时候，任务虽然执行了，但一条数据都没有插入，这应该跟Mybatis-plus本身批量插入数据的实现有关，导致有这样的现象，如果主线程运行结束，那么批量插入数据的线程也会自动运行结束，因为主线程非常快就结束了，自然而然其他工作线程也就被迫结束了</p>
<h1 id="进一步深入领悟学习方法"><a href="#进一步深入领悟学习方法" class="headerlink" title="进一步深入领悟学习方法"></a>进一步深入领悟学习方法</h1><p><strong>问题</strong></p>
<p><strong>在学习JUC并发编程时发现我对每一个知识点都学习的非常的零碎，完全无法串起来，每个知识点的知识体系完全无法搭建起来，学起来非常的乱，东懂一块西懂一块的</strong></p>
<p>解决方案：使用是什么，为什么，怎么做三步学习法(无论是在输入还是)</p>
<p>深刻的领悟到学习(输入)一个知识为什么要遵守是什么？为什么？怎么做这三步学习法了，体会到三步学习法对于学习的重要作用，<strong>简单用一句话概括就是在输入知识时可以帮助我们带着问题去学习，引导我们主动去思考的学习。在输出知识时可以帮助我们以层层递减(是什么，为什么，怎么做..)的关系将琐碎的知识点串联起来形成一个小的知识体系</strong></p>
<p><strong>更深入的体会到他的作用不仅是在输入的过程让我带着目标去学习，引导我们主动思考而非被动思考，还能帮助我们把零碎的知识点以逻辑的层层递进关系把零碎的知识点串联成一个小的知识体系， 形成某一个知识点的知识体系对学习和理解该知识点起到了至关重要的作用</strong></p>
<p><strong>疑问</strong></p>
<p>知识点内部的零碎知识可以使用三步法串联起来，但大的知识点与知识点如何串联起来呢？如何找到他们的关联呢？只有将每个章节的知识都串联起来才能形成该技术 or 学科的完整 知识体系，在这一点上我尚且较为模糊，不知道具体怎么找到他们之间的关联</p>
<h1 id="操作系统聊天课程设计问题"><a href="#操作系统聊天课程设计问题" class="headerlink" title="操作系统聊天课程设计问题"></a>操作系统聊天课程设计问题</h1><p><strong>1.如何在泛型集合中添加泛型元素时选择添加其泛型的子类元素？</strong></p>
<p>泛型本身就支持集合中添加其子类元素，但如果是泛型中包含泛型，想要支持被包含泛型中的子类元素添加，就需要将泛型设计成&lt;? extend 父类&gt; 或者将泛型设计成&lt; ? &gt;，前者是类型上限是父类，后者的类型上限是Object</p>
<p><strong>2.关于泛型结合继承实现类型动态化还是有待深入学习</strong></p>
<p>在仔细琢磨了一个小时后发现泛型是编译时行为，也就是编译时就需要知道准确的类型。而多态是运行时行为，只有运行时才知道实际的类型，二者可以结合使用，典型的jdk8的函数式接口就是二者的结合体。函数式接口既可以实现参数类型的动态化，又可以实现运行时的动态绑定</p>
<p>综合上述的理解，泛型是用来实现编译时类型的动态化，而多态是用来实现运行时类型的动态化，二者的侧重点和应用场景不一样。编译时类型的动态可以借鉴mybatis-plus的BaseMapper的泛型继承体系进行学习，完全是一致的</p>
<p><strong>但我发现如果泛型结合多态使用(即实际的类型是泛型包泛型的情况)，如果将对应的实例加入到容器中时，容器是很难识别嵌套泛型的类型的，当你从 容器中获取元素时，就会发现嵌套的泛型只能被识别为Object类型，这样等于是要自己做好类型检查的防范工作，否则就会类型转换异常</strong></p>
<p><strong>3.解决方案：泛型+多态结合使用就不应该再结合容器使用，因为容器识别不出嵌套泛型的类型，会有可能出现bug，我的解决方案是去掉泛型</strong></p>
<p>现在我把类的泛型去掉了，不需要泛型实现动态类型的变化，而是在接口方法参数中使用顶级父类接收类型(如果是泛型的话接口方法的参数则是泛型参数)，再在具体的子类中进行类型转换即可，也可以实现动态类型的变化</p>
<p>4.关于函数式接口的深入理解，<strong>函数接口实际上就是泛型+多态+面向接口编程的思想</strong>，其中泛型是如何指定的呢？因为其泛型是加在接口上的，只要在实现类中指明泛型的类型即可，如果使用Lambda表达式的话，可以在方法参数上显式指定参数类型而不是用他的类型推断，返回值可以使用其类型推断，因为非常的明显</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/01/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="clks8c8ng0003hcor857e01zn" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  
  <a href="/2023/08/01/desgin-pattern/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">desgin-pattern</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>程序猿-小陈 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/shark.svg" alt="程序猿-小陈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>